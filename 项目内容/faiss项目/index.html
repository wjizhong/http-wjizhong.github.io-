<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <meta name="author" content="wjizhong">
    <link rel="canonical" href="https://wjizhong.github.io/%E9%A1%B9%E7%9B%AE%E5%86%85%E5%AE%B9/faiss%E9%A1%B9%E7%9B%AE/">
    <link rel="shortcut icon" href="https://pic.pngsucai.com/00/18/26/4a7884c36067e596.jpg">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>faiss项目 - 图像/视频算法</title>
    <link href="../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../css/highlight.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../js/jquery-3.2.1.min.js"></script>
    <script src="../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "faiss\u6559\u7a0b", url: "#_top", children: [
              {title: "\u4e00\u3001faiss\u6559\u7a0b", url: "#faiss_1" },
              {title: "\u4e8c\u3001faiss\u539f\u7406", url: "#faiss_2" },
              {title: "\u4e09\u3001\u6e90\u7801\u4ecb\u7ecd", url: "#_1" },
          ]},
        ];

    </script>
    <script src="../../js/base.js"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    <style>
blockquote{
    font-size: 99%;
}
</style>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  CommonHTML: {
    scale: 85
  }
});
</script>
<script type="text/javascript" async
src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


    
    
      
    

    

    <h1 id="faiss">faiss教程<a class="headerlink" href="#faiss" title="Permanent link">&para;</a></h1>
<h2 id="faiss_1">一、faiss教程<a class="headerlink" href="#faiss_1" title="Permanent link">&para;</a></h2>
<h3 id="11-faiss">1.1  faiss教程<a class="headerlink" href="#11-faiss" title="Permanent link">&para;</a></h3>
<p>Faiss是Facebook AI团队开源的针对聚类和相似性搜索库,为稠密向量提供高效相似度搜索和聚类,支持十亿级别向量的搜索,是目前最为成熟的近似近邻搜索库。它包含多种搜索任意大小向量集(备注:向量集大小由RAM内存决定)的算法,以及用于算法评估和参数调整的支持代码。Faiss用C++编写,并提供与Numpy完美衔接的Python接口。除此以外,对一些核心算法提供了GPU实现。</p>
<ul>
<li><strong>关于相似性搜索</strong></li>
</ul>
<p>传统的数据库是由包含符号信息的结构化数据表组成。比如,一个图片集可以表示为一个数据表,每行代表一个被索引的图片,包含图片标识符和描述文字之类的信息;每一行也可以与其他数据表中的实体关联起来,比如某个用户的一张图片可以与用户姓名表建立关联。</p>
<p>像文本嵌入(word2vec)或者卷积神经网络(CNN)描述符这样通过深度学习训练出的AI工具,都可以生成高维向量。这种表示远比一个固定的符号表示更加强大和灵活,正如后文将解释的那样。然而使用SQL查询的传统数据库并不适用这些新的表示方式。首先,海量多媒体信息的涌入产生了数十亿的向量;其次,且更重要的是,查找相似实体意味着查找相似的高维向量,如果只是使用标准查询语言这将非常低效和困难。</p>
<ul>
<li><strong>如何使用向量表示?</strong></li>
</ul>
<p>假设有一张建筑物的图片——比如某个你不记得名字的中等规模城市的市政大厅——然后你想在图片集中查找所有该建筑物的图片。由于不记得城市的名字,此时传统SQL中常用的key/value查询就帮不上忙了。这就是相似性搜索的用武之地了。图片的向量化表示旨在为相似的图片生成相似向量,这里相似向量定义为欧氏距离最近的向量。</p>
<p>向量化表示的另一个应用是分类。假设需要一个分类器,来判定某个相册中的哪些图片属于菊花。分类器的训练过程众所周知:给算法分别输入菊花的图片和非菊花的图片(比如汽车、羊、玫瑰、矢车菊等);如果分类器是线性的,那么就输出一个分类向量,其属性值是它与图片向量的点积,反映了该图片包含菊花的可能性;然后分类器可以与相册中所有图片计算点积,并返回点积最大的图片。这种查询就是"最大内积"搜索。</p>
<p>所以,对于相似性搜索和分类,我们需要做下列处理:</p>
<blockquote>
<ul>
<li>给定一个查询向量,返回与该向量的欧式距离最近的数据库对象列表。</li>
<li>给定一个查询向量,返回与该向量点积最大的数据库对象列表。</li>
<li>一个额外的挑战是,要在一个超大规模比如数十亿向量上做这些运算。</li>
</ul>
</blockquote>
<ul>
<li><strong>软件包</strong></li>
</ul>
<p>现有软件工具都不足以完成上述数据库检索操作。传统的SQL数据库系统也不太适合,因为它们是为基于哈希的检索或1维区间检索而优化的;像OpenCV等软件包中的相似性搜索功能在扩展性方面则严重受限;同时其他的相似性搜索类库主要适用于小规模数据集(比如,1百万大小的向量);另外的软件包基本是为发表论文而输出的学术研究产物,旨在展示某些特定设置下的效果。</p>
<p><img alt="" src="http://static001.infoq.cn/resource/image/90/74/906cc6ca574b43c5bdf3a2df8dcdb774.png" /></p>
<p>faiss类库则解决了以上提到的种种局限,其优点如下:</p>
<blockquote>
<ul>
<li>提供了多种相似性搜索方法,支持各种各样的不同用法和功能集。</li>
<li>特别优化了内存使用和速度。</li>
<li>为最相关索引方法提供了最先进的GPU实现。</li>
</ul>
</blockquote>
<ul>
<li><strong>相似性搜索评估</strong></li>
</ul>
<p>一旦从学习系统(从图片、视频、文本文件以及其他地方)抽取出向量,就能准备将其用于相似性搜索类库。我们有一个暴力算法作为参考对比,该算法计算出了所有的相似度——非常精确和齐全——然后返回最相似的元素列表。这就提供了一个黄金标准的参考结果列表。需要注意的是,暴力算法的高效实现并不简单,一般依赖于其他组件的性能。</p>
<p>如果牺牲一些精度的话,比如允许与参考结果有一点点偏差,那么相似性搜索能快几个数量级。举个例子,如果一张图片的相似性搜索结果中的第一个和第二个交换了,可能并没有太大问题,因为对于一个给定的查询,它们可能都是正确结果。加快搜索速度还涉及到数据集的预处理,我们通常把这个预处理操作称作索引。</p>
<p>这样一来我们就关注到下面三个指标:</p>
<blockquote>
<p><strong>速度</strong> :找到与查询最相似的10个或更多个向量要耗时多久?期望比暴力算法耗时更少,不然索引的意义何在?</p>
<p><strong>内存消耗</strong> :该方法需要消耗多少RAM?比原始向量更多还是更少?Faiss支持只在RAM上搜索,而磁盘数据库就会慢几个数量级,即便是SSD也是一样。</p>
<p><strong>精确度</strong> :返回的结果列表与暴力搜索结果匹配程度如何?精确度可以这样评估,计算返回的真正最近邻结果在查询结果第一位(这个指标一般叫做1-recall@1)的数量,或者衡量返回结果前10个(即指标10-intersection)中包含10个最近邻结果的平均占比。</p>
</blockquote>
<p>通常我们都会在确定的内存资源下在速度和精准度之间权衡。Faiss专注于压缩原始向量的方法,因为这是扩展到数十亿向量数据集的不二之选:当必须索引十亿个向量的时候,每个向量32字节,就会消耗很大的内存。</p>
<p>许多索引类库适用于百万左右向量的小规模数据集,比如nmslib就包含了一些适于这种规模数据的非常高效的算法,这比Faiss快很多,但需要消耗更多的存储。</p>
<ul>
<li><strong>基于10亿向量的评估</strong></li>
</ul>
<p>由于工程界并没有针对这种大小数据集的公认基准,所以我们就基于研究结果来评估。</p>
<p>评估精度基于Deep1B,这是一个包含10亿图片的数据集。每张图片已通过CNN处理,CNN激活图之一用于图片描述。比较这些向量之间的欧氏距离,就能量化图片的相似程度。</p>
<p>Deep1B还带有一个较小的查询图片集,以及由暴力算法产生的真实相似性搜索结果。因此,如果运行一个搜索算法,就能评估结果中的1-recall@1。</p>
<ul>
<li><strong>选择索引</strong></li>
</ul>
<p>为了评估,我们把内存限制在30G以内。这个内存约束是我们选择索引方法和参数的依据。Faiss中的索引方法表示为一个字符串,在本例中叫做<code>OPQ20_80</code>,<code>IMI2x14</code>,<code>PQ20</code>。该字符串包含的信息有,作用到向量上的预处理步骤(<code>OPQ20_80</code>),一个选择机制(IMI2x14)表明数据库如何分区,以及一个编码组件(PQ20)表示向量编码时使用一个产品量化器(PQ)来生成一个20字节的编码。所以在内存使用上,包括其他开销,累计少于30G。这听起来技术性较强,所以Faiss文档提供了使用指南,来说明如何选择满足需求的最佳索引。</p>
<p>选好了索引类型,就可以开始执行索引过程了。Faiss中的算法实现会处理10亿向量并把它们置于一个索引库中。索引会存在磁盘上或立即使用,检索和增加/移除索引的操作可以穿插进行。</p>
<ul>
<li><strong>查询索引</strong></li>
</ul>
<p>当索引准备好以后,一系列搜索时间参数就会被设置来调整算法。为方便评估,这里使用单线程搜索。由于内存消耗是受限并固定的,所以需要在精确度和搜索时间之间权衡优化。举例说来,这表示为了获取40%的1-recall@1,可以设置参数以花费尽可能短的搜索时间。</p>
<p>幸运的是,Faiss带有一个自动调优机制,能扫描参数空间并收集提供最佳操作点的参数;也就是说,最可能的搜索时间对应某个精确度,反之亦然,最优的精确度对应某个搜索时间。Deep1B中操作点被可视化为如下图示:</p>
<p><img alt="" src="http://static001.infoq.cn/resource/image/20/15/200428156d590d96d8b05667f67b4115.png" /></p>
<p>本图中我们可以看到,达到40%的1-recall@1,要求每次查询耗时必须小于2ms,或者能优化到耗时0.5ms的话,就可以达到30%的1-recall@1。一次查询耗时2ms表示单核500QPS的处理能力。</p>
<p>这个结果基本上能媲美目前业内最新研究成果了,即Babenko和Lempitsky在CVPR 2016发表的论文"Efficient Indexing of Billion-Scale Datasets of Deep Descriptors",这篇论文介绍了Deep1B数据集,他们达到45%的1-recall@1需要耗时20ms。</p>
<ul>
<li><strong>10亿级数据集的GPU计算</strong></li>
</ul>
<p>GPU实现方面也做了很大的投入,在原生多GPU的支持下能产出惊人的单机性能。GPU实现已经可以作为对应CPU设备的替代,无需了解CUDA API就能挖掘出GPU的性能。Faiss支持所有Nvidia2012之后发布的GPU(Kepler,计算能力3.5+)。</p>
<p>我们把roofline model作为指南,它指出应当尽量让内存带宽或浮点运算单元满载。Faiss的GPU实现在单GPU上的性能要比对应的CPU实现快5到10倍,像英伟达P100这样的新型Pascal架构硬件甚至会快20倍以上。</p>
<p>一些性能关键数字:</p>
<blockquote>
<ul>
<li>对于近似的索引,使用YFCC100M数据集中的9500万张图片,一个基于128D CNN描述符的暴力k近邻图(k=10),只需4个Maxwell TitanX GPU就能在35分钟内构建完成,包括索引构建时间。</li>
<li>十亿级向量的k近邻图现在触手可及。基于Deep1B数据集,可以构建一个暴力k-NN图(k=10),达到0.65的10-intersection,需要使用4个Maxwell TitanX GPU花费不到12小时,或者达到0.8,使用8个Pascal P100-PCIe GPU消耗不到12小时。TitanX配置可以在不到5小时生成低质量的图。</li>
<li>其他组件也表现出了骄人的性能。比如,构建上述Deep1B索引需要使用k均值聚类6701万个120维的向量到262,144个簇,对于25E-M迭代需要在4个Titan X GPU(12.6tflop/s)上花139分钟,或者在8个P100 GPU(40tflop/s)上花43.8分钟。注意聚类的训练数据集并不需要放在GPU内存中,因为数据可以在需要时流到GPU而没有额外的性能影响。</li>
</ul>
</blockquote>
<ul>
<li><strong>底层实现</strong></li>
</ul>
<p>Facebook AI研究团队2015年就开始开发Faiss,这建立在许多研究成果和大量工程实践的基础之上。对于Faiss类库,我们选择聚焦在一些基础技术方面的优化,特别是在CPU方面,我们重度使用了:</p>
<blockquote>
<ul>
<li>采用多线程来利用多核资源,并在多个GPU上执行并行检索。</li>
<li>使用BLAS类库通过矩阵和矩阵乘法来高效精准地完成距离计算。一个不采用BLAS的暴力实现很难达到最优。BLAS/LAPACK是Faiss唯一强制依赖的软件。</li>
<li>采用机器SIMD向量化和popcount加速独立向量的距离计算。</li>
</ul>
</blockquote>
<ul>
<li><strong>关于GPU</strong></li>
</ul>
<p>对于前述相似性搜索的GPU实现,k-selection(查找k个最小或最大元素)有一个性能问题,因为传统CPU算法(比如堆查找算法)对GPU并不友好。针对Faiss GPU,我们设计了文献中已知的最快轻量k-selection算法(k&lt;=1024)。所有的中间状态全部保存在寄存器,方便高速读写。可以对输入数据一次性完成k-select,运行至高达55%的理论峰值性能,作为输出的峰值GPU内存带宽。因为其状态单独保存在寄存器文件中,所以与其他内核很容易集成,使它成为极速的精准和近似检索算法。</p>
<p>大量的精力投在了为高效策略做铺垫,以及近似搜索的内核实现。通过数据分片或数据副本可以提供对多核GPU支持,而不会受限于单GPU的可用显存大小;还提供了对半精度浮点数的支持(float16),可在支持的GPU上做完整float16运算,以及早期架构上提供的中间float16存储。我们发现以float16编码向量技术可以做到精度无损加速。</p>
<p>简而言之,对关键因素的不断突破在实践中非常重要,faiss确实在工程细节方面下了很大的功夫。</p>
<h3 id="12-faiss">1.2 faiss使用<a class="headerlink" href="#12-faiss" title="Permanent link">&para;</a></h3>
<p>参考:<a href="https://github.com/facebookresearch/faiss/wiki"><code>https://github.com/facebookresearch/faiss/wiki</code></a></p>
<p>这里仅使用python版,如果需要了解C++版,请参考<a href="https://github.com/facebookresearch/faiss/wiki">github wiki</a>。</p>
<p>faiss总体使用过程可以分为三步:</p>
<blockquote>
<ul>
<li>构建训练数据(以矩阵形式表达)</li>
<li>挑选合适的Index(Faiss的核心部件),将训练数据add进Index中。</li>
<li>Search,也就是搜索,得到最后结果</li>
</ul>
</blockquote>
<p><strong>构建训练数据</strong></p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="n">d</span> <span class="o">=</span> <span class="mi">64</span>                           <span class="c1"># dimension</span>
<span class="n">nb</span> <span class="o">=</span> <span class="mi">100000</span>                      <span class="c1"># database size</span>
<span class="n">nq</span> <span class="o">=</span> <span class="mi">10000</span>                       <span class="c1"># nb of queries</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">1234</span><span class="p">)</span>             <span class="c1"># make reproducible</span>
<span class="n">xb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="n">nb</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float32&#39;</span><span class="p">)</span>
<span class="n">xb</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nb</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1000.</span>
<span class="n">xq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="n">nq</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float32&#39;</span><span class="p">)</span>
<span class="n">xq</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nq</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1000.</span>
</pre></div>

<p>上面的代码,生成了训练数据矩阵xd,以及查询数据矩阵xq。仅仅为了好玩,分别在xd和xq所有数据的第一个维度中添加了一个偏移量,并且偏移量随着id数字的增大而增大。</p>
<p><strong>创建Index对象以及add训练数据</strong></p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">faiss</span>                   <span class="c1"># make faiss available</span>
<span class="n">index</span> <span class="o">=</span> <span class="n">faiss</span><span class="o">.</span><span class="n">IndexFlatL2</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>   <span class="c1"># build the index</span>
<span class="k">print</span><span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">is_trained</span><span class="p">)</span>
<span class="n">index</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">xb</span><span class="p">)</span>                  <span class="c1"># add vectors to the index</span>
<span class="k">print</span><span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">ntotal</span><span class="p">)</span>
</pre></div>

<p>faiss是围绕Index对象构建的,Faiss也提供了许多种类的Index,这里简单起见,使用IndexFlatL2:一个蛮力L2距离搜索的索引。所有索引都需要知道它们是何时构建的,它们运行的向量维数是多少(在我们的例子中是d),然后,大多数索引还需要训练阶段(training phase),以分析向量的分布。对于IndexFlatL2,我们可以跳过此操作。</p>
<p><strong>搜索</strong></p>
<div class="highlight"><pre><span></span><span class="n">k</span> <span class="o">=</span> <span class="mi">4</span>                          <span class="c1"># we want to see 4 nearest neighbors</span>
<span class="n">D</span><span class="p">,</span> <span class="n">I</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">xb</span><span class="p">[:</span><span class="mi">5</span><span class="p">],</span> <span class="n">k</span><span class="p">)</span> <span class="c1"># sanity check</span>
<span class="k">print</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>

<span class="n">D</span><span class="p">,</span> <span class="n">I</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">xq</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>     <span class="c1"># actual search</span>
<span class="k">print</span><span class="p">(</span><span class="n">I</span><span class="p">[:</span><span class="mi">5</span><span class="p">])</span>                   <span class="c1"># neighbors of the 5 first queries</span>
<span class="k">print</span><span class="p">(</span><span class="n">I</span><span class="p">[</span><span class="o">-</span><span class="mi">5</span><span class="p">:])</span>                  <span class="c1"># neighbors of the 5 last queries</span>
</pre></div>

<p>可以对索引执行的基本搜索操作是k最近邻搜索,即:对于每个查询向量,在数据库中查找其k个最近邻居。所以结果集应该是一个size为<code>nq*k</code>的矩阵。</p>
<p>上述代码,做了两次搜索:</p>
<blockquote>
<p>第一次的查询数据,直接使用了训练数据的前5行,这样子更加有比较性。I和D分别代表Id和Distance,也就是距离和邻居的id。结果分别如下：</p>
</blockquote>
<div class="highlight"><pre><span></span><span class="p">[[</span>  <span class="mi">0</span> <span class="mi">393</span> <span class="mi">363</span>  <span class="mi">78</span><span class="p">]</span>
 <span class="p">[</span>  <span class="mi">1</span> <span class="mi">555</span> <span class="mi">277</span> <span class="mi">364</span><span class="p">]</span>
 <span class="p">[</span>  <span class="mi">2</span> <span class="mi">304</span> <span class="mi">101</span>  <span class="mi">13</span><span class="p">]</span>
 <span class="p">[</span>  <span class="mi">3</span> <span class="mi">173</span>  <span class="mi">18</span> <span class="mi">182</span><span class="p">]</span>
 <span class="p">[</span>  <span class="mi">4</span> <span class="mi">288</span> <span class="mi">370</span> <span class="mi">531</span><span class="p">]]</span>

<span class="p">[[</span> <span class="mf">0.</span>          <span class="mf">7.17517328</span>  <span class="mf">7.2076292</span>   <span class="mf">7.25116253</span><span class="p">]</span>
 <span class="p">[</span> <span class="mf">0.</span>          <span class="mf">6.32356453</span>  <span class="mf">6.6845808</span>   <span class="mf">6.79994535</span><span class="p">]</span>
 <span class="p">[</span> <span class="mf">0.</span>          <span class="mf">5.79640865</span>  <span class="mf">6.39173603</span>  <span class="mf">7.28151226</span><span class="p">]</span>
 <span class="p">[</span> <span class="mf">0.</span>          <span class="mf">7.27790546</span>  <span class="mf">7.52798653</span>  <span class="mf">7.66284657</span><span class="p">]</span>
 <span class="p">[</span> <span class="mf">0.</span>          <span class="mf">6.76380348</span>  <span class="mf">7.29512024</span>  <span class="mf">7.36881447</span><span class="p">]]</span>
</pre></div>

<p>I直接显示了与搜索向量最相近的4个邻居的ID,D显示了与搜索向量之间的距离。</p>
<p>第二次的搜索结果如下:</p>
<div class="highlight"><pre><span></span><span class="p">[[</span> <span class="mi">381</span>  <span class="mi">207</span>  <span class="mi">210</span>  <span class="mi">477</span><span class="p">]</span>
 <span class="p">[</span> <span class="mi">526</span>  <span class="mi">911</span>  <span class="mi">142</span>   <span class="mi">72</span><span class="p">]</span>
 <span class="p">[</span> <span class="mi">838</span>  <span class="mi">527</span> <span class="mi">1290</span>  <span class="mi">425</span><span class="p">]</span>
 <span class="p">[</span> <span class="mi">196</span>  <span class="mi">184</span>  <span class="mi">164</span>  <span class="mi">359</span><span class="p">]</span>
 <span class="p">[</span> <span class="mi">526</span>  <span class="mi">377</span>  <span class="mi">120</span>  <span class="mi">425</span><span class="p">]]</span>

<span class="p">[[</span> <span class="mi">9900</span> <span class="mi">10500</span>  <span class="mi">9309</span>  <span class="mi">9831</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">11055</span> <span class="mi">10895</span> <span class="mi">10812</span> <span class="mi">11321</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">11353</span> <span class="mi">11103</span> <span class="mi">10164</span>  <span class="mi">9787</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">10571</span> <span class="mi">10664</span> <span class="mi">10632</span>  <span class="mi">9638</span><span class="p">]</span>
 <span class="p">[</span> <span class="mi">9628</span>  <span class="mi">9554</span> <span class="mi">10036</span>  <span class="mi">9582</span><span class="p">]]</span>
</pre></div>

<ul>
<li><strong>更快查询</strong></li>
</ul>
<p>为了加快搜索速度,我们可以按照一定规则或者顺序将数据集分段。我们可以在d维空间中定义Voronoi单元,并且每个数据库向量都会落在其中一个单元。在搜索时,查询向量x,可以经过计算,算出它会落在哪个单元格中。然后我们只需要在这个单元格以及与它相邻的一些单元格中,进行与查询向量x的比较工作就可以了。(这里可以类比HashMap的实现原理,训练就是生成hashmap的过程,查询就是getByKey的过程)。</p>
<p>上述工作已经通过IndexIVFFlat实现了,这种类型的索引需要一个训练阶段,可以对与数据库矢量具有相同分布的任何矢量集合执行。在这种情况下,我们只使用数据库向量本身。IndexIVFFlat同时需要另外一个Index:quantizer,来给Voronoi单元格分配向量。每个单元格由质心(centroid)定义,找某个向量落在哪个Voronoi单元格的任务,就是一个在质心集合中找这个向量最近邻居的任务。这是另一个索引的任务,通常是IndexFlatL2。</p>
<p>这里搜索方法有两个参数:nlist(单元格数量),nprobe(一次搜索可以访问的单元格数量,默认为1)。搜索时间大致随着nprobe的值加上一些由于量化产生的常数,进行线性增长。代码如下:</p>
<div class="highlight"><pre><span></span><span class="n">nlist</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">k</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">quantizer</span> <span class="o">=</span> <span class="n">faiss</span><span class="o">.</span><span class="n">IndexFlatL2</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>  <span class="c1"># 另外一个 Index</span>
<span class="n">index</span> <span class="o">=</span> <span class="n">faiss</span><span class="o">.</span><span class="n">IndexIVFFlat</span><span class="p">(</span><span class="n">quantizer</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">nlist</span><span class="p">,</span> <span class="n">faiss</span><span class="o">.</span><span class="n">METRIC_L2</span><span class="p">)</span> <span class="c1"># 这里我们指定了 METRIC_L2, 默认它执行inner-product搜索。</span>
<span class="k">assert</span> <span class="ow">not</span> <span class="n">index</span><span class="o">.</span><span class="n">is_trained</span>
<span class="n">index</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">xb</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">index</span><span class="o">.</span><span class="n">is_trained</span>

<span class="n">index</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">xb</span><span class="p">)</span>                  <span class="c1"># add may be a bit slower as well</span>
<span class="n">D</span><span class="p">,</span> <span class="n">I</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">xq</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>     <span class="c1"># actual search</span>
<span class="k">print</span><span class="p">(</span><span class="n">I</span><span class="p">[</span><span class="o">-</span><span class="mi">5</span><span class="p">:])</span>                  <span class="c1"># neighbors of the 5 last queries</span>
<span class="n">index</span><span class="o">.</span><span class="n">nprobe</span> <span class="o">=</span> <span class="mi">10</span>              <span class="c1"># default nprobe is 1, try a few more</span>
<span class="n">D</span><span class="p">,</span> <span class="n">I</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">xq</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">I</span><span class="p">[</span><span class="o">-</span><span class="mi">5</span><span class="p">:])</span>                  <span class="c1"># neighbors of the 5 last queries</span>
</pre></div>

<p>运行结果</p>
<blockquote>
<p>当nprobe=1的输出:</p>
</blockquote>
<div class="highlight"><pre><span></span><span class="p">[[</span> <span class="mi">9900</span> <span class="mi">10500</span>  <span class="mi">9831</span> <span class="mi">10808</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">11055</span> <span class="mi">10812</span> <span class="mi">11321</span> <span class="mi">10260</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">11353</span> <span class="mi">10164</span> <span class="mi">10719</span> <span class="mi">11013</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">10571</span> <span class="mi">10203</span> <span class="mi">10793</span> <span class="mi">10952</span><span class="p">]</span>
 <span class="p">[</span> <span class="mi">9582</span> <span class="mi">10304</span>  <span class="mi">9622</span>  <span class="mi">9229</span><span class="p">]]</span>
</pre></div>

<p>结果与蛮力搜索类似,但不完全相同(见上文),这是因为一些结果不在完全相同的Voronoi单元格中。因此,访问更多的单元格可能会有用。</p>
<blockquote>
<p>把nprobe上升到10的结果:</p>
</blockquote>
<div class="highlight"><pre><span></span><span class="p">[[</span> <span class="mi">9900</span> <span class="mi">10500</span>  <span class="mi">9309</span>  <span class="mi">9831</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">11055</span> <span class="mi">10895</span> <span class="mi">10812</span> <span class="mi">11321</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">11353</span> <span class="mi">11103</span> <span class="mi">10164</span>  <span class="mi">9787</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">10571</span> <span class="mi">10664</span> <span class="mi">10632</span>  <span class="mi">9638</span><span class="p">]</span>
 <span class="p">[</span> <span class="mi">9628</span>  <span class="mi">9554</span> <span class="mi">10036</span>  <span class="mi">9582</span><span class="p">]]</span>
</pre></div>

<p>这个就是正确的结果。请注意,在这种情况下获得完美结果仅仅是数据分布的工件,因为它在x轴上具有强大的组件,这使得它更容易处理。nprobe参数始终是调整结果的速度和准确度之间权衡的一种方法。设置nprobe=nlist会产生与暴力搜索相同的结果(但速度较慢)。</p>
<ul>
<li><strong>减少内存占用</strong></li>
</ul>
<p>IndexFlatL2和IndexIVFFlat都会存储所有的向量。为了扩展到非常大的数据集,Faiss提供了一些变体,它们根据产品量化器(productquantizer)压缩存储的矢量并进行有损压缩。矢量仍然存储在Voronoi单元中,但是它们的大小减小到可配置的字节数m(d必须是m的倍数)。压缩基于Product Quantizer,其可以被视为额外的量化水平,其应用于要编码的矢量的子矢量。</p>
<p>在这种情况下,由于矢量未精确存储,因此搜索方法返回的距离也是近似值。代码如下:</p>
<div class="highlight"><pre><span></span><span class="n">nlist</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">m</span> <span class="o">=</span> <span class="mi">8</span>                             <span class="c1"># number of bytes per vector</span>
<span class="n">k</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">quantizer</span> <span class="o">=</span> <span class="n">faiss</span><span class="o">.</span><span class="n">IndexFlatL2</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>  <span class="c1"># this remains the same</span>
<span class="n">index</span> <span class="o">=</span> <span class="n">faiss</span><span class="o">.</span><span class="n">IndexIVFPQ</span><span class="p">(</span><span class="n">quantizer</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">nlist</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
                                    <span class="c1"># 8 specifies that each sub-vector is encoded as 8 bits</span>
<span class="n">index</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">xb</span><span class="p">)</span>
<span class="n">index</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">xb</span><span class="p">)</span>
<span class="n">D</span><span class="p">,</span> <span class="n">I</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">xb</span><span class="p">[:</span><span class="mi">5</span><span class="p">],</span> <span class="n">k</span><span class="p">)</span> <span class="c1"># sanity check</span>
<span class="k">print</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
<span class="n">index</span><span class="o">.</span><span class="n">nprobe</span> <span class="o">=</span> <span class="mi">10</span>              <span class="c1"># make comparable with experiment above</span>
<span class="n">D</span><span class="p">,</span> <span class="n">I</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">xq</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>     <span class="c1"># search</span>
<span class="k">print</span><span class="p">(</span><span class="n">I</span><span class="p">[</span><span class="o">-</span><span class="mi">5</span><span class="p">:])</span>
</pre></div>

<p>结果看起来时这个样子的:</p>
<div class="highlight"><pre><span></span><span class="p">[[</span>   <span class="mi">0</span>  <span class="mi">608</span>  <span class="mi">220</span>  <span class="mi">228</span><span class="p">]</span>
 <span class="p">[</span>   <span class="mi">1</span> <span class="mi">1063</span>  <span class="mi">277</span>  <span class="mi">617</span><span class="p">]</span>
 <span class="p">[</span>   <span class="mi">2</span>   <span class="mi">46</span>  <span class="mi">114</span>  <span class="mi">304</span><span class="p">]</span>
 <span class="p">[</span>   <span class="mi">3</span>  <span class="mi">791</span>  <span class="mi">527</span>  <span class="mi">316</span><span class="p">]</span>
 <span class="p">[</span>   <span class="mi">4</span>  <span class="mi">159</span>  <span class="mi">288</span>  <span class="mi">393</span><span class="p">]]</span>

<span class="p">[[</span> <span class="mf">1.40704751</span>  <span class="mf">6.19361687</span>  <span class="mf">6.34912491</span>  <span class="mf">6.35771513</span><span class="p">]</span>
 <span class="p">[</span> <span class="mf">1.49901485</span>  <span class="mf">5.66632462</span>  <span class="mf">5.94188499</span>  <span class="mf">6.29570007</span><span class="p">]</span>
 <span class="p">[</span> <span class="mf">1.63260388</span>  <span class="mf">6.04126883</span>  <span class="mf">6.18447495</span>  <span class="mf">6.26815748</span><span class="p">]</span>
 <span class="p">[</span> <span class="mf">1.5356375</span>   <span class="mf">6.33165455</span>  <span class="mf">6.64519501</span>  <span class="mf">6.86594009</span><span class="p">]</span>
 <span class="p">[</span> <span class="mf">1.46203303</span>  <span class="mf">6.5022912</span>   <span class="mf">6.62621975</span>  <span class="mf">6.63154221</span><span class="p">]]</span>
</pre></div>

<p>我们可以观察到我们正确找到了最近邻居(它是矢量ID本身),但是矢量与其自身的估计距离不是0,尽管它明显低于到其他邻居的距离。这是由于有损压缩造成的,这里我们将64个32位浮点数压缩为8个字节,因此压缩因子为32。搜索真实查询时,结果如下所示:</p>
<div class="highlight"><pre><span></span><span class="p">[[</span> <span class="mi">9432</span>  <span class="mi">9649</span>  <span class="mi">9900</span> <span class="mi">10287</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">10229</span> <span class="mi">10403</span>  <span class="mi">9829</span>  <span class="mi">9740</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">10847</span> <span class="mi">10824</span>  <span class="mi">9787</span> <span class="mi">10089</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">11268</span> <span class="mi">10935</span> <span class="mi">10260</span> <span class="mi">10571</span><span class="p">]</span>
 <span class="p">[</span> <span class="mi">9582</span> <span class="mi">10304</span>  <span class="mi">9616</span>  <span class="mi">9850</span><span class="p">]]</span>
</pre></div>

<p>它们可以与上面的IVFFlat结果进行比较。对于这种情况,大多数结果都是错误的,但它们位于空间的正确区域,如10000左右的ID所示。实际数据的情况更好,因为：</p>
<blockquote>
<p>统一数据很难索引,因为没有可用于聚类或降低维度的规律性</p>
<p>对于自然数据，语义最近邻居通常比不相关的结果更接近。</p>
</blockquote>
<ul>
<li><strong>简化索引构建</strong></li>
</ul>
<p>由于构建索引可能变得复杂,因此有一个工厂函数在给定字符串的情况下构造它们。上述索引可以通过以下简写获得:</p>
<p><div class="highlight"><pre><span></span><span class="n">index</span> <span class="o">=</span> <span class="n">faiss</span><span class="o">.</span><span class="n">index_factory</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="s2">&quot;IVF100,PQ8&quot;</span><span class="p">)</span>
</pre></div>
把”PQ8”替换为“Flat”,就可以得到一个IndexFlat。当需要预处理(PCA)应用于输入向量时,工厂就特别有用。例如要使用PCA投影将矢量减少到32D的预处理时,工厂字符串应该时:"PCA32,IVF100,Flat"。</p>
<ul>
<li><strong>使用GPU</strong></li>
</ul>
<div class="highlight"><pre><span></span><span class="c1"># 获取单个 GPU 资源</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">faiss</span><span class="o">.</span><span class="n">StandardGpuResources</span><span class="p">()</span>  <span class="c1"># use a single GPU</span>
<span class="c1"># 使用GPU资源构建GPU索引</span>
<span class="c1"># build a flat (CPU) index</span>
<span class="n">index_flat</span> <span class="o">=</span> <span class="n">faiss</span><span class="o">.</span><span class="n">IndexFlatL2</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="c1"># make it into a gpu index</span>
<span class="n">gpu_index_flat</span> <span class="o">=</span> <span class="n">faiss</span><span class="o">.</span><span class="n">index_cpu_to_gpu</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">index_flat</span><span class="p">)</span>
<span class="c1"># 多个索引可以使用单个GPU资源对象，只要它们不发出并发查询即可。</span>
<span class="c1"># 获得的GPU索引可以与CPU索引完全相同的方式使用:</span>
<span class="n">gpu_index_flat</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">xb</span><span class="p">)</span>         <span class="c1"># add vectors to the index</span>
<span class="k">print</span><span class="p">(</span><span class="n">gpu_index_flat</span><span class="o">.</span><span class="n">ntotal</span><span class="p">)</span>

<span class="n">k</span> <span class="o">=</span> <span class="mi">4</span>                          <span class="c1"># we want to see 4 nearest neighbors</span>
<span class="n">D</span><span class="p">,</span> <span class="n">I</span> <span class="o">=</span> <span class="n">gpu_index_flat</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">xq</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>  <span class="c1"># actual search</span>
<span class="k">print</span><span class="p">(</span><span class="n">I</span><span class="p">[:</span><span class="mi">5</span><span class="p">])</span>                   <span class="c1"># neighbors of the 5 first queries</span>
<span class="k">print</span><span class="p">(</span><span class="n">I</span><span class="p">[</span><span class="o">-</span><span class="mi">5</span><span class="p">:])</span>                  <span class="c1"># neighbors of the 5 last queries</span>
<span class="c1"># 使用多个GPU</span>
<span class="c1">## 使用多个GPU主要是声明几个GPU资源,在python中,这可以使用index_cpu_to_all_gpus帮助程序隐式完成。</span>

<span class="n">ngpus</span> <span class="o">=</span> <span class="n">faiss</span><span class="o">.</span><span class="n">get_num_gpus</span><span class="p">()</span>

<span class="k">print</span><span class="p">(</span><span class="s2">&quot;number of GPUs:&quot;</span><span class="p">,</span> <span class="n">ngpus</span><span class="p">)</span>

<span class="n">cpu_index</span> <span class="o">=</span> <span class="n">faiss</span><span class="o">.</span><span class="n">IndexFlatL2</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

<span class="n">gpu_index</span> <span class="o">=</span> <span class="n">faiss</span><span class="o">.</span><span class="n">index_cpu_to_all_gpus</span><span class="p">(</span>  <span class="c1"># build the index</span>
    <span class="n">cpu_index</span>
<span class="p">)</span>

<span class="n">gpu_index</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">xb</span><span class="p">)</span>              <span class="c1"># add vectors to the index</span>
<span class="k">print</span><span class="p">(</span><span class="n">gpu_index</span><span class="o">.</span><span class="n">ntotal</span><span class="p">)</span>

<span class="n">k</span> <span class="o">=</span> <span class="mi">4</span>                          <span class="c1"># we want to see 4 nearest neighbors</span>
<span class="n">D</span><span class="p">,</span> <span class="n">I</span> <span class="o">=</span> <span class="n">gpu_index</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">xq</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="c1"># actual search</span>
<span class="k">print</span><span class="p">(</span><span class="n">I</span><span class="p">[:</span><span class="mi">5</span><span class="p">])</span>                   <span class="c1"># neighbors of the 5 first queries</span>
<span class="k">print</span><span class="p">(</span><span class="n">I</span><span class="p">[</span><span class="o">-</span><span class="mi">5</span><span class="p">:])</span>                  <span class="c1"># neighbors of the 5 last queries</span>
</pre></div>

<p><img alt="" src="http://upload-images.jianshu.io/upload_images/5617720-56b8280f2c78029b.png?imageMogr2/auto-orient/strip|imageView2/2/w/569/format/webp" /></p>
<h2 id="faiss_2">二、faiss原理<a class="headerlink" href="#faiss_2" title="Permanent link">&para;</a></h2>
<h3 id="21-faiss">2.1 faiss核心算法实现<a class="headerlink" href="#21-faiss" title="Permanent link">&para;</a></h3>
<p><img alt="" src="http://raw.githubusercontent.com/wiki/facebookresearch/faiss/PQ_variants_Faiss_annotated.png" /></p>
<p>faiss对一些基础的算法提供了非常高效的失效</p>
<blockquote>
<ul>
<li>聚类Faiss提供了一个高效的k-means实现</li>
<li>PCA降维算法</li>
<li>PQ(Product Quantizer)编码/解码</li>
</ul>
</blockquote>
<h3 id="22-faiss">2.2 faiss功能流程说明<a class="headerlink" href="#22-faiss" title="Permanent link">&para;</a></h3>
<p>通过Faiss文档介绍可以了解faiss的主要功能就是相似度搜索。如下图所示,以图片搜索为例,所谓相似度搜索,便是在给定的一堆图片中,寻找出我指定的目标最像的K张图片,也简称为KNN(K近邻)问题。</p>
<p><img alt="" src="http://img2018.cnblogs.com/blog/1408825/201903/1408825-20190320225405798-259149897.png" /></p>
<p>为了解决KNN问题,在工程上需要实现对已有图库的存储,当用户指定检索图片后,需要知道如何从存储的图片库中找到最相似的K张图片。基于此,我们推测Faiss在应用场景中具备添加功能和搜索功能,有了添加相应的修改和删除功能也会接踵而来,从上述分析看,Faiss本质上是一个向量(矢量)数据库。</p>
<p>对于数据库来说,时空优化是两个永恒的主题,即在存储上如何以更少的空间来存储更多的信息,在搜索上如何以更快的速度来搜索出更准确的信息。如何减少搜索所需的时间?在数据库中很最常见的操作便是加各种索引,把各种加速搜索算法的功能或空间换时间的策略都封装成各种各样的索引,以满足各种不同的引用场景。</p>
<h3 id="23">2.3 组件分析<a class="headerlink" href="#23" title="Permanent link">&para;</a></h3>
<p>Faiss中最常用的是索引Index,而后是PCA降维、PQ乘积量化,这里针对Index和PQ进行说明,PCA降维从流程上都可以理解。</p>
<h4 id="231-index">2.3.1 索引Index<a class="headerlink" href="#231-index" title="Permanent link">&para;</a></h4>
<p>faiss中有两个基础索引类Index、IndexBinary,下面我们先从类图进行分析。下面给出Index和IndexBinary的类图如下所示:</p>
<p><img src="http://img2018.cnblogs.com/blog/1408825/201903/1408825-20190320225730601-1447506992.png" style="width:40%" /></p>
<p><img src="http://img2018.cnblogs.com/blog/1408825/201903/1408825-20190320225751231-231723243.png" style="width:40%" /></p>
<p>Faiss提供了针对不同场景下应用对Index的封装类,这里我们针对Index基类进行说明。</p>
<p><img src="http://img2018.cnblogs.com/blog/1408825/201903/1408825-20190320225820995-299814548.png" style="width:80%" /></p>
<p>基础索引的说明参考:<a href="http://github.com/facebookresearch/faiss/wiki/Faiss-indexes">Faiss indexes</a>涉及方法解释、参数说明以及推荐试用的工厂方法创建时的标识等。</p>
<p>索引的创建提供了工厂方法,可以通过字符串灵活的创建不同的索引。</p>
<div class="highlight"><pre><span></span><span class="n">index</span> <span class="o">=</span> <span class="n">faiss</span><span class="p">.</span><span class="n">index_factory</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="s">&quot;PCA32,IVF100,PQ8 &quot;</span><span class="p">)</span>
</pre></div>

<p>该字符串的含义为:使用PCA算法将向量降维到32维,划分成100个nprobe(搜索空间),通过PQ算法将每个向量压缩成8bit。其他的字符串可以参考上文给出的Faiss indexes链接中给出的标识。</p>
<ul>
<li><strong>索引说明</strong></li>
</ul>
<p>此部分对索引id进行说明,此部分的理解是基于PQ量化及Faiss创建不同的索引时选择的量化器而来,可能会稍有偏差,不影响对Faiss的使用操作。</p>
<p>默认情况,Faiss会为每个输入的向量记录一个次序id,也可以为向量指定任意我们需要的id。部分索引类(IndexIVFFlat/IndexPQ/IndexIVFPQ等)有<code>add_with_ids</code>方法,可以为每个向量对应一个64-bit的id,搜索的时候返回此id。此段中说明的id从我的角度理解就是索引。(备注:id是long型数据,所有的索引id类型在Index基类中已经定义,参考类图中标注,<code>typedef long idx_t;    ///&lt; all indices are this type</code>)</p>
<p>示例:</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">faiss</span>                   <span class="c1"># make faiss available</span>

<span class="c1"># 构造数据</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="n">d</span> <span class="o">=</span> <span class="mi">64</span>                           <span class="c1"># dimension</span>
<span class="n">nb</span> <span class="o">=</span> <span class="mi">1000000</span>                      <span class="c1"># database size</span>
<span class="n">nq</span> <span class="o">=</span> <span class="mi">1000000</span>                       <span class="c1"># nb of queries</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">1234</span><span class="p">)</span>             <span class="c1"># make reproducible</span>
<span class="n">xb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="n">nb</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float32&#39;</span><span class="p">)</span>
<span class="n">xb</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nb</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1000.</span>
<span class="n">xq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="n">nq</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float32&#39;</span><span class="p">)</span>
<span class="n">xq</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nq</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1000.</span>

<span class="c1"># 为向量集构建IndexFlatL2索引,它是最简单的索引类型,只执行强力L2距离搜索</span>
<span class="n">index</span> <span class="o">=</span> <span class="n">faiss</span><span class="o">.</span><span class="n">IndexFlatL2</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>   <span class="c1"># build the index</span>
<span class="c1"># #此处索引是按照默认方式,即faiss给的次序id为主</span>
<span class="c1"># #可以添加我们需要的索引方式,因IndexFlatL2不支持add_with_ids方法,需要借助IndexIDMap进行映射,代码如下</span>
<span class="c1"># ids = np.arange(100000, 200000)  #id设定为6位数整数,默认id从0开始,这里我们将其设置从100000开始</span>
<span class="c1"># index2 = faiss.IndexIDMap(index)</span>
<span class="c1"># index2.add_with_ids(xb, ids)</span>
<span class="c1">#</span>
<span class="c1"># print(index2.is_trained)</span>
<span class="c1"># # index.add(xb)                  # add vectors to the index</span>
<span class="c1"># print(index2.ntotal)</span>
<span class="c1"># k = 4   # we want to see 4 nearest neighbors</span>
<span class="c1"># D, I = index2.search(xb[:5], k) # sanity check</span>
<span class="c1"># print(I)     # 向量索引位置</span>
<span class="c1"># print(D)     # 相似度矩阵</span>

<span class="k">print</span><span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">is_trained</span><span class="p">)</span>
<span class="n">index</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">xb</span><span class="p">)</span>                  <span class="c1"># add vectors to the index</span>
<span class="k">print</span><span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">ntotal</span><span class="p">)</span>
<span class="n">k</span> <span class="o">=</span> <span class="mi">4</span>   <span class="c1"># we want to see 4 nearest neighbors</span>
<span class="c1"># D, I = index.search(xb[:5], k) # sanity check</span>
<span class="c1"># # print(xb[:5])</span>
<span class="c1"># print(I)     # 向量索引位置</span>
<span class="c1"># print(D)     # 相似度矩阵</span>

<span class="n">D</span><span class="p">,</span> <span class="n">I</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">xq</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>     <span class="c1"># actual search</span>
<span class="c1"># xq is the query data</span>
<span class="c1"># k is the num of neigbors you want to search</span>
<span class="c1"># D is the distance matrix between xq and k neigbors</span>
<span class="c1"># I is the index matrix of k neigbors</span>
<span class="k">print</span><span class="p">(</span><span class="n">I</span><span class="p">[:</span><span class="mi">5</span><span class="p">])</span>                   <span class="c1"># neighbors of the 5 first queries</span>
<span class="k">print</span><span class="p">(</span><span class="n">I</span><span class="p">[</span><span class="o">-</span><span class="mi">5</span><span class="p">:])</span> <span class="c1"># neighbors of the 5 last queries</span>

<span class="c1">#从index中恢复数据,indexFlatL2索引就是将向量进行排序</span>
<span class="c1"># print(xb[381])</span>
<span class="c1"># print(index.reconstruct(381))</span>
</pre></div>

<ul>
<li><strong>索引选择</strong></li>
</ul>
<p>此部分没做实践验证,对Faiss给的部分说明进行翻译过来作为后续我们使用的一个参考。</p>
<p>如果关心返回精度,可以使用IndexFlatL2,该索引能确保返回精确结果。一般将其作为baseline与其他索引方式对比,以便在精度和时间开销之间做权衡。不支持<code>add_with_ids</code>,如果需要,可以用“IDMap”给予任意定义id。</p>
<p>如果关注内存开销,可以使用"..., Flat“的索引,"..."是聚类操作,聚类之后将每个向量映射到相应的bucket。该索引类型并不会保存压缩之后的数据,而是保存原始数据,所以内存开销与原始数据一致。通过nprobe参数控制速度/精度。</p>
<p>对内存开销比较关心的话,可以在聚类的基础上使用PQ成绩量化进行处理。</p>
<ul>
<li><strong>检索数据恢复</strong></li>
</ul>
<p>Faiss检索返回的是数据的索引及数据的计算距离,在检索获得的索引后需要根据索引将原始数据取出。</p>
<p>Faiss提供了两种方式,一种是一条一条的进行恢复,一种是批量恢复。</p>
<p>给定id,可以使用reconstruct进行单条取出数据;可以使用<code>reconstruct_n</code>方法从index中回批量复出原始向量(备注:该方法从给的示例看是恢复连续的数据(0,10),如果索引是离散的话恢复数据暂时还没做实践)。</p>
<p>上述方法支持IndexFlat,IndexIVFFlat(需要与<code>make_direct_map</code>结合),IndexIVFPQ(需要与<code>make_direct_map</code>结合)等几类索引类型。</p>
<h4 id="232-product-quantizationpq">2.3.2 Product quantization(乘积量化PQ)<a class="headerlink" href="#232-product-quantizationpq" title="Permanent link">&para;</a></h4>
<p>Faiss中使用的乘积量化是Faiss的作者在2011年发表的论文,参考:<a href="https://hal.inria.fr/file/index/docid/514462/filename/paper_hal.pdf">Product Quantization for Nearest Neighbor Search</a></p>
<p>PQ算法可以理解为首先把原始的向量空间分解为m个低维向量空间的笛卡尔积,并对分解得到的低维向量空间分别做量化。即是把原始D维向量(比如D=128)分成m组(比如m=4),每组就是D∗=D/m维的子向量(比如D∗=D/m=128/4=32),各自用kmeans算法学习到一个码本,然后这些码本的笛卡尔积就是原始D维向量对应的码本。用qj表示第j组子向量,用Cj表示其对应学习到的码本,那么原始D维向量对应的码本就是C=C1×C2×…×Cm。用k∗表示子向量的聚类中心点数或者说码本大小,那么原始D维向量对应的聚类中心点数或者说码本大小就是<code>k=(k*)m</code>。</p>
<p>示例参考<a href="http://www.fabwrite.com/productquantization">实例理解product quantization算法</a>。</p>
<ul>
<li><strong>检索和距离的关系—ADC</strong></li>
</ul>
<p>假如做法是以图搜图,那么输入图像为<span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span>,要从数据库中找出与<span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span>最匹配的图像集<span><span class="MathJax_Preview">\{y\}</span><script type="math/tex">\{y\}</script></span>,首先提取特征,特征向量就代表图像,如果特征向量之间的距离越小,图像之间相似度越大,检索就是要找出<span><span class="MathJax_Preview">NN(x)=arg\ min_{y\in \mathcal{Y} d(x,y)}</span><script type="math/tex">NN(x)=arg\ min_{y\in \mathcal{Y} d(x,y)}</script></span>,公式中d的选取可以是欧式距离。PQ(乘积量化)中ADC的做法并不是求各个分量差的平方和,而是求x与y量化后的向量之间各个分量差的平方和。用公式表示如下：</p>
<div>
<div class="MathJax_Preview">
\tilde{d}(x,y)=d(x,q(y)) = \sqrt{\sum_jd(u_j(x),q_j(u_j(y)))^2}
</div>
<script type="math/tex; mode=display">
\tilde{d}(x,y)=d(x,q(y)) = \sqrt{\sum_jd(u_j(x),q_j(u_j(y)))^2}
</script>
</div>
<p>示意图如下:</p>
<p><img src="http://img-blog.csdn.net/20151218095829175" style="width:30%" /></p>
<p>把求x与y的距离用x与q(y)的距离代替,q(y)是y量化后的结果。这样做之所以可行,论文中有详细推到,主要是两个原因:1）MSE越小,说明量化器的精度越高;2）三角形两边之和大于第三边,两边只差小于第三边。由于只是对y做量化,对x未量化,这是不对称的,这就是ADC(Asymmetric distance computation)中Asymmetric的含义,如果对y也量化,对x也量化,就是对称的。</p>
<ul>
<li><strong>索引结构</strong></li>
</ul>
<p>索引的建立过程如下:</p>
<p><img alt="" src="http://img-blog.csdn.net/20151218100903780" /></p>
<p>上图中主要涉及三个过程,coarse quantizer,product quantizer和append to inverted list。</p>
<blockquote>
<ul>
<li>coarse quantizer</li>
</ul>
</blockquote>
<p>对数据库中的所有特征采用K-means聚类,得到粗糙量化的类中心,比如聚类成1024类,并记录每个类的样本数和各个样本所属的类别,这个类中心的个数就是inverted list的个数,把所有类中心保存到一张表中,叫coarse_cluster表,表中每项是d维。</p>
<blockquote>
<ul>
<li>product quantizer</li>
</ul>
</blockquote>
<p>计算y的余量<span><span class="MathJax_Preview">r(y)=y-q_c(y)</span><script type="math/tex">r(y)=y-q_c(y)</script></span>,用y减去y的粗糙量化的结果得到<span><span class="MathJax_Preview">r(y)</span><script type="math/tex">r(y)</script></span>。r(y)维数与y一样,然后对所有r(y)的特征分成m组,采用乘积量化,每组内仍然使用k-means聚类,这时结果是一个m维数的向量,这就是上篇文章中提到的内容。把所有的乘积量化结果保存到一个表中,叫pq_centroids表,表中每项是m维</p>
<blockquote>
<ul>
<li><strong>append to inverted list</strong></li>
</ul>
</blockquote>
<p>前面的操作中记录下y在coarse_cluster表的索引i,在pq_centroids表中的索引j,那么插入inverted list时,把(id,j)插入到第i个倒排索引中,id是y的标识符,比如文件名。list的长度就是属于第i类的样本y的数目,处理不等长list有些技巧。</p>
<ul>
<li><strong>基于IVFADC的搜索</strong></li>
</ul>
<p>检索过程如下:</p>
<p><img alt="" src="http://img-blog.csdn.net/20151218103655086" /></p>
<p>主要包括四个操作:</p>
<blockquote>
<ul>
<li>粗糙量化</li>
</ul>
</blockquote>
<p>对查询图像x的特征进行粗糙量化,即采用KNN方法将x分到某个类或某几个类,分到几个类的话叫做multiple assignment,过程同对数据集中的y分类差不多。</p>
<blockquote>
<ul>
<li>计算余量</li>
</ul>
</blockquote>
<p>计算x的余量r(x)。</p>
<blockquote>
<ul>
<li>计算d(x,y)</li>
</ul>
</blockquote>
<p>对r(x)分组,计算每组中r(x)的特征子集到pq_centroids的距离。根据ADC的技巧,计算x与y的距离可以用计算x与q(y)的距离,而q(y)就是pq_centroids表中的某项,因此已经得到了x到y的近似距离。</p>
<blockquote>
<ul>
<li>最大堆排序</li>
</ul>
</blockquote>
<p>堆中每个元素代表数据库中y与x的距离,堆顶元素的距离最大,只要是比堆顶元素小的元素,代替堆顶元素,调整堆,直到判断完所有的y。</p>
<p>数学语言:</p>
<div>
<div class="MathJax_Preview">
\begin{aligned}
&amp; r(y)=y-q_c(y) \\
&amp; y\approx q_c(y) + q_p(r(y)) \\
&amp; x=q_c(x) + r(x) \\
&amp; \|x-y\|=\|q_c(x) + r(x) -q_c(y) -q_p(r(y))\| = \|r(x)-q_p(r(y))\|  \\
&amp; answer = \min_{\{y|q_c(y)=q_c(x)\}} \|x-y\|
\end{aligned}
</div>
<script type="math/tex; mode=display">
\begin{aligned}
& r(y)=y-q_c(y) \\
& y\approx q_c(y) + q_p(r(y)) \\
& x=q_c(x) + r(x) \\
& \|x-y\|=\|q_c(x) + r(x) -q_c(y) -q_p(r(y))\| = \|r(x)-q_p(r(y))\|  \\
& answer = \min_{\{y|q_c(y)=q_c(x)\}} \|x-y\|
\end{aligned}
</script>
</div>
<p><img alt="" src="http://img-blog.csdn.net/20151218105910378" /></p>
<ul>
<li><strong>PQ算法实例</strong></li>
</ul>
<p>假设有50,000张图片组成的图片集，使用 CNN 提取特征后，每张图片可以由1024维的特征表示。那么整个图片集由50000*1024的向量来表示。如下图。</p>
<p><img alt="" src="https://i.typcdn.com/fabwrite/0u/FGZaUH_FpRdhEIdKVmqA.png" /></p>
<p>然后我们把1024维的向量平均分成m=8个子向量，每组子向量128维。如下图。</p>
<p><img alt="" src="https://i.typcdn.com/fabwrite/5G/GGjYfyGzybfnchgieepw.png" /></p>
<p>对于这8组子向量的每组子向量，使用 kmeans 方法聚成k=256类。也就是说，每个子向量有256个中心点(centroids)。如下图。</p>
<p><img alt="" src="https://i.typcdn.com/fabwrite/NM/ZL0fPpntjxi3pzrQirdw.png" /></p>
<p>在product quantization方法中，这256个中心点构成一个码本。这些码本的笛卡尔积就是原始D维向量对应的码本。用<span><span class="MathJax_Preview">q_j</span><script type="math/tex">q_j</script></span>表示第<span><span class="MathJax_Preview">j</span><script type="math/tex">j</script></span>组子向量，用<span><span class="MathJax_Preview">C_j</span><script type="math/tex">C_j</script></span>表示其对应学习到的码本，那么原始D维向量对应的码本就是
<span><span class="MathJax_Preview">C=C_1×C_2×\dots ×C_m</span><script type="math/tex">C=C_1×C_2×\dots ×C_m</script></span>,码本大小为<span><span class="MathJax_Preview">k^m</span><script type="math/tex">k^m</script></span>。</p>
<p>注意到每组子向量有其256个中心点，我们可以中心点的 ID 来表示每组子向量中的每个向量。中心点的ID只需要8位(=<span><span class="MathJax_Preview">log_2 256</span><script type="math/tex">log_2 256</script></span>)来保存即可。这样，初始一个由32位浮点数组成的1,024维向量，可以转化为8个8位整数组成。如下图。</p>
<p><img alt="" src="https://i.typcdn.com/fabwrite/c5/L56k1gZ7ZumryJrAfzzw.png" /></p>
<p>对向量压缩后，有2种方法作相似搜索。一种是SDC(symmetric distance computation)，另一种是ADC(asymmetric distance computation)。SDC算法和ADC算法的区别在于是否要对查询向量x做量化，参见公式1和公式2。如下图所示，x是查询向量(query vector)，y是数据集中的某个向量，目标是要在数据集中找到x的相似向量。</p>
<p><img alt="" src="https://i.typcdn.com/fabwrite/9v/LJlnKOiKCtDH1DN90YKQ.png" /></p>
<blockquote>
<ul>
<li>SDC算法：先用PQ量化器对x和y表示为对应的中心点q(x)和q(y)，然后用公式1来近似d(x,y)。这里 q 表示 PQ量化过程。</li>
</ul>
</blockquote>
<div>
<div class="MathJax_Preview">
\hat{d}(x,y)=d(q(x),q(y))=\sqrt{\sum_jd(q_j(x),q_j(y))^2} 
</div>
<script type="math/tex; mode=display">
\hat{d}(x,y)=d(q(x),q(y))=\sqrt{\sum_jd(q_j(x),q_j(y))^2} 
</script>
</div>
<blockquote>
<ul>
<li>ADC算法：只对y表示为对应的中心点q(y)，然后用下述公式来近似d(x,y)。</li>
</ul>
</blockquote>
<div>
<div class="MathJax_Preview">
\tilde{d}(x,y)=d(x,q(y))=\sqrt{\sum_jd(u_j(x),q_j(u_j(y)))^2}
</div>
<script type="math/tex; mode=display">
\tilde{d}(x,y)=d(x,q(y))=\sqrt{\sum_jd(u_j(x),q_j(u_j(y)))^2}
</script>
</div>
<p>Python代码:</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.cluster.vq</span> <span class="kn">import</span> <span class="n">vq</span><span class="p">,</span> <span class="n">kmeans2</span>


<span class="k">class</span> <span class="nc">PQ</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Pure python implementation of Product Quantization (PQ) [Jegou11]_.</span>
<span class="sd">    For the indexing phase of database vectors,</span>
<span class="sd">    a `D`-dim input vector is divided into `M` `D`/`M`-dim sub-vectors.</span>
<span class="sd">    Each sub-vector is quantized into a small integer via `Ks` codewords.</span>
<span class="sd">    For the querying phase, given a new `D`-dim query vector, the distance beween the query</span>
<span class="sd">    and the database PQ-codes are efficiently approximated via Asymmetric Distance.</span>
<span class="sd">    All vectors must be np.ndarray with np.float32</span>
<span class="sd">    .. [Jegou11] H. Jegou et al., &quot;Product Quantization for Nearest Neighbor Search&quot;, IEEE TPAMI 2011</span>
<span class="sd">    Args:</span>
<span class="sd">        M (int): The number of sub-space</span>
<span class="sd">        Ks (int): The number of codewords for each subspace</span>
<span class="sd">            (typically 256, so that each sub-vector is quantized</span>
<span class="sd">            into 256 bits = 1 byte = uint8)</span>
<span class="sd">        verbose (bool): Verbose flag</span>
<span class="sd">    Attributes:</span>
<span class="sd">        M (int): The number of sub-space</span>
<span class="sd">        Ks (int): The number of codewords for each subspace</span>
<span class="sd">        verbose (bool): Verbose flag</span>
<span class="sd">        code_dtype (object): dtype of PQ-code. Either np.uint{8, 16, 32}</span>
<span class="sd">        codewords (np.ndarray): shape=(M, Ks, Ds) with dtype=np.float32.</span>
<span class="sd">            codewords[m][ks] means ks-th codeword (Ds-dim) for m-th subspace</span>
<span class="sd">        Ds (int): The dim of each sub-vector, i.e., Ds=D/M</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">Ks</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">Ks</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">32</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ks</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">M</span><span class="p">,</span> <span class="n">Ks</span><span class="p">,</span> <span class="n">verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">code_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span> <span class="k">if</span> <span class="n">Ks</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">8</span> <span class="k">else</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span> <span class="k">if</span> <span class="n">Ks</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">16</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">codewords</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Ds</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s2">&quot;M: {}, Ks: {}, code_dtype: {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">Ks</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">code_dtype</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">PQ</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ks</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">code_dtype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ds</span><span class="p">)</span> <span class="o">==</span> \
                   <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">M</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">Ks</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">verbose</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">code_dtype</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">Ds</span><span class="p">)</span> <span class="ow">and</span> \
                   <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">codewords</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">codewords</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vecs</span><span class="p">,</span> <span class="nb">iter</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">123</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Given training vectors, run k-means for each sub-space and create</span>
<span class="sd">        codewords for each sub-space.</span>
<span class="sd">        This function should be run once first of all.</span>
<span class="sd">        Args:</span>
<span class="sd">            vecs (np.ndarray): Training vectors with shape=(N, D) and dtype=np.float32.</span>
<span class="sd">            iter (int): The number of iteration for k-means</span>
<span class="sd">            seed (int): The seed for random process</span>
<span class="sd">        Returns:</span>
<span class="sd">            object: self</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">vecs</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span>
        <span class="k">assert</span> <span class="n">vecs</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="n">N</span><span class="p">,</span> <span class="n">D</span> <span class="o">=</span> <span class="n">vecs</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ks</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">,</span> <span class="s2">&quot;the number of training vector should be more than Ks&quot;</span>
        <span class="k">assert</span> <span class="n">D</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;input dimension must be dividable by M&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Ds</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">D</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">)</span>

        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s2">&quot;iter: {}, seed: {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">iter</span><span class="p">,</span> <span class="n">seed</span><span class="p">))</span>

        <span class="c1"># [m][ks][ds]: m-th subspace, ks-the codeword, ds-th dim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">codewords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ks</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ds</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Training the subspace: {} / {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">))</span>
            <span class="n">vecs_sub</span> <span class="o">=</span> <span class="n">vecs</span><span class="p">[:,</span> <span class="n">m</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ds</span> <span class="p">:</span> <span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ds</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">codewords</span><span class="p">[</span><span class="n">m</span><span class="p">],</span> <span class="n">_</span> <span class="o">=</span> <span class="n">kmeans2</span><span class="p">(</span><span class="n">vecs_sub</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ks</span><span class="p">,</span> <span class="nb">iter</span><span class="o">=</span><span class="nb">iter</span><span class="p">,</span> <span class="n">minit</span><span class="o">=</span><span class="s1">&#39;points&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">encode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vecs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Encode input vectors into PQ-codes.</span>
<span class="sd">        Args:</span>
<span class="sd">            vecs (np.ndarray): Input vectors with shape=(N, D) and dtype=np.float32.</span>
<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: PQ codes with shape=(N, M) and dtype=self.code_dtype</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">vecs</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span>
        <span class="k">assert</span> <span class="n">vecs</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="n">N</span><span class="p">,</span> <span class="n">D</span> <span class="o">=</span> <span class="n">vecs</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">assert</span> <span class="n">D</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ds</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">,</span> <span class="s2">&quot;input dimension must be Ds * M&quot;</span>

        <span class="c1"># codes[n][m] : code of n-th vec, m-th subspace</span>
        <span class="n">codes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">code_dtype</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s2">&quot;Encoding the subspace: {} / {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">))</span>
            <span class="n">vecs_sub</span> <span class="o">=</span> <span class="n">vecs</span><span class="p">[:,</span> <span class="n">m</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ds</span> <span class="p">:</span> <span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ds</span><span class="p">]</span>
            <span class="n">codes</span><span class="p">[:,</span> <span class="n">m</span><span class="p">],</span> <span class="n">_</span> <span class="o">=</span> <span class="n">vq</span><span class="p">(</span><span class="n">vecs_sub</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">codewords</span><span class="p">[</span><span class="n">m</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">codes</span>

    <span class="k">def</span> <span class="nf">decode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">codes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Given PQ-codes, reconstruct original D-dimensional vectors</span>
<span class="sd">        approximately by fetching the codewords.</span>
<span class="sd">        Args:</span>
<span class="sd">            codes (np.ndarray): PQ-cdoes with shape=(N, M) and dtype=self.code_dtype.</span>
<span class="sd">                Each row is a PQ-code</span>
<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: Reconstructed vectors with shape=(N, D) and dtype=np.float32</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">codes</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="n">N</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="n">codes</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">assert</span> <span class="n">M</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span>
        <span class="k">assert</span> <span class="n">codes</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">code_dtype</span>

        <span class="n">vecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ds</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">):</span>
            <span class="n">vecs</span><span class="p">[:,</span> <span class="n">m</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ds</span> <span class="p">:</span> <span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ds</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">codewords</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">codes</span><span class="p">[:,</span> <span class="n">m</span><span class="p">],</span> <span class="p">:]</span>

        <span class="k">return</span> <span class="n">vecs</span>

    <span class="k">def</span> <span class="nf">dtable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute a distance table for a query vector.</span>
<span class="sd">        The distances are computed by comparing each sub-vector of the query</span>
<span class="sd">        to the codewords for each sub-subspace.</span>
<span class="sd">        `dtable[m][ks]` contains the squared Euclidean distance between</span>
<span class="sd">        the `m`-th sub-vector of the query and the `ks`-th codeword</span>
<span class="sd">        for the `m`-th sub-space (`self.codewords[m][ks]`).</span>
<span class="sd">        Args:</span>
<span class="sd">            query (np.ndarray): Input vector with shape=(D, ) and dtype=np.float32</span>
<span class="sd">        Returns:</span>
<span class="sd">            nanopq.DistanceTable:</span>
<span class="sd">                Distance table. which contains</span>
<span class="sd">                dtable with shape=(M, Ks) and dtype=np.float32</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">query</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span>
        <span class="k">assert</span> <span class="n">query</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;input must be a single vector&quot;</span>
        <span class="n">D</span><span class="p">,</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">assert</span> <span class="n">D</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ds</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">,</span> <span class="s2">&quot;input dimension must be Ds * M&quot;</span>

        <span class="c1"># dtable[m] : distance between m-th subvec and m-th codewords (m-th subspace)</span>
        <span class="c1"># dtable[m][ks] : distance between m-th subvec and ks-th codeword of m-th codewords</span>
        <span class="n">dtable</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ks</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">):</span>
            <span class="n">query_sub</span> <span class="o">=</span> <span class="n">query</span><span class="p">[</span><span class="n">m</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ds</span> <span class="p">:</span> <span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ds</span><span class="p">]</span>
            <span class="n">dtable</span><span class="p">[</span><span class="n">m</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">codewords</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">-</span> <span class="n">query_sub</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>

        <span class="k">return</span> <span class="n">DistanceTable</span><span class="p">(</span><span class="n">dtable</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">DistanceTable</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Distance table from query to codeworkds.</span>
<span class="sd">    Given a query vector, a PQ/OPQ instance compute this DistanceTable class</span>
<span class="sd">    using :func:`PQ.dtable` or :func:`OPQ.dtable`.</span>
<span class="sd">    The Asymmetric Distance from query to each database codes can be computed</span>
<span class="sd">    by :func:`DistanceTable.adist`.</span>
<span class="sd">    Args:</span>
<span class="sd">        dtable (np.ndarray): Distance table with shape=(M, Ks) and dtype=np.float32</span>
<span class="sd">            computed by :func:`PQ.dtable` or :func:`OPQ.dtable`</span>
<span class="sd">    Attributes:</span>
<span class="sd">        dtable (np.ndarray): Distance table with shape=(M, Ks) and dtype=np.float32.</span>
<span class="sd">            Note that dtable[m][ks] contains the squared Euclidean distance between</span>
<span class="sd">            (1) m-th sub-vector of query and (2) ks-th codeword for m-th subspace.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtable</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">dtable</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="k">assert</span> <span class="n">dtable</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtable</span> <span class="o">=</span> <span class="n">dtable</span>

    <span class="k">def</span> <span class="nf">adist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">codes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Given PQ-codes, compute Asymmetric Distances between the query (self.dtable)</span>
<span class="sd">        and the PQ-codes.</span>
<span class="sd">        Args:</span>
<span class="sd">            codes (np.ndarray): PQ codes with shape=(N, M) and</span>
<span class="sd">                dtype=pq.code_dtype where pq is a pq instance that creates the codes</span>
<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: Asymmetric Distances with shape=(N, ) and dtype=np.float32</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="n">codes</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="n">N</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="n">codes</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">assert</span> <span class="n">M</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtable</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Fetch distance values using codes. The following codes are</span>
        <span class="n">dists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtable</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">),</span> <span class="n">codes</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># The above line is equivalent to the followings:</span>
        <span class="c1"># dists = np.zeros((N, )).astype(np.float32)</span>
        <span class="c1"># for n in range(N):</span>
        <span class="c1">#     for m in range(M):</span>
        <span class="c1">#         dists[n] += self.dtable[m][codes[n][m]]</span>

        <span class="k">return</span> <span class="n">dists</span>
</pre></div>

<h4 id="234">2.3.4 距离指标<a class="headerlink" href="#234" title="Permanent link">&para;</a></h4>
<h4 id="235-knn">2.3.5 <code>KNN</code>算法<a class="headerlink" href="#235-knn" title="Permanent link">&para;</a></h4>
<h2 id="_1">三、源码介绍<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h2>
<h3 id="41">4.1 基础工具<a class="headerlink" href="#41" title="Permanent link">&para;</a></h3>
<h4 id="411-randomhrandomcpp">4.1.1 <code>random.h</code>和<code>random.cpp</code>文件<a class="headerlink" href="#411-randomhrandomcpp" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><span class="cm">/* Random generators. Implemented here for speed and to make sequences reproducible. */</span>

<span class="cp">#pragma once</span>

<span class="cp">#include</span> <span class="cpf">&lt;random&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">faiss</span> <span class="p">{</span>

    <span class="cm">/**************************************************</span>
<span class="cm">    * Random data generation functions</span>
<span class="cm">    **************************************************/</span>

    <span class="c1">/// random generator that can be used in multithreaded contexts</span>
    <span class="k">struct</span> <span class="n">RandomGenerator</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">mt19937</span> <span class="n">mt</span><span class="p">;</span>

        <span class="c1">/// random positive integer</span>
        <span class="kt">int</span> <span class="nf">rand_int</span> <span class="p">(){</span> <span class="k">return</span> <span class="n">mt</span><span class="p">()</span> <span class="o">&amp;</span> <span class="mh">0x7fffffff</span><span class="p">;</span> <span class="p">};</span>

        <span class="c1">/// random int64_t</span>
        <span class="kt">int64_t</span> <span class="nf">rand_int64</span> <span class="p">(){</span> <span class="k">return</span> <span class="kt">int64_t</span><span class="p">(</span><span class="n">rand_int</span><span class="p">())</span> <span class="o">|</span> <span class="kt">int64_t</span><span class="p">(</span><span class="n">rand_int</span><span class="p">())</span> <span class="o">&lt;&lt;</span> <span class="mi">31</span><span class="p">;</span> <span class="p">};</span>

        <span class="c1">/// generate random integer between 0 and max-1</span>
        <span class="kt">int</span> <span class="nf">rand_int</span> <span class="p">(</span><span class="kt">int</span> <span class="n">max</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">mt</span><span class="p">()</span> <span class="o">%</span> <span class="n">max</span><span class="p">;</span> <span class="p">};</span>

        <span class="c1">/// between 0 and 1</span>
        <span class="kt">float</span> <span class="nf">rand_float</span> <span class="p">(){</span> <span class="k">return</span> <span class="n">mt</span><span class="p">()</span> <span class="o">/</span> <span class="kt">float</span><span class="p">(</span><span class="n">mt</span><span class="p">.</span><span class="n">max</span><span class="p">());};</span>

        <span class="kt">double</span> <span class="nf">rand_double</span> <span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">mt</span><span class="p">()</span> <span class="o">/</span> <span class="kt">double</span><span class="p">(</span><span class="n">mt</span><span class="p">.</span><span class="n">max</span><span class="p">());</span> <span class="p">};</span>

        <span class="k">explicit</span> <span class="nf">RandomGenerator</span> <span class="p">(</span><span class="kt">int64_t</span> <span class="n">seed</span> <span class="o">=</span> <span class="mi">1234</span><span class="p">)</span><span class="o">:</span> <span class="n">mt</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">seed</span><span class="p">)</span> <span class="p">{};</span>
    <span class="p">};</span>

    <span class="cm">/* Generate an array of uniform random floats / multi-threaded implementation */</span>
    <span class="kt">void</span> <span class="nf">float_rand</span> <span class="p">(</span><span class="kt">float</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">seed</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// only try to parallelize on large enough arrays</span>
        <span class="k">const</span> <span class="kt">size_t</span> <span class="n">nblock</span> <span class="o">=</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1024</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">1024</span><span class="p">;</span>

        <span class="n">RandomGenerator</span> <span class="n">rng0</span> <span class="p">(</span><span class="n">seed</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">a0</span> <span class="o">=</span> <span class="n">rng0</span><span class="p">.</span><span class="n">rand_int</span> <span class="p">(),</span> <span class="n">b0</span> <span class="o">=</span> <span class="n">rng0</span><span class="p">.</span><span class="n">rand_int</span> <span class="p">();</span>

        <span class="cp">#pragma omp parallel for</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nblock</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">RandomGenerator</span> <span class="n">rng</span> <span class="p">(</span><span class="n">a0</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="n">b0</span><span class="p">);</span>

            <span class="k">const</span> <span class="kt">size_t</span> <span class="n">istart</span> <span class="o">=</span> <span class="n">j</span> <span class="o">*</span> <span class="n">n</span> <span class="o">/</span> <span class="n">nblock</span><span class="p">;</span>
            <span class="k">const</span> <span class="kt">size_t</span> <span class="n">iend</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">n</span> <span class="o">/</span> <span class="n">nblock</span><span class="p">;</span>

            <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">istart</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">iend</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
                <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rng</span><span class="p">.</span><span class="n">rand_float</span> <span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>


    <span class="kt">void</span> <span class="nf">float_randn</span> <span class="p">(</span><span class="kt">float</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">seed</span><span class="p">);{</span>
        <span class="c1">// only try to parallelize on large enough arrays</span>
        <span class="k">const</span> <span class="kt">size_t</span> <span class="n">nblock</span> <span class="o">=</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1024</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">1024</span><span class="p">;</span>

        <span class="n">RandomGenerator</span> <span class="nf">rng0</span> <span class="p">(</span><span class="n">seed</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">a0</span> <span class="o">=</span> <span class="n">rng0</span><span class="p">.</span><span class="n">rand_int</span> <span class="p">(),</span> <span class="n">b0</span> <span class="o">=</span> <span class="n">rng0</span><span class="p">.</span><span class="n">rand_int</span> <span class="p">();</span>

        <span class="cp">#pragma omp parallel for</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nblock</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">RandomGenerator</span> <span class="n">rng</span> <span class="p">(</span><span class="n">a0</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="n">b0</span><span class="p">);</span>

                <span class="kt">double</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="kt">int</span> <span class="n">state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="cm">/* generate two number per &quot;do-while&quot; loop */</span>

                <span class="k">const</span> <span class="kt">size_t</span> <span class="n">istart</span> <span class="o">=</span> <span class="n">j</span> <span class="o">*</span> <span class="n">n</span> <span class="o">/</span> <span class="n">nblock</span><span class="p">;</span>
                <span class="k">const</span> <span class="kt">size_t</span> <span class="n">iend</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">n</span> <span class="o">/</span> <span class="n">nblock</span><span class="p">;</span>

                <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">istart</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">iend</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                    <span class="cm">/* Marsaglia&#39;s method (see Knuth) */</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                        <span class="k">do</span> <span class="p">{</span>
                            <span class="n">a</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">rng</span><span class="p">.</span><span class="n">rand_double</span> <span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
                            <span class="n">b</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">rng</span><span class="p">.</span><span class="n">rand_double</span> <span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
                            <span class="n">s</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">b</span><span class="p">;</span>
                        <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">s</span> <span class="o">&gt;=</span> <span class="mf">1.0</span><span class="p">);</span>
                        <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">log</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">/</span> <span class="n">s</span><span class="p">);</span>
                    <span class="p">}</span>
                    <span class="k">else</span>
                        <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span> <span class="o">*</span> <span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">log</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">/</span> <span class="n">s</span><span class="p">);</span>
                    <span class="n">state</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">state</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">int64_rand</span> <span class="p">(</span><span class="kt">int64_t</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">seed</span><span class="p">){</span>
        <span class="c1">// only try to parallelize on large enough arrays</span>
        <span class="k">const</span> <span class="kt">size_t</span> <span class="n">nblock</span> <span class="o">=</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1024</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">1024</span><span class="p">;</span>

        <span class="n">RandomGenerator</span> <span class="nf">rng0</span> <span class="p">(</span><span class="n">seed</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">a0</span> <span class="o">=</span> <span class="n">rng0</span><span class="p">.</span><span class="n">rand_int</span> <span class="p">(),</span> <span class="n">b0</span> <span class="o">=</span> <span class="n">rng0</span><span class="p">.</span><span class="n">rand_int</span> <span class="p">();</span>

        <span class="cp">#pragma omp parallel for</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nblock</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">RandomGenerator</span> <span class="n">rng</span> <span class="p">(</span><span class="n">a0</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="n">b0</span><span class="p">);</span>
                <span class="k">const</span> <span class="kt">size_t</span> <span class="n">istart</span> <span class="o">=</span> <span class="n">j</span> <span class="o">*</span> <span class="n">n</span> <span class="o">/</span> <span class="n">nblock</span><span class="p">;</span>
                <span class="k">const</span> <span class="kt">size_t</span> <span class="n">iend</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">n</span> <span class="o">/</span> <span class="n">nblock</span><span class="p">;</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">istart</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">iend</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
                    <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rng</span><span class="p">.</span><span class="n">rand_int64</span> <span class="p">();</span>
            <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">byte_rand</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">seed</span><span class="p">);</span> <span class="p">{</span>
        <span class="c1">// only try to parallelize on large enough arrays</span>
        <span class="k">const</span> <span class="kt">size_t</span> <span class="n">nblock</span> <span class="o">=</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1024</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">1024</span><span class="p">;</span>

        <span class="n">RandomGenerator</span> <span class="nf">rng0</span> <span class="p">(</span><span class="n">seed</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">a0</span> <span class="o">=</span> <span class="n">rng0</span><span class="p">.</span><span class="n">rand_int</span> <span class="p">(),</span> <span class="n">b0</span> <span class="o">=</span> <span class="n">rng0</span><span class="p">.</span><span class="n">rand_int</span> <span class="p">();</span>

        <span class="cp">#pragma omp parallel for</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nblock</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">RandomGenerator</span> <span class="n">rng</span> <span class="p">(</span><span class="n">a0</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="n">b0</span><span class="p">);</span>
                <span class="k">const</span> <span class="kt">size_t</span> <span class="n">istart</span> <span class="o">=</span> <span class="n">j</span> <span class="o">*</span> <span class="n">n</span> <span class="o">/</span> <span class="n">nblock</span><span class="p">;</span>
                <span class="k">const</span> <span class="kt">size_t</span> <span class="n">iend</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">n</span> <span class="o">/</span> <span class="n">nblock</span><span class="p">;</span>
                <span class="kt">size_t</span> <span class="n">i</span><span class="p">;</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">istart</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">iend</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
                    <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rng</span><span class="p">.</span><span class="n">rand_int64</span> <span class="p">();</span>
            <span class="p">}</span>
    <span class="p">}</span>


    <span class="c1">// max is actually the maximum value + 1</span>
    <span class="kt">void</span> <span class="n">int64_rand_max</span> <span class="p">(</span><span class="kt">int64_t</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">max</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">seed</span><span class="p">){</span>
        <span class="c1">// only try to parallelize on large enough arrays</span>
        <span class="k">const</span> <span class="kt">size_t</span> <span class="n">nblock</span> <span class="o">=</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1024</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">1024</span><span class="p">;</span>

        <span class="n">RandomGenerator</span> <span class="nf">rng0</span> <span class="p">(</span><span class="n">seed</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">a0</span> <span class="o">=</span> <span class="n">rng0</span><span class="p">.</span><span class="n">rand_int</span> <span class="p">(),</span> <span class="n">b0</span> <span class="o">=</span> <span class="n">rng0</span><span class="p">.</span><span class="n">rand_int</span> <span class="p">();</span>

        <span class="cp">#pragma omp parallel for</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nblock</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

                <span class="n">RandomGenerator</span> <span class="n">rng</span> <span class="p">(</span><span class="n">a0</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="n">b0</span><span class="p">);</span>
                <span class="k">const</span> <span class="kt">size_t</span> <span class="n">istart</span> <span class="o">=</span> <span class="n">j</span> <span class="o">*</span> <span class="n">n</span> <span class="o">/</span> <span class="n">nblock</span><span class="p">;</span>
                <span class="k">const</span> <span class="kt">size_t</span> <span class="n">iend</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">n</span> <span class="o">/</span> <span class="n">nblock</span><span class="p">;</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">istart</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">iend</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
                    <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rng</span><span class="p">.</span><span class="n">rand_int64</span> <span class="p">()</span> <span class="o">%</span> <span class="n">max</span><span class="p">;</span>
            <span class="p">}</span>
    <span class="p">}</span>


    <span class="cm">/* random permutation */</span>
    <span class="kt">void</span> <span class="n">rand_perm</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span> <span class="n">perm</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">seed</span><span class="p">){</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

        <span class="n">RandomGenerator</span> <span class="nf">rng</span> <span class="p">(</span><span class="n">seed</span><span class="p">);</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">i2</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">rng</span><span class="p">.</span><span class="n">rand_int</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">i</span><span class="p">);</span>
            <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">perm</span><span class="p">[</span><span class="n">i2</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>

<span class="p">}</span> <span class="c1">// namespace faiss</span>
</pre></div>

<h4 id="412-heaphheapcpp">4.1.2 <code>Heap.h</code>和<code>Heap.cpp</code>文件<a class="headerlink" href="#412-heaphheapcpp" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm"> * C++ support for heaps. The set of functions is tailored for efficient similarity search.</span>
<span class="cm"> *</span>
<span class="cm"> * There is no specific object for a heap, and the functions that operate on a signle heap are </span>
<span class="cm"> * inlined, because heaps are often small. More complex functions are implemented in Heaps.cpp</span>
<span class="cm"> */</span>


<span class="cp">#ifndef FAISS_Heap_h</span>
<span class="cp">#define FAISS_Heap_h</span>

<span class="cp">#include</span> <span class="cpf">&lt;climits&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cstring&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cmath&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&lt;cassert&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&lt;limits&gt;</span><span class="cp"></span>


<span class="k">namespace</span> <span class="n">faiss</span> <span class="p">{</span>

    <span class="cm">/*******************************************************************</span>
<span class="cm">    * C object: uniform handling of min and max heap</span>
<span class="cm">    *******************************************************************/</span>

    <span class="cm">/** The C object gives the type T of the values in the heap, the type</span>
<span class="cm">    *  of the keys, TI and the comparison that is done: &gt; for the minheap</span>
<span class="cm">    *  and &lt; for the maxheap. The neutral value will always be dropped in</span>
<span class="cm">    *  favor of any other value in the heap.</span>
<span class="cm">    */</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T_</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TI_</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="n">CMax</span><span class="p">;</span>

    <span class="c1">// traits of minheaps = heaps where the minimum value is stored on top</span>
    <span class="c1">// useful to find the *max* values of an array</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T_</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TI_</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="n">CMin</span> <span class="p">{</span> 
        <span class="k">typedef</span> <span class="n">T_</span> <span class="n">T</span><span class="p">;</span> 
        <span class="k">typedef</span> <span class="n">TI_</span> <span class="n">TI</span><span class="p">;</span> 
        <span class="k">typedef</span> <span class="n">CMax</span><span class="o">&lt;</span><span class="n">T_</span><span class="p">,</span> <span class="n">TI_</span><span class="o">&gt;</span> <span class="n">Crev</span><span class="p">;</span>
        <span class="kr">inline</span> <span class="k">static</span> <span class="kt">bool</span> <span class="nf">cmp</span> <span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// value that will be popped first -&gt; must be smaller than all others</span>
        <span class="c1">// for int types this is not strictly the smallest val (-max - 1)</span>
        <span class="kr">inline</span> <span class="k">static</span> <span class="n">T</span> <span class="nf">neutral</span> <span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">};</span>


    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T_</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TI_</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="n">CMax</span> <span class="p">{</span>
        <span class="k">typedef</span> <span class="n">T_</span> <span class="n">T</span><span class="p">;</span>
        <span class="k">typedef</span> <span class="n">TI_</span> <span class="n">TI</span><span class="p">;</span>
        <span class="k">typedef</span> <span class="n">CMin</span><span class="o">&lt;</span><span class="n">T_</span><span class="p">,</span> <span class="n">TI_</span><span class="o">&gt;</span> <span class="n">Crev</span><span class="p">;</span>
        <span class="kr">inline</span> <span class="k">static</span> <span class="kt">bool</span> <span class="nf">cmp</span> <span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="kr">inline</span> <span class="k">static</span> <span class="n">T</span> <span class="nf">neutral</span> <span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">};</span>


    <span class="cm">/*******************************************************************</span>
<span class="cm">     * Basic heap ops: push and pop</span>
<span class="cm">     *******************************************************************/</span>

    <span class="cm">/** Pops the top element from the heap defined by bh_val[0..k-1] and</span>
<span class="cm">     * bh_ids[0..k-1].  on output the element at k-1 is undefined.</span>
<span class="cm">     */</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">C</span><span class="o">&gt;</span> 
    <span class="kr">inline</span> <span class="kt">void</span> <span class="n">heap_pop</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">k</span><span class="p">,</span> <span class="k">typename</span> <span class="n">C</span><span class="o">::</span><span class="n">T</span> <span class="o">*</span> <span class="n">bh_val</span><span class="p">,</span> <span class="k">typename</span> <span class="n">C</span><span class="o">::</span><span class="n">TI</span> <span class="o">*</span> <span class="n">bh_ids</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">bh_val</span><span class="o">--</span><span class="p">;</span> <span class="cm">/* Use 1-based indexing for easier node-&gt;child translation */</span>
        <span class="n">bh_ids</span><span class="o">--</span><span class="p">;</span>
        <span class="k">typename</span> <span class="n">C</span><span class="o">::</span><span class="n">T</span> <span class="n">val</span> <span class="o">=</span> <span class="n">bh_val</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
        <span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">i1</span> <span class="o">=</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">i2</span> <span class="o">=</span> <span class="n">i1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i1</span> <span class="o">&gt;</span> <span class="n">k</span><span class="p">)</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i2</span> <span class="o">==</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">C</span><span class="o">::</span><span class="n">cmp</span><span class="p">(</span><span class="n">bh_val</span><span class="p">[</span><span class="n">i1</span><span class="p">],</span> <span class="n">bh_val</span><span class="p">[</span><span class="n">i2</span><span class="p">]))</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">C</span><span class="o">::</span><span class="n">cmp</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">bh_val</span><span class="p">[</span><span class="n">i1</span><span class="p">]))</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="n">bh_val</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">bh_val</span><span class="p">[</span><span class="n">i1</span><span class="p">];</span>
                <span class="n">bh_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">bh_ids</span><span class="p">[</span><span class="n">i1</span><span class="p">];</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">i1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">C</span><span class="o">::</span><span class="n">cmp</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">bh_val</span><span class="p">[</span><span class="n">i2</span><span class="p">]))</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="n">bh_val</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">bh_val</span><span class="p">[</span><span class="n">i2</span><span class="p">];</span>
                <span class="n">bh_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">bh_ids</span><span class="p">[</span><span class="n">i2</span><span class="p">];</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">i2</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">bh_val</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">bh_val</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
        <span class="n">bh_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">bh_ids</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
    <span class="p">}</span>



    <span class="cm">/** Pushes the element (val, ids) into the heap bh_val[0..k-2] and</span>
<span class="cm">     * bh_ids[0..k-2].  on output the element at k-1 is defined.</span>
<span class="cm">     */</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">C</span><span class="o">&gt;</span> <span class="kr">inline</span>
    <span class="kt">void</span> <span class="n">heap_push</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">k</span><span class="p">,</span> <span class="k">typename</span> <span class="n">C</span><span class="o">::</span><span class="n">T</span> <span class="o">*</span> <span class="n">bh_val</span><span class="p">,</span> <span class="k">typename</span> <span class="n">C</span><span class="o">::</span><span class="n">TI</span> <span class="o">*</span> <span class="n">bh_ids</span><span class="p">,</span> <span class="k">typename</span> <span class="n">C</span><span class="o">::</span><span class="n">T</span> <span class="n">val</span><span class="p">,</span> <span class="k">typename</span> <span class="n">C</span><span class="o">::</span><span class="n">TI</span> <span class="n">ids</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">bh_val</span><span class="o">--</span><span class="p">;</span> <span class="cm">/* Use 1-based indexing for easier node-&gt;child translation */</span>
        <span class="n">bh_ids</span><span class="o">--</span><span class="p">;</span>
        <span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">k</span><span class="p">,</span> <span class="n">i_father</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">i_father</span> <span class="o">=</span> <span class="n">i</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">C</span><span class="o">::</span><span class="n">cmp</span> <span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">bh_val</span><span class="p">[</span><span class="n">i_father</span><span class="p">]))</span>  <span class="cm">/* the heap structure is ok */</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="n">bh_val</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">bh_val</span><span class="p">[</span><span class="n">i_father</span><span class="p">];</span>
            <span class="n">bh_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">bh_ids</span><span class="p">[</span><span class="n">i_father</span><span class="p">];</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">i_father</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">bh_val</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
        <span class="n">bh_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ids</span><span class="p">;</span>
    <span class="p">}</span>



    <span class="cm">/* Partial instanciation for heaps with TI = int64_t */</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kr">inline</span>
    <span class="kt">void</span> <span class="n">minheap_pop</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">k</span><span class="p">,</span> <span class="n">T</span> <span class="o">*</span> <span class="n">bh_val</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="o">*</span> <span class="n">bh_ids</span><span class="p">){</span>
        <span class="n">heap_pop</span><span class="o">&lt;</span><span class="n">CMin</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">int64_t</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">bh_val</span><span class="p">,</span> <span class="n">bh_ids</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kr">inline</span>
    <span class="kt">void</span> <span class="n">minheap_push</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">k</span><span class="p">,</span> <span class="n">T</span> <span class="o">*</span> <span class="n">bh_val</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="o">*</span> <span class="n">bh_ids</span><span class="p">,</span> <span class="n">T</span> <span class="n">val</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">ids</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">heap_push</span><span class="o">&lt;</span><span class="n">CMin</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">int64_t</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">bh_val</span><span class="p">,</span> <span class="n">bh_ids</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">ids</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kr">inline</span>
    <span class="kt">void</span> <span class="n">maxheap_pop</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">k</span><span class="p">,</span> <span class="n">T</span> <span class="o">*</span> <span class="n">bh_val</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="o">*</span> <span class="n">bh_ids</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">heap_pop</span><span class="o">&lt;</span><span class="n">CMax</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">int64_t</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">bh_val</span><span class="p">,</span> <span class="n">bh_ids</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kr">inline</span>
    <span class="kt">void</span> <span class="n">maxheap_push</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">k</span><span class="p">,</span> <span class="n">T</span> <span class="o">*</span> <span class="n">bh_val</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="o">*</span> <span class="n">bh_ids</span><span class="p">,</span> <span class="n">T</span> <span class="n">val</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">ids</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">heap_push</span><span class="o">&lt;</span><span class="n">CMax</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">int64_t</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">bh_val</span><span class="p">,</span> <span class="n">bh_ids</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">ids</span><span class="p">);</span>
    <span class="p">}</span>


    <span class="cm">/*******************************************************************</span>
<span class="cm">     * Heap initialization</span>
<span class="cm">     *******************************************************************/</span>
    <span class="cm">/* Initialization phase for the heap (with unconditionnal pushes).</span>
<span class="cm">     * Store k0 elements in a heap containing up to k values. Note that</span>
<span class="cm">     * (bh_val, bh_ids) can be the same as (x, ids) */</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">C</span><span class="o">&gt;</span> <span class="kr">inline</span>
    <span class="kt">void</span> <span class="n">heap_heapify</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">k</span><span class="p">,</span> <span class="k">typename</span> <span class="n">C</span><span class="o">::</span><span class="n">T</span> <span class="o">*</span>  <span class="n">bh_val</span><span class="p">,</span> <span class="k">typename</span> <span class="n">C</span><span class="o">::</span><span class="n">TI</span> <span class="o">*</span>  <span class="n">bh_ids</span><span class="p">,</span>
        <span class="k">const</span> <span class="k">typename</span> <span class="n">C</span><span class="o">::</span><span class="n">T</span> <span class="o">*</span> <span class="n">x</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">,</span><span class="k">const</span> <span class="k">typename</span> <span class="n">C</span><span class="o">::</span><span class="n">TI</span> <span class="o">*</span> <span class="n">ids</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">k0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">){</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">k0</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">assert</span> <span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ids</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k0</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
                <span class="n">heap_push</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">bh_val</span><span class="p">,</span> <span class="n">bh_ids</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ids</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k0</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
                <span class="n">heap_push</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">bh_val</span><span class="p">,</span> <span class="n">bh_ids</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">k0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">bh_val</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">C</span><span class="o">::</span><span class="n">neutral</span><span class="p">();</span>
            <span class="n">bh_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kr">inline</span>
    <span class="kt">void</span> <span class="n">minheap_heapify</span> <span class="p">(</span> <span class="kt">size_t</span> <span class="n">k</span><span class="p">,</span> <span class="n">T</span> <span class="o">*</span>  <span class="n">bh_val</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="o">*</span> <span class="n">bh_ids</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">T</span> <span class="o">*</span> <span class="n">x</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int64_t</span> <span class="o">*</span> <span class="n">ids</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">k0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">heap_heapify</span><span class="o">&lt;</span> <span class="n">CMin</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">int64_t</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">bh_val</span><span class="p">,</span> <span class="n">bh_ids</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">k0</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kr">inline</span>
    <span class="kt">void</span> <span class="n">maxheap_heapify</span> <span class="p">(</span> <span class="kt">size_t</span> <span class="n">k</span><span class="p">,</span> <span class="n">T</span> <span class="o">*</span> <span class="n">bh_val</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="o">*</span> <span class="n">bh_ids</span><span class="p">,</span>
         <span class="k">const</span> <span class="n">T</span> <span class="o">*</span> <span class="n">x</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int64_t</span> <span class="o">*</span> <span class="n">ids</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">k0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">heap_heapify</span><span class="o">&lt;</span> <span class="n">CMax</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">int64_t</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">bh_val</span><span class="p">,</span> <span class="n">bh_ids</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">k0</span><span class="p">);</span>
    <span class="p">}</span>


    <span class="cm">/*******************************************************************</span>
<span class="cm">     * Add n elements to the heap</span>
<span class="cm">     *******************************************************************/</span>

    <span class="cm">/* Add some elements to the heap  */</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">C</span><span class="o">&gt;</span> <span class="kr">inline</span>
    <span class="kt">void</span> <span class="n">heap_addn</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">k</span><span class="p">,</span> <span class="k">typename</span> <span class="n">C</span><span class="o">::</span><span class="n">T</span> <span class="o">*</span> <span class="n">bh_val</span><span class="p">,</span> <span class="k">typename</span> <span class="n">C</span><span class="o">::</span><span class="n">TI</span> <span class="o">*</span> <span class="n">bh_ids</span><span class="p">,</span>
                <span class="k">const</span> <span class="k">typename</span> <span class="n">C</span><span class="o">::</span><span class="n">T</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="k">typename</span> <span class="n">C</span><span class="o">::</span><span class="n">TI</span> <span class="o">*</span> <span class="n">ids</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">size_t</span> <span class="n">i</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ids</span><span class="p">)</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">C</span><span class="o">::</span><span class="n">cmp</span> <span class="p">(</span><span class="n">bh_val</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">{</span>
                    <span class="n">heap_pop</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">bh_val</span><span class="p">,</span> <span class="n">bh_ids</span><span class="p">);</span>
                    <span class="n">heap_push</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">bh_val</span><span class="p">,</span> <span class="n">bh_ids</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ids</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
                <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">else</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">C</span><span class="o">::</span><span class="n">cmp</span> <span class="p">(</span><span class="n">bh_val</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">{</span>
                    <span class="n">heap_pop</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">bh_val</span><span class="p">,</span> <span class="n">bh_ids</span><span class="p">);</span>
                    <span class="n">heap_push</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">bh_val</span><span class="p">,</span> <span class="n">bh_ids</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/* Partial instanciation for heaps with TI = int64_t */</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kr">inline</span>
    <span class="kt">void</span> <span class="n">minheap_addn</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">k</span><span class="p">,</span> <span class="n">T</span> <span class="o">*</span> <span class="n">bh_val</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="o">*</span> <span class="n">bh_ids</span><span class="p">,</span>
                       <span class="k">const</span> <span class="n">T</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int64_t</span> <span class="o">*</span> <span class="n">ids</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">heap_addn</span><span class="o">&lt;</span><span class="n">CMin</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">int64_t</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">bh_val</span><span class="p">,</span> <span class="n">bh_ids</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kr">inline</span>
    <span class="kt">void</span> <span class="n">maxheap_addn</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">k</span><span class="p">,</span> <span class="n">T</span> <span class="o">*</span> <span class="n">bh_val</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="o">*</span> <span class="n">bh_ids</span><span class="p">,</span>
                       <span class="k">const</span> <span class="n">T</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int64_t</span> <span class="o">*</span> <span class="n">ids</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">heap_addn</span><span class="o">&lt;</span><span class="n">CMax</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">int64_t</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">bh_val</span><span class="p">,</span> <span class="n">bh_ids</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
    <span class="p">}</span>


    <span class="cm">/*******************************************************************</span>
<span class="cm">     * Heap finalization (reorder elements)</span>
<span class="cm">     *******************************************************************/</span>

    <span class="cm">/* This function maps a binary heap into an sorted structure. It returns the number  */</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">C</span><span class="o">&gt;</span> <span class="kr">inline</span>
    <span class="kt">size_t</span> <span class="n">heap_reorder</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">k</span><span class="p">,</span> <span class="k">typename</span> <span class="n">C</span><span class="o">::</span><span class="n">T</span> <span class="o">*</span> <span class="n">bh_val</span><span class="p">,</span> <span class="k">typename</span> <span class="n">C</span><span class="o">::</span><span class="n">TI</span> <span class="o">*</span> <span class="n">bh_ids</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">size_t</span> <span class="n">i</span><span class="p">,</span> <span class="n">ii</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ii</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* top element should be put at the end of the list */</span>
            <span class="k">typename</span> <span class="n">C</span><span class="o">::</span><span class="n">T</span> <span class="n">val</span> <span class="o">=</span> <span class="n">bh_val</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
            <span class="k">typename</span> <span class="n">C</span><span class="o">::</span><span class="n">TI</span> <span class="n">id</span> <span class="o">=</span> <span class="n">bh_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

            <span class="cm">/* boundary case: we will over-ride this value if not a true element */</span>
            <span class="n">heap_pop</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="n">i</span><span class="p">,</span> <span class="n">bh_val</span><span class="p">,</span> <span class="n">bh_ids</span><span class="p">);</span>
            <span class="n">bh_val</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="n">ii</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
            <span class="n">bh_ids</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="n">ii</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="n">ii</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="cm">/* Count the number of elements which are effectively returned */</span>
        <span class="kt">size_t</span> <span class="n">nel</span> <span class="o">=</span> <span class="n">ii</span><span class="p">;</span>
        <span class="n">memmove</span> <span class="p">(</span><span class="n">bh_val</span><span class="p">,</span> <span class="n">bh_val</span><span class="o">+</span><span class="n">k</span><span class="o">-</span><span class="n">ii</span><span class="p">,</span> <span class="n">ii</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bh_val</span><span class="p">));</span>
        <span class="n">memmove</span> <span class="p">(</span><span class="n">bh_ids</span><span class="p">,</span> <span class="n">bh_ids</span><span class="o">+</span><span class="n">k</span><span class="o">-</span><span class="n">ii</span><span class="p">,</span> <span class="n">ii</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bh_ids</span><span class="p">));</span>
        <span class="k">for</span> <span class="p">(;</span> <span class="n">ii</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">;</span> <span class="n">ii</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">bh_val</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">C</span><span class="o">::</span><span class="n">neutral</span><span class="p">();</span>
            <span class="n">bh_ids</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">nel</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kr">inline</span>
    <span class="kt">size_t</span> <span class="n">minheap_reorder</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">k</span><span class="p">,</span> <span class="n">T</span> <span class="o">*</span> <span class="n">bh_val</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="o">*</span> <span class="n">bh_ids</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">heap_reorder</span><span class="o">&lt;</span> <span class="n">CMin</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">int64_t</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">bh_val</span><span class="p">,</span> <span class="n">bh_ids</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kr">inline</span>
    <span class="kt">size_t</span> <span class="n">maxheap_reorder</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">k</span><span class="p">,</span> <span class="n">T</span> <span class="o">*</span> <span class="n">bh_val</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="o">*</span> <span class="n">bh_ids</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">heap_reorder</span><span class="o">&lt;</span> <span class="n">CMax</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">int64_t</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">bh_val</span><span class="p">,</span> <span class="n">bh_ids</span><span class="p">);</span>
    <span class="p">}</span>


    <span class="cm">/*******************************************************************</span>
<span class="cm">     * Operations on heap arrays</span>
<span class="cm">     *******************************************************************/</span>

    <span class="cm">/** a template structure for a set of [min|max]-heaps it is tailored</span>
<span class="cm">     * so that the actual data of the heaps can just live in compact arrays. */</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">C</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="n">HeapArray</span> <span class="p">{</span>
        <span class="k">typedef</span> <span class="k">typename</span> <span class="n">C</span><span class="o">::</span><span class="n">TI</span> <span class="n">TI</span><span class="p">;</span>
        <span class="k">typedef</span> <span class="k">typename</span> <span class="n">C</span><span class="o">::</span><span class="n">T</span> <span class="n">T</span><span class="p">;</span>

        <span class="kt">size_t</span> <span class="n">nh</span><span class="p">;</span>    <span class="c1">///&lt; number of heaps</span>
        <span class="kt">size_t</span> <span class="n">k</span><span class="p">;</span>     <span class="c1">///&lt; allocated size per heap</span>
        <span class="n">TI</span> <span class="o">*</span> <span class="n">ids</span><span class="p">;</span>     <span class="c1">///&lt; identifiers (size nh * k)</span>
        <span class="n">T</span> <span class="o">*</span> <span class="n">val</span><span class="p">;</span>      <span class="c1">///&lt; values (distances or similarities), size nh * k</span>

        <span class="c1">/// Return the list of values for a heap</span>
        <span class="n">T</span> <span class="o">*</span> <span class="nf">get_val</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">val</span> <span class="o">+</span> <span class="n">key</span> <span class="o">*</span> <span class="n">k</span><span class="p">;</span> <span class="p">}</span>

        <span class="c1">/// Correspponding identifiers</span>
        <span class="n">TI</span> <span class="o">*</span> <span class="nf">get_ids</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">ids</span> <span class="o">+</span> <span class="n">key</span> <span class="o">*</span> <span class="n">k</span><span class="p">;</span> <span class="p">}</span>

        <span class="c1">/// prepare all the heaps before adding</span>
        <span class="kt">void</span> <span class="nf">heapify</span> <span class="p">(){</span>
            <span class="cp">#pragma omp parallel for</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nh</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
                    <span class="n">heap_heapify</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">val</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="n">k</span><span class="p">,</span> <span class="n">ids</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="n">k</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="cm">/** add nj elements to heaps i0:i0+ni, with sequential ids</span>
<span class="cm">         *</span>
<span class="cm">         * @param nj    nb of elements to add to each heap</span>
<span class="cm">         * @param vin   elements to add, size ni * nj</span>
<span class="cm">         * @param j0    add this to the ids that are added</span>
<span class="cm">         * @param i0    first heap to update</span>
<span class="cm">         * @param ni    nb of elements to update (-1 = use nh)</span>
<span class="cm">         */</span>
        <span class="kt">void</span> <span class="nf">addn</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">nj</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span> <span class="o">*</span><span class="n">vin</span><span class="p">,</span> <span class="n">TI</span> <span class="n">j0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">i0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">ni</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ni</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="n">ni</span> <span class="o">=</span> <span class="n">nh</span><span class="p">;</span>
            <span class="n">assert</span> <span class="p">(</span><span class="n">i0</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">i0</span> <span class="o">+</span> <span class="n">ni</span> <span class="o">&lt;=</span> <span class="n">nh</span><span class="p">);</span>
            <span class="cp">#pragma omp parallel for</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">i0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">i0</span> <span class="o">+</span> <span class="n">ni</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">T</span> <span class="o">*</span> <span class="n">__restrict</span> <span class="n">simi</span> <span class="o">=</span> <span class="n">get_val</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
                    <span class="n">TI</span> <span class="o">*</span> <span class="n">__restrict</span> <span class="n">idxi</span> <span class="o">=</span> <span class="n">get_ids</span> <span class="p">(</span><span class="n">i</span><span class="p">);</span>
                    <span class="k">const</span> <span class="n">T</span> <span class="o">*</span><span class="n">ip_line</span> <span class="o">=</span> <span class="n">vin</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">i0</span><span class="p">)</span> <span class="o">*</span> <span class="n">nj</span><span class="p">;</span>

                    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nj</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">T</span> <span class="n">ip</span> <span class="o">=</span> <span class="n">ip_line</span> <span class="p">[</span><span class="n">j</span><span class="p">];</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">C</span><span class="o">::</span><span class="n">cmp</span><span class="p">(</span><span class="n">simi</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ip</span><span class="p">))</span> <span class="p">{</span>
                            <span class="n">heap_pop</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">simi</span><span class="p">,</span> <span class="n">idxi</span><span class="p">);</span>
                            <span class="n">heap_push</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">simi</span><span class="p">,</span> <span class="n">idxi</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="n">j0</span><span class="p">);</span>
                        <span class="p">}</span>
                    <span class="p">}</span>
        <span class="p">}</span>

        <span class="cm">/** same as addn</span>
<span class="cm">         * @param id_in     ids of the elements to add, size ni * nj</span>
<span class="cm">         * @param id_stride stride for id_in</span>
<span class="cm">         */</span>
        <span class="kt">void</span> <span class="n">addn_with_ids</span> <span class="p">(</span> <span class="kt">size_t</span> <span class="n">nj</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span> <span class="o">*</span><span class="n">vin</span><span class="p">,</span> <span class="k">const</span> <span class="n">TI</span> <span class="o">*</span><span class="n">id_in</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">,</span>
                <span class="kt">int64_t</span> <span class="n">id_stride</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">i0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">ni</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">id_in</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">addn</span> <span class="p">(</span><span class="n">nj</span><span class="p">,</span> <span class="n">vin</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i0</span><span class="p">,</span> <span class="n">ni</span><span class="p">);</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ni</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="n">ni</span> <span class="o">=</span> <span class="n">nh</span><span class="p">;</span>
            <span class="n">assert</span> <span class="p">(</span><span class="n">i0</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">i0</span> <span class="o">+</span> <span class="n">ni</span> <span class="o">&lt;=</span> <span class="n">nh</span><span class="p">);</span>
            <span class="cp">#pragma omp parallel for</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">i0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">i0</span> <span class="o">+</span> <span class="n">ni</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">T</span> <span class="o">*</span> <span class="n">__restrict</span> <span class="n">simi</span> <span class="o">=</span> <span class="n">get_val</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
                    <span class="n">TI</span> <span class="o">*</span> <span class="n">__restrict</span> <span class="n">idxi</span> <span class="o">=</span> <span class="n">get_ids</span> <span class="p">(</span><span class="n">i</span><span class="p">);</span>
                    <span class="k">const</span> <span class="n">T</span> <span class="o">*</span><span class="n">ip_line</span> <span class="o">=</span> <span class="n">vin</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">i0</span><span class="p">)</span> <span class="o">*</span> <span class="n">nj</span><span class="p">;</span>
                    <span class="k">const</span> <span class="n">TI</span> <span class="o">*</span><span class="n">id_line</span> <span class="o">=</span> <span class="n">id_in</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">i0</span><span class="p">)</span> <span class="o">*</span> <span class="n">id_stride</span><span class="p">;</span>

                    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nj</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">T</span> <span class="n">ip</span> <span class="o">=</span> <span class="n">ip_line</span> <span class="p">[</span><span class="n">j</span><span class="p">];</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">C</span><span class="o">::</span><span class="n">cmp</span><span class="p">(</span><span class="n">simi</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ip</span><span class="p">))</span> <span class="p">{</span>
                            <span class="n">heap_pop</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">simi</span><span class="p">,</span> <span class="n">idxi</span><span class="p">);</span>
                            <span class="n">heap_push</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">simi</span><span class="p">,</span> <span class="n">idxi</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">id_line</span> <span class="p">[</span><span class="n">j</span><span class="p">]);</span>
                        <span class="p">}</span>
                    <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">/// reorder all the heaps</span>
        <span class="kt">void</span> <span class="n">reorder</span> <span class="p">(){</span>
            <span class="cp">#pragma omp parallel for</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nh</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
                    <span class="n">heap_reorder</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">val</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="n">k</span><span class="p">,</span> <span class="n">ids</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="n">k</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="cm">/** this is not really a heap function. It just finds the per-line</span>
<span class="cm">         *   extrema of each line of array D</span>
<span class="cm">         * @param vals_out    extreme value of each line (size nh, or NULL)</span>
<span class="cm">         * @param idx_out     index of extreme value (size nh or NULL)</span>
<span class="cm">         */</span>
        <span class="kt">void</span> <span class="n">per_line_extrema</span> <span class="p">(</span><span class="n">T</span> <span class="o">*</span><span class="n">vals_out</span><span class="p">,</span> <span class="n">TI</span> <span class="o">*</span><span class="n">idx_out</span><span class="p">)</span> <span class="k">const</span><span class="p">{</span>
            <span class="cp">#pragma omp parallel for</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nh</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                    <span class="kt">int64_t</span> <span class="n">imin</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
                    <span class="k">typename</span> <span class="n">C</span><span class="o">::</span><span class="n">T</span> <span class="n">xval</span> <span class="o">=</span> <span class="n">C</span><span class="o">::</span><span class="n">Crev</span><span class="o">::</span><span class="n">neutral</span> <span class="p">();</span>
                    <span class="k">const</span> <span class="k">typename</span> <span class="n">C</span><span class="o">::</span><span class="n">T</span> <span class="o">*</span> <span class="n">x_</span> <span class="o">=</span> <span class="n">val</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="n">k</span><span class="p">;</span>
                    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">C</span><span class="o">::</span><span class="n">cmp</span> <span class="p">(</span><span class="n">x_</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">xval</span><span class="p">))</span> <span class="p">{</span>
                            <span class="n">xval</span> <span class="o">=</span> <span class="n">x_</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                            <span class="n">imin</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
                        <span class="p">}</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">out_val</span><span class="p">)</span>
                        <span class="n">out_val</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">xval</span><span class="p">;</span>

                    <span class="k">if</span> <span class="p">(</span><span class="n">out_ids</span><span class="p">)</span> <span class="p">{</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">ids</span> <span class="o">&amp;&amp;</span> <span class="n">imin</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                            <span class="n">out_ids</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">ids</span> <span class="p">[</span><span class="n">j</span> <span class="o">*</span> <span class="n">k</span> <span class="o">+</span> <span class="n">imin</span><span class="p">];</span>
                        <span class="k">else</span>
                            <span class="n">out_ids</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">imin</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/* Define useful heaps */</span>
    <span class="k">typedef</span> <span class="n">HeapArray</span><span class="o">&lt;</span><span class="n">CMin</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="kt">int64_t</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">float_minheap_array_t</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">HeapArray</span><span class="o">&lt;</span><span class="n">CMin</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int64_t</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">int_minheap_array_t</span><span class="p">;</span>

    <span class="k">typedef</span> <span class="n">HeapArray</span><span class="o">&lt;</span><span class="n">CMax</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="kt">int64_t</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">float_maxheap_array_t</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">HeapArray</span><span class="o">&lt;</span><span class="n">CMax</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int64_t</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">int_maxheap_array_t</span><span class="p">;</span>


    <span class="cm">/*********************************************************************</span>
<span class="cm">     * Indirect heaps: instead of having</span>
<span class="cm">     *          node i = (bh_ids[i], bh_val[i]),</span>
<span class="cm">     * in indirect heaps,</span>
<span class="cm">     *          node i = (bh_ids[i], bh_val[bh_ids[i]]),</span>
<span class="cm">     *********************************************************************/</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">C</span><span class="o">&gt;</span>
    <span class="kr">inline</span> <span class="kt">void</span> <span class="n">indirect_heap_pop</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">k</span><span class="p">,</span><span class="k">const</span> <span class="k">typename</span> <span class="n">C</span><span class="o">::</span><span class="n">T</span> <span class="o">*</span> <span class="n">bh_val</span><span class="p">,</span> <span class="k">typename</span> <span class="n">C</span><span class="o">::</span><span class="n">TI</span> <span class="o">*</span> <span class="n">bh_ids</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">bh_ids</span><span class="o">--</span><span class="p">;</span> <span class="cm">/* Use 1-based indexing for easier node-&gt;child translation */</span>
        <span class="k">typename</span> <span class="n">C</span><span class="o">::</span><span class="n">T</span> <span class="n">val</span> <span class="o">=</span> <span class="n">bh_val</span><span class="p">[</span><span class="n">bh_ids</span><span class="p">[</span><span class="n">k</span><span class="p">]];</span>
        <span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">size_t</span> <span class="n">i1</span> <span class="o">=</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
            <span class="kt">size_t</span> <span class="n">i2</span> <span class="o">=</span> <span class="n">i1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i1</span> <span class="o">&gt;</span> <span class="n">k</span><span class="p">)</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">typename</span> <span class="n">C</span><span class="o">::</span><span class="n">TI</span> <span class="n">id1</span> <span class="o">=</span> <span class="n">bh_ids</span><span class="p">[</span><span class="n">i1</span><span class="p">],</span> <span class="n">id2</span> <span class="o">=</span> <span class="n">bh_ids</span><span class="p">[</span><span class="n">i2</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i2</span> <span class="o">==</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">C</span><span class="o">::</span><span class="n">cmp</span><span class="p">(</span><span class="n">bh_val</span><span class="p">[</span><span class="n">id1</span><span class="p">],</span> <span class="n">bh_val</span><span class="p">[</span><span class="n">id2</span><span class="p">]))</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">C</span><span class="o">::</span><span class="n">cmp</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">bh_val</span><span class="p">[</span><span class="n">id1</span><span class="p">]))</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="n">bh_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">id1</span><span class="p">;</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">i1</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">C</span><span class="o">::</span><span class="n">cmp</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">bh_val</span><span class="p">[</span><span class="n">id2</span><span class="p">]))</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="n">bh_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">id2</span><span class="p">;</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">i2</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">bh_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">bh_ids</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">C</span><span class="o">&gt;</span>
    <span class="kr">inline</span> <span class="kt">void</span> <span class="n">indirect_heap_push</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">k</span><span class="p">,</span><span class="k">const</span> <span class="k">typename</span> <span class="n">C</span><span class="o">::</span><span class="n">T</span> <span class="o">*</span> <span class="n">bh_val</span><span class="p">,</span> <span class="k">typename</span> <span class="n">C</span><span class="o">::</span><span class="n">TI</span> <span class="o">*</span> <span class="n">bh_ids</span><span class="p">,</span>
                         <span class="k">typename</span> <span class="n">C</span><span class="o">::</span><span class="n">TI</span> <span class="n">id</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">bh_ids</span><span class="o">--</span><span class="p">;</span> <span class="cm">/* Use 1-based indexing for easier node-&gt;child translation */</span>
        <span class="k">typename</span> <span class="n">C</span><span class="o">::</span><span class="n">T</span> <span class="n">val</span> <span class="o">=</span> <span class="n">bh_val</span><span class="p">[</span><span class="n">id</span><span class="p">];</span>
        <span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">size_t</span> <span class="n">i_father</span> <span class="o">=</span> <span class="n">i</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">C</span><span class="o">::</span><span class="n">cmp</span> <span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">bh_val</span><span class="p">[</span><span class="n">bh_ids</span><span class="p">[</span><span class="n">i_father</span><span class="p">]]))</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="n">bh_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">bh_ids</span><span class="p">[</span><span class="n">i_father</span><span class="p">];</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">i_father</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">bh_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// explicit instanciations</span>
    <span class="k">template</span> <span class="k">struct</span> <span class="n">HeapArray</span><span class="o">&lt;</span><span class="n">CMin</span> <span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="kt">int64_t</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">;</span>
    <span class="k">template</span> <span class="k">struct</span> <span class="n">HeapArray</span><span class="o">&lt;</span><span class="n">CMax</span> <span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="kt">int64_t</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">;</span>
    <span class="k">template</span> <span class="k">struct</span> <span class="n">HeapArray</span><span class="o">&lt;</span><span class="n">CMin</span> <span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int64_t</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">;</span>
    <span class="k">template</span> <span class="k">struct</span> <span class="n">HeapArray</span><span class="o">&lt;</span><span class="n">CMax</span> <span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int64_t</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">;</span>

<span class="p">}</span> <span class="c1">// namespace faiss</span>

<span class="cp">#endif  </span><span class="cm">/* FAISS_Heap_h */</span><span class="cp"></span>
</pre></div>

<h3 id="413-distanceshdistancescpp">4.1.3 <code>distances.h</code>、<code>distances.cpp</code>文件<a class="headerlink" href="#413-distanceshdistancescpp" title="Permanent link">&para;</a></h3>
<ul>
<li><strong><code>distances.h</code>文件</strong></li>
</ul>
<div class="highlight"><pre><span></span><span class="cm">/* All distance functions for L2 and IP distances.</span>
<span class="cm"> * The actual functions are implemented in distances.cpp and distances_simd.cpp */</span>

<span class="cp">#pragma once</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;faiss/utils/Heap.h&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">faiss</span> <span class="p">{</span>

    <span class="c1">/// Optimized distance/norm/inner prod computations</span>

    <span class="c1">/// Squared L2 distance between two vectors</span>
    <span class="kt">float</span> <span class="n">fvec_L2sqr</span> <span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">y</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">d</span><span class="p">);</span>

    <span class="c1">/// inner product</span>
    <span class="kt">float</span> <span class="nf">fvec_inner_product</span> <span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">y</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">d</span><span class="p">);</span>

    <span class="c1">/// L1 distance</span>
    <span class="kt">float</span> <span class="nf">fvec_L1</span> <span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">y</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">d</span><span class="p">);</span>

<span class="kt">float</span> <span class="nf">fvec_Linf</span> <span class="p">(</span>
        <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">y</span><span class="p">,</span>
        <span class="kt">size_t</span> <span class="n">d</span><span class="p">);</span>


<span class="cm">/** Compute pairwise distances between sets of vectors</span>
<span class="cm"> *</span>
<span class="cm"> * @param d     dimension of the vectors</span>
<span class="cm"> * @param nq    nb of query vectors</span>
<span class="cm"> * @param nb    nb of database vectors</span>
<span class="cm"> * @param xq    query vectors (size nq * d)</span>
<span class="cm"> * @param xb    database vectros (size nb * d)</span>
<span class="cm"> * @param dis   output distances (size nq * nb)</span>
<span class="cm"> * @param ldq,ldb, ldd strides for the matrices</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">pairwise_L2sqr</span> <span class="p">(</span><span class="kt">int64_t</span> <span class="n">d</span><span class="p">,</span>
                     <span class="kt">int64_t</span> <span class="n">nq</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">xq</span><span class="p">,</span>
                     <span class="kt">int64_t</span> <span class="n">nb</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">xb</span><span class="p">,</span>
                     <span class="kt">float</span> <span class="o">*</span><span class="n">dis</span><span class="p">,</span>
                     <span class="kt">int64_t</span> <span class="n">ldq</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">ldb</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">ldd</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

<span class="cm">/* compute the inner product between nx vectors x and one y */</span>
<span class="kt">void</span> <span class="nf">fvec_inner_products_ny</span> <span class="p">(</span>
        <span class="kt">float</span> <span class="o">*</span> <span class="n">ip</span><span class="p">,</span>         <span class="cm">/* output inner product */</span>
        <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">y</span><span class="p">,</span>
        <span class="kt">size_t</span> <span class="n">d</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">ny</span><span class="p">);</span>

<span class="cm">/* compute ny square L2 distance bewteen x and a set of contiguous y vectors */</span>
<span class="kt">void</span> <span class="nf">fvec_L2sqr_ny</span> <span class="p">(</span>
        <span class="kt">float</span> <span class="o">*</span> <span class="n">dis</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">y</span><span class="p">,</span>
        <span class="kt">size_t</span> <span class="n">d</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">ny</span><span class="p">);</span>


<span class="cm">/** squared norm of a vector */</span>
<span class="kt">float</span> <span class="nf">fvec_norm_L2sqr</span> <span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span>
                       <span class="kt">size_t</span> <span class="n">d</span><span class="p">);</span>

<span class="cm">/** compute the L2 norms for a set of vectors</span>
<span class="cm"> *</span>
<span class="cm"> * @param  ip       output norms, size nx</span>
<span class="cm"> * @param  x        set of vectors, size nx * d</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">fvec_norms_L2</span> <span class="p">(</span><span class="kt">float</span> <span class="o">*</span> <span class="n">ip</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">d</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nx</span><span class="p">);</span>

<span class="c1">/// same as fvec_norms_L2, but computes square norms</span>
<span class="kt">void</span> <span class="nf">fvec_norms_L2sqr</span> <span class="p">(</span><span class="kt">float</span> <span class="o">*</span> <span class="n">ip</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">d</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nx</span><span class="p">);</span>

<span class="cm">/* L2-renormalize a set of vector. Nothing done if the vector is 0-normed */</span>
<span class="kt">void</span> <span class="nf">fvec_renorm_L2</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">d</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nx</span><span class="p">,</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">x</span><span class="p">);</span>


<span class="cm">/* This function exists because the Torch counterpart is extremly slow</span>
<span class="cm">   (not multi-threaded + unexpected overhead even in single thread).</span>
<span class="cm">   It is here to implement the usual property |x-y|^2=|x|^2+|y|^2-2&lt;x|y&gt;  */</span>
<span class="kt">void</span> <span class="nf">inner_product_to_L2sqr</span> <span class="p">(</span><span class="kt">float</span> <span class="o">*</span> <span class="n">dis</span><span class="p">,</span>
                             <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">nr1</span><span class="p">,</span>
                             <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">nr2</span><span class="p">,</span>
                             <span class="kt">size_t</span> <span class="n">n1</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n2</span><span class="p">);</span>

<span class="cm">/***************************************************************************</span>
<span class="cm"> * Compute a subset of  distances</span>
<span class="cm"> ***************************************************************************/</span>

 <span class="cm">/* compute the inner product between x and a subset y of ny vectors,</span>
<span class="cm">   whose indices are given by idy.  */</span>
<span class="kt">void</span> <span class="nf">fvec_inner_products_by_idx</span> <span class="p">(</span>
        <span class="kt">float</span> <span class="o">*</span> <span class="n">ip</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">y</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">int64_t</span> <span class="o">*</span><span class="n">ids</span><span class="p">,</span>
        <span class="kt">size_t</span> <span class="n">d</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nx</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">ny</span><span class="p">);</span>

<span class="cm">/* same but for a subset in y indexed by idsy (ny vectors in total) */</span>
<span class="kt">void</span> <span class="nf">fvec_L2sqr_by_idx</span> <span class="p">(</span>
        <span class="kt">float</span> <span class="o">*</span> <span class="n">dis</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">y</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">int64_t</span> <span class="o">*</span><span class="n">ids</span><span class="p">,</span> <span class="cm">/* ids of y vecs */</span>
        <span class="kt">size_t</span> <span class="n">d</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nx</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">ny</span><span class="p">);</span>


<span class="cm">/** compute dis[j] = L2sqr(x[ix[j]], y[iy[j]]) forall j=0..n-1</span>
<span class="cm"> *</span>
<span class="cm"> * @param x  size (max(ix) + 1, d)</span>
<span class="cm"> * @param y  size (max(iy) + 1, d)</span>
<span class="cm"> * @param ix size n</span>
<span class="cm"> * @param iy size n</span>
<span class="cm"> * @param dis size n</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">pairwise_indexed_L2sqr</span> <span class="p">(</span>
        <span class="kt">size_t</span> <span class="n">d</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int64_t</span> <span class="o">*</span><span class="n">ix</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">y</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int64_t</span> <span class="o">*</span><span class="n">iy</span><span class="p">,</span>
        <span class="kt">float</span> <span class="o">*</span><span class="n">dis</span><span class="p">);</span>

<span class="cm">/* same for inner product */</span>
<span class="kt">void</span> <span class="nf">pairwise_indexed_inner_product</span> <span class="p">(</span>
        <span class="kt">size_t</span> <span class="n">d</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int64_t</span> <span class="o">*</span><span class="n">ix</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">y</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int64_t</span> <span class="o">*</span><span class="n">iy</span><span class="p">,</span>
        <span class="kt">float</span> <span class="o">*</span><span class="n">dis</span><span class="p">);</span>

<span class="cm">/***************************************************************************</span>
<span class="cm"> * KNN functions</span>
<span class="cm"> ***************************************************************************/</span>

<span class="c1">// threshold on nx above which we switch to BLAS to compute distances</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">distance_compute_blas_threshold</span><span class="p">;</span>

<span class="cm">/** Return the k nearest neighors of each of the nx vectors x among the ny</span>
<span class="cm"> *  vector y, w.r.t to max inner product</span>
<span class="cm"> *</span>
<span class="cm"> * @param x    query vectors, size nx * d</span>
<span class="cm"> * @param y    database vectors, size ny * d</span>
<span class="cm"> * @param res  result array, which also provides k. Sorted on output</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">knn_inner_product</span> <span class="p">(</span>
        <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">y</span><span class="p">,</span>
        <span class="kt">size_t</span> <span class="n">d</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nx</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">ny</span><span class="p">,</span>
        <span class="n">float_minheap_array_t</span> <span class="o">*</span> <span class="n">res</span><span class="p">);</span>

<span class="cm">/** Same as knn_inner_product, for the L2 distance */</span>
<span class="kt">void</span> <span class="nf">knn_L2sqr</span> <span class="p">(</span>
        <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">y</span><span class="p">,</span>
        <span class="kt">size_t</span> <span class="n">d</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nx</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">ny</span><span class="p">,</span>
        <span class="n">float_maxheap_array_t</span> <span class="o">*</span> <span class="n">res</span><span class="p">);</span>



<span class="cm">/** same as knn_L2sqr, but base_shift[bno] is subtracted to all</span>
<span class="cm"> * computed distances.</span>
<span class="cm"> *</span>
<span class="cm"> * @param base_shift   size ny</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">knn_L2sqr_base_shift</span> <span class="p">(</span>
         <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span>
         <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">y</span><span class="p">,</span>
         <span class="kt">size_t</span> <span class="n">d</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nx</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">ny</span><span class="p">,</span>
         <span class="n">float_maxheap_array_t</span> <span class="o">*</span> <span class="n">res</span><span class="p">,</span>
         <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">base_shift</span><span class="p">);</span>

<span class="cm">/* Find the nearest neighbors for nx queries in a set of ny vectors</span>
<span class="cm"> * indexed by ids. May be useful for re-ranking a pre-selected vector list</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">knn_inner_products_by_idx</span> <span class="p">(</span>
        <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">y</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">int64_t</span> <span class="o">*</span>  <span class="n">ids</span><span class="p">,</span>
        <span class="kt">size_t</span> <span class="n">d</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nx</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">ny</span><span class="p">,</span>
        <span class="n">float_minheap_array_t</span> <span class="o">*</span> <span class="n">res</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">knn_L2sqr_by_idx</span> <span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span>
                       <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">y</span><span class="p">,</span>
                       <span class="k">const</span> <span class="kt">int64_t</span> <span class="o">*</span> <span class="n">ids</span><span class="p">,</span>
                       <span class="kt">size_t</span> <span class="n">d</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nx</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">ny</span><span class="p">,</span>
                       <span class="n">float_maxheap_array_t</span> <span class="o">*</span> <span class="n">res</span><span class="p">);</span>

<span class="cm">/***************************************************************************</span>
<span class="cm"> * Range search</span>
<span class="cm"> ***************************************************************************/</span>



<span class="c1">/// Forward declaration, see AuxIndexStructures.h</span>
<span class="k">struct</span> <span class="n">RangeSearchResult</span><span class="p">;</span>

<span class="cm">/** Return the k nearest neighors of each of the nx vectors x among the ny</span>
<span class="cm"> *  vector y, w.r.t to max inner product</span>
<span class="cm"> *</span>
<span class="cm"> * @param x      query vectors, size nx * d</span>
<span class="cm"> * @param y      database vectors, size ny * d</span>
<span class="cm"> * @param radius search radius around the x vectors</span>
<span class="cm"> * @param result result structure</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">range_search_L2sqr</span> <span class="p">(</span>
        <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">y</span><span class="p">,</span>
        <span class="kt">size_t</span> <span class="n">d</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nx</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">ny</span><span class="p">,</span>
        <span class="kt">float</span> <span class="n">radius</span><span class="p">,</span>
        <span class="n">RangeSearchResult</span> <span class="o">*</span><span class="n">result</span><span class="p">);</span>

<span class="c1">/// same as range_search_L2sqr for the inner product similarity</span>
<span class="kt">void</span> <span class="nf">range_search_inner_product</span> <span class="p">(</span>
        <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">y</span><span class="p">,</span>
        <span class="kt">size_t</span> <span class="n">d</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nx</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">ny</span><span class="p">,</span>
        <span class="kt">float</span> <span class="n">radius</span><span class="p">,</span>
        <span class="n">RangeSearchResult</span> <span class="o">*</span><span class="n">result</span><span class="p">);</span>




<span class="p">}</span> <span class="c1">// namespace faiss</span>
</pre></div>

<ul>
<li><strong><code>distances.cpp</code>文件</strong></li>
</ul>
<div class="highlight"><pre><span></span><span class="c1">// -*- c++ -*-</span>

<span class="cp">#include</span> <span class="cpf">&lt;faiss/utils/distances.h&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cassert&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cstring&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cmath&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&lt;omp.h&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&lt;faiss/impl/AuxIndexStructures.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;faiss/impl/FaissAssert.h&gt;</span><span class="cp"></span>



<span class="cp">#ifndef FINTEGER</span>
<span class="cp">#define FINTEGER long</span>
<span class="cp">#endif</span>


<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="p">{</span>

<span class="cm">/* declare BLAS functions, see http://www.netlib.org/clapack/cblas/ */</span>

<span class="kt">int</span> <span class="n">sgemm_</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">transa</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">transb</span><span class="p">,</span> <span class="n">FINTEGER</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="n">FINTEGER</span> <span class="o">*</span>
            <span class="n">n</span><span class="p">,</span> <span class="n">FINTEGER</span> <span class="o">*</span><span class="n">k</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">alpha</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span>
            <span class="n">FINTEGER</span> <span class="o">*</span><span class="n">lda</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="n">FINTEGER</span> <span class="o">*</span>
            <span class="n">ldb</span><span class="p">,</span> <span class="kt">float</span> <span class="o">*</span><span class="n">beta</span><span class="p">,</span> <span class="kt">float</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">FINTEGER</span> <span class="o">*</span><span class="n">ldc</span><span class="p">);</span>

<span class="cm">/* Lapack functions, see http://www.netlib.org/clapack/old/single/sgeqrf.c */</span>

<span class="kt">int</span> <span class="nf">sgeqrf_</span> <span class="p">(</span><span class="n">FINTEGER</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="n">FINTEGER</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="kt">float</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="n">FINTEGER</span> <span class="o">*</span><span class="n">lda</span><span class="p">,</span>
                 <span class="kt">float</span> <span class="o">*</span><span class="n">tau</span><span class="p">,</span> <span class="kt">float</span> <span class="o">*</span><span class="n">work</span><span class="p">,</span> <span class="n">FINTEGER</span> <span class="o">*</span><span class="n">lwork</span><span class="p">,</span> <span class="n">FINTEGER</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">sgemv_</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="n">FINTEGER</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> <span class="n">FINTEGER</span> <span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="kt">float</span> <span class="o">*</span><span class="n">alpha</span><span class="p">,</span>
           <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="n">FINTEGER</span> <span class="o">*</span><span class="n">lda</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">FINTEGER</span> <span class="o">*</span><span class="n">incx</span><span class="p">,</span>
           <span class="kt">float</span> <span class="o">*</span><span class="n">beta</span><span class="p">,</span> <span class="kt">float</span> <span class="o">*</span><span class="n">y</span><span class="p">,</span> <span class="n">FINTEGER</span> <span class="o">*</span><span class="n">incy</span><span class="p">);</span>

<span class="p">}</span>


<span class="k">namespace</span> <span class="n">faiss</span> <span class="p">{</span>



<span class="cm">/***************************************************************************</span>
<span class="cm"> * Matrix/vector ops</span>
<span class="cm"> ***************************************************************************/</span>



<span class="cm">/* Compute the inner product between a vector x and</span>
<span class="cm">   a set of ny vectors y.</span>
<span class="cm">   These functions are not intended to replace BLAS matrix-matrix, as they</span>
<span class="cm">   would be significantly less efficient in this case. */</span>
<span class="kt">void</span> <span class="n">fvec_inner_products_ny</span> <span class="p">(</span><span class="kt">float</span> <span class="o">*</span> <span class="n">ip</span><span class="p">,</span>
                             <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span>
                             <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">y</span><span class="p">,</span>
                             <span class="kt">size_t</span> <span class="n">d</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">ny</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Not sure which one is fastest</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">    {</span>
<span class="c">        FINTEGER di = d;</span>
<span class="c">        FINTEGER nyi = ny;</span>
<span class="c">        float one = 1.0, zero = 0.0;</span>
<span class="c">        FINTEGER onei = 1;</span>
<span class="c">        sgemv_ (&quot;T&quot;, &amp;di, &amp;nyi, &amp;one, y, &amp;di, x, &amp;onei, &amp;zero, ip, &amp;onei);</span>
<span class="c">    }</span>
<span class="cp">#endif</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ny</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ip</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">fvec_inner_product</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
        <span class="n">y</span> <span class="o">+=</span> <span class="n">d</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>





<span class="cm">/* Compute the L2 norm of a set of nx vectors */</span>
<span class="kt">void</span> <span class="n">fvec_norms_L2</span> <span class="p">(</span><span class="kt">float</span> <span class="o">*</span> <span class="n">__restrict</span> <span class="n">nr</span><span class="p">,</span>
                    <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">__restrict</span> <span class="n">x</span><span class="p">,</span>
                    <span class="kt">size_t</span> <span class="n">d</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nx</span><span class="p">)</span>
<span class="p">{</span>

<span class="cp">#pragma omp parallel for</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nx</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">nr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrtf</span> <span class="p">(</span><span class="n">fvec_norm_L2sqr</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">fvec_norms_L2sqr</span> <span class="p">(</span><span class="kt">float</span> <span class="o">*</span> <span class="n">__restrict</span> <span class="n">nr</span><span class="p">,</span>
                       <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">__restrict</span> <span class="n">x</span><span class="p">,</span>
                       <span class="kt">size_t</span> <span class="n">d</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nx</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#pragma omp parallel for</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nx</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">nr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">fvec_norm_L2sqr</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
<span class="p">}</span>



<span class="kt">void</span> <span class="n">fvec_renorm_L2</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">d</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nx</span><span class="p">,</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">__restrict</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#pragma omp parallel for</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nx</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">float</span> <span class="o">*</span> <span class="n">__restrict</span> <span class="n">xi</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">d</span><span class="p">;</span>

        <span class="kt">float</span> <span class="n">nr</span> <span class="o">=</span> <span class="n">fvec_norm_L2sqr</span> <span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">nr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">size_t</span> <span class="n">j</span><span class="p">;</span>
            <span class="k">const</span> <span class="kt">float</span> <span class="n">inv_nr</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">sqrtf</span> <span class="p">(</span><span class="n">nr</span><span class="p">);</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
                <span class="n">xi</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*=</span> <span class="n">inv_nr</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>












<span class="cm">/***************************************************************************</span>
<span class="cm"> * KNN functions</span>
<span class="cm"> ***************************************************************************/</span>



<span class="cm">/* Find the nearest neighbors for nx queries in a set of ny vectors */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">knn_inner_product_sse</span> <span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span>
                        <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">y</span><span class="p">,</span>
                        <span class="kt">size_t</span> <span class="n">d</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nx</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">ny</span><span class="p">,</span>
                        <span class="n">float_minheap_array_t</span> <span class="o">*</span> <span class="n">res</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">k</span> <span class="o">=</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">k</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">check_period</span> <span class="o">=</span> <span class="n">InterruptCallback</span><span class="o">::</span><span class="n">get_period_hint</span> <span class="p">(</span><span class="n">ny</span> <span class="o">*</span> <span class="n">d</span><span class="p">);</span>

    <span class="n">check_period</span> <span class="o">*=</span> <span class="n">omp_get_max_threads</span><span class="p">();</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i0</span> <span class="o">&lt;</span> <span class="n">nx</span><span class="p">;</span> <span class="n">i0</span> <span class="o">+=</span> <span class="n">check_period</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">size_t</span> <span class="n">i1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">i0</span> <span class="o">+</span> <span class="n">check_period</span><span class="p">,</span> <span class="n">nx</span><span class="p">);</span>

<span class="cp">#pragma omp parallel for</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">i0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">i1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">x_i</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">d</span><span class="p">;</span>
            <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">y_j</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>

            <span class="kt">float</span> <span class="o">*</span> <span class="n">__restrict</span> <span class="n">simi</span> <span class="o">=</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">get_val</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
            <span class="kt">int64_t</span> <span class="o">*</span> <span class="n">__restrict</span> <span class="n">idxi</span> <span class="o">=</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">get_ids</span> <span class="p">(</span><span class="n">i</span><span class="p">);</span>

            <span class="n">minheap_heapify</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">simi</span><span class="p">,</span> <span class="n">idxi</span><span class="p">);</span>

            <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">ny</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="kt">float</span> <span class="n">ip</span> <span class="o">=</span> <span class="n">fvec_inner_product</span> <span class="p">(</span><span class="n">x_i</span><span class="p">,</span> <span class="n">y_j</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">ip</span> <span class="o">&gt;</span> <span class="n">simi</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
                    <span class="n">minheap_pop</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">simi</span><span class="p">,</span> <span class="n">idxi</span><span class="p">);</span>
                    <span class="n">minheap_push</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">simi</span><span class="p">,</span> <span class="n">idxi</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="n">y_j</span> <span class="o">+=</span> <span class="n">d</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">minheap_reorder</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">simi</span><span class="p">,</span> <span class="n">idxi</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">InterruptCallback</span><span class="o">::</span><span class="n">check</span> <span class="p">();</span>
    <span class="p">}</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">knn_L2sqr_sse</span> <span class="p">(</span>
                <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span>
                <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">y</span><span class="p">,</span>
                <span class="kt">size_t</span> <span class="n">d</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nx</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">ny</span><span class="p">,</span>
                <span class="n">float_maxheap_array_t</span> <span class="o">*</span> <span class="n">res</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">k</span> <span class="o">=</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">k</span><span class="p">;</span>

    <span class="kt">size_t</span> <span class="n">check_period</span> <span class="o">=</span> <span class="n">InterruptCallback</span><span class="o">::</span><span class="n">get_period_hint</span> <span class="p">(</span><span class="n">ny</span> <span class="o">*</span> <span class="n">d</span><span class="p">);</span>
    <span class="n">check_period</span> <span class="o">*=</span> <span class="n">omp_get_max_threads</span><span class="p">();</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i0</span> <span class="o">&lt;</span> <span class="n">nx</span><span class="p">;</span> <span class="n">i0</span> <span class="o">+=</span> <span class="n">check_period</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">size_t</span> <span class="n">i1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">i0</span> <span class="o">+</span> <span class="n">check_period</span><span class="p">,</span> <span class="n">nx</span><span class="p">);</span>

<span class="cp">#pragma omp parallel for</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">i0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">i1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">x_i</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">d</span><span class="p">;</span>
            <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">y_j</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>
            <span class="kt">size_t</span> <span class="n">j</span><span class="p">;</span>
            <span class="kt">float</span> <span class="o">*</span> <span class="n">simi</span> <span class="o">=</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">get_val</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
            <span class="kt">int64_t</span> <span class="o">*</span> <span class="n">idxi</span> <span class="o">=</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">get_ids</span> <span class="p">(</span><span class="n">i</span><span class="p">);</span>

            <span class="n">maxheap_heapify</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">simi</span><span class="p">,</span> <span class="n">idxi</span><span class="p">);</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">ny</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="kt">float</span> <span class="n">disij</span> <span class="o">=</span> <span class="n">fvec_L2sqr</span> <span class="p">(</span><span class="n">x_i</span><span class="p">,</span> <span class="n">y_j</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">disij</span> <span class="o">&lt;</span> <span class="n">simi</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
                    <span class="n">maxheap_pop</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">simi</span><span class="p">,</span> <span class="n">idxi</span><span class="p">);</span>
                    <span class="n">maxheap_push</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">simi</span><span class="p">,</span> <span class="n">idxi</span><span class="p">,</span> <span class="n">disij</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="n">y_j</span> <span class="o">+=</span> <span class="n">d</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">maxheap_reorder</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">simi</span><span class="p">,</span> <span class="n">idxi</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">InterruptCallback</span><span class="o">::</span><span class="n">check</span> <span class="p">();</span>
    <span class="p">}</span>

<span class="p">}</span>


<span class="cm">/** Find the nearest neighbors for nx queries in a set of ny vectors */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">knn_inner_product_blas</span> <span class="p">(</span>
        <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">y</span><span class="p">,</span>
        <span class="kt">size_t</span> <span class="n">d</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nx</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">ny</span><span class="p">,</span>
        <span class="n">float_minheap_array_t</span> <span class="o">*</span> <span class="n">res</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">res</span><span class="o">-&gt;</span><span class="n">heapify</span> <span class="p">();</span>

    <span class="c1">// BLAS does not like empty matrices</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nx</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">ny</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

    <span class="cm">/* block sizes */</span>
    <span class="k">const</span> <span class="kt">size_t</span> <span class="n">bs_x</span> <span class="o">=</span> <span class="mi">4096</span><span class="p">,</span> <span class="n">bs_y</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
    <span class="c1">// const size_t bs_x = 16, bs_y = 16;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">[]</span><span class="o">&gt;</span> <span class="n">ip_block</span><span class="p">(</span><span class="k">new</span> <span class="kt">float</span><span class="p">[</span><span class="n">bs_x</span> <span class="o">*</span> <span class="n">bs_y</span><span class="p">]);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i0</span> <span class="o">&lt;</span> <span class="n">nx</span><span class="p">;</span> <span class="n">i0</span> <span class="o">+=</span> <span class="n">bs_x</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">size_t</span> <span class="n">i1</span> <span class="o">=</span> <span class="n">i0</span> <span class="o">+</span> <span class="n">bs_x</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">i1</span> <span class="o">&gt;</span> <span class="n">nx</span><span class="p">)</span> <span class="n">i1</span> <span class="o">=</span> <span class="n">nx</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">j0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j0</span> <span class="o">&lt;</span> <span class="n">ny</span><span class="p">;</span> <span class="n">j0</span> <span class="o">+=</span> <span class="n">bs_y</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">size_t</span> <span class="n">j1</span> <span class="o">=</span> <span class="n">j0</span> <span class="o">+</span> <span class="n">bs_y</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">j1</span> <span class="o">&gt;</span> <span class="n">ny</span><span class="p">)</span> <span class="n">j1</span> <span class="o">=</span> <span class="n">ny</span><span class="p">;</span>
            <span class="cm">/* compute the actual dot products */</span>
            <span class="p">{</span>
                <span class="kt">float</span> <span class="n">one</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">zero</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="n">FINTEGER</span> <span class="n">nyi</span> <span class="o">=</span> <span class="n">j1</span> <span class="o">-</span> <span class="n">j0</span><span class="p">,</span> <span class="n">nxi</span> <span class="o">=</span> <span class="n">i1</span> <span class="o">-</span> <span class="n">i0</span><span class="p">,</span> <span class="n">di</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>
                <span class="n">sgemm_</span> <span class="p">(</span><span class="s">&quot;Transpose&quot;</span><span class="p">,</span> <span class="s">&quot;Not transpose&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nyi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nxi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">di</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">one</span><span class="p">,</span>
                        <span class="n">y</span> <span class="o">+</span> <span class="n">j0</span> <span class="o">*</span> <span class="n">d</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">di</span><span class="p">,</span>
                        <span class="n">x</span> <span class="o">+</span> <span class="n">i0</span> <span class="o">*</span> <span class="n">d</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">di</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zero</span><span class="p">,</span>
                        <span class="n">ip_block</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">nyi</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="cm">/* collect maxima */</span>
            <span class="n">res</span><span class="o">-&gt;</span><span class="n">addn</span> <span class="p">(</span><span class="n">j1</span> <span class="o">-</span> <span class="n">j0</span><span class="p">,</span> <span class="n">ip_block</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="n">j0</span><span class="p">,</span> <span class="n">i0</span><span class="p">,</span> <span class="n">i1</span> <span class="o">-</span> <span class="n">i0</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">InterruptCallback</span><span class="o">::</span><span class="n">check</span> <span class="p">();</span>
    <span class="p">}</span>
    <span class="n">res</span><span class="o">-&gt;</span><span class="n">reorder</span> <span class="p">();</span>
<span class="p">}</span>

<span class="c1">// distance correction is an operator that can be applied to transform</span>
<span class="c1">// the distances</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">DistanceCorrection</span><span class="o">&gt;</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">knn_L2sqr_blas</span> <span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">y</span><span class="p">,</span>
        <span class="kt">size_t</span> <span class="n">d</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nx</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">ny</span><span class="p">,</span>
        <span class="n">float_maxheap_array_t</span> <span class="o">*</span> <span class="n">res</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">DistanceCorrection</span> <span class="o">&amp;</span><span class="n">corr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">res</span><span class="o">-&gt;</span><span class="n">heapify</span> <span class="p">();</span>

    <span class="c1">// BLAS does not like empty matrices</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nx</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">ny</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

    <span class="kt">size_t</span> <span class="n">k</span> <span class="o">=</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">k</span><span class="p">;</span>

    <span class="cm">/* block sizes */</span>
    <span class="k">const</span> <span class="kt">size_t</span> <span class="n">bs_x</span> <span class="o">=</span> <span class="mi">4096</span><span class="p">,</span> <span class="n">bs_y</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
    <span class="c1">// const size_t bs_x = 16, bs_y = 16;</span>
    <span class="kt">float</span> <span class="o">*</span><span class="n">ip_block</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">float</span><span class="p">[</span><span class="n">bs_x</span> <span class="o">*</span> <span class="n">bs_y</span><span class="p">];</span>
    <span class="kt">float</span> <span class="o">*</span><span class="n">x_norms</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">float</span><span class="p">[</span><span class="n">nx</span><span class="p">];</span>
    <span class="kt">float</span> <span class="o">*</span><span class="n">y_norms</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">float</span><span class="p">[</span><span class="n">ny</span><span class="p">];</span>
    <span class="n">ScopeDeleter</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">del1</span><span class="p">(</span><span class="n">ip_block</span><span class="p">),</span> <span class="n">del3</span><span class="p">(</span><span class="n">x_norms</span><span class="p">),</span> <span class="n">del2</span><span class="p">(</span><span class="n">y_norms</span><span class="p">);</span>

    <span class="n">fvec_norms_L2sqr</span> <span class="p">(</span><span class="n">x_norms</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">nx</span><span class="p">);</span>
    <span class="n">fvec_norms_L2sqr</span> <span class="p">(</span><span class="n">y_norms</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">ny</span><span class="p">);</span>


    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i0</span> <span class="o">&lt;</span> <span class="n">nx</span><span class="p">;</span> <span class="n">i0</span> <span class="o">+=</span> <span class="n">bs_x</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">size_t</span> <span class="n">i1</span> <span class="o">=</span> <span class="n">i0</span> <span class="o">+</span> <span class="n">bs_x</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">i1</span> <span class="o">&gt;</span> <span class="n">nx</span><span class="p">)</span> <span class="n">i1</span> <span class="o">=</span> <span class="n">nx</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">j0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j0</span> <span class="o">&lt;</span> <span class="n">ny</span><span class="p">;</span> <span class="n">j0</span> <span class="o">+=</span> <span class="n">bs_y</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">size_t</span> <span class="n">j1</span> <span class="o">=</span> <span class="n">j0</span> <span class="o">+</span> <span class="n">bs_y</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">j1</span> <span class="o">&gt;</span> <span class="n">ny</span><span class="p">)</span> <span class="n">j1</span> <span class="o">=</span> <span class="n">ny</span><span class="p">;</span>
            <span class="cm">/* compute the actual dot products */</span>
            <span class="p">{</span>
                <span class="kt">float</span> <span class="n">one</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">zero</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="n">FINTEGER</span> <span class="n">nyi</span> <span class="o">=</span> <span class="n">j1</span> <span class="o">-</span> <span class="n">j0</span><span class="p">,</span> <span class="n">nxi</span> <span class="o">=</span> <span class="n">i1</span> <span class="o">-</span> <span class="n">i0</span><span class="p">,</span> <span class="n">di</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>
                <span class="n">sgemm_</span> <span class="p">(</span><span class="s">&quot;Transpose&quot;</span><span class="p">,</span> <span class="s">&quot;Not transpose&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nyi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nxi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">di</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">one</span><span class="p">,</span>
                        <span class="n">y</span> <span class="o">+</span> <span class="n">j0</span> <span class="o">*</span> <span class="n">d</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">di</span><span class="p">,</span>
                        <span class="n">x</span> <span class="o">+</span> <span class="n">i0</span> <span class="o">*</span> <span class="n">d</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">di</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zero</span><span class="p">,</span>
                        <span class="n">ip_block</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nyi</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="cm">/* collect minima */</span>
<span class="cp">#pragma omp parallel for</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">i0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">i1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="kt">float</span> <span class="o">*</span> <span class="n">__restrict</span> <span class="n">simi</span> <span class="o">=</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">get_val</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
                <span class="kt">int64_t</span> <span class="o">*</span> <span class="n">__restrict</span> <span class="n">idxi</span> <span class="o">=</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">get_ids</span> <span class="p">(</span><span class="n">i</span><span class="p">);</span>
                <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">ip_line</span> <span class="o">=</span> <span class="n">ip_block</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">i0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">j1</span> <span class="o">-</span> <span class="n">j0</span><span class="p">);</span>

                <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="n">j0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">j1</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                    <span class="kt">float</span> <span class="n">ip</span> <span class="o">=</span> <span class="o">*</span><span class="n">ip_line</span><span class="o">++</span><span class="p">;</span>
                    <span class="kt">float</span> <span class="n">dis</span> <span class="o">=</span> <span class="n">x_norms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">y_norms</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">ip</span><span class="p">;</span>

                    <span class="c1">// negative values can occur for identical vectors</span>
                    <span class="c1">// due to roundoff errors</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">dis</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">dis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

                    <span class="n">dis</span> <span class="o">=</span> <span class="n">corr</span> <span class="p">(</span><span class="n">dis</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>

                    <span class="k">if</span> <span class="p">(</span><span class="n">dis</span> <span class="o">&lt;</span> <span class="n">simi</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
                        <span class="n">maxheap_pop</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">simi</span><span class="p">,</span> <span class="n">idxi</span><span class="p">);</span>
                        <span class="n">maxheap_push</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">simi</span><span class="p">,</span> <span class="n">idxi</span><span class="p">,</span> <span class="n">dis</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">InterruptCallback</span><span class="o">::</span><span class="n">check</span> <span class="p">();</span>
    <span class="p">}</span>
    <span class="n">res</span><span class="o">-&gt;</span><span class="n">reorder</span> <span class="p">();</span>

<span class="p">}</span>









<span class="cm">/*******************************************************</span>
<span class="cm"> * KNN driver functions</span>
<span class="cm"> *******************************************************/</span>

<span class="kt">int</span> <span class="n">distance_compute_blas_threshold</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">knn_inner_product</span> <span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">y</span><span class="p">,</span>
        <span class="kt">size_t</span> <span class="n">d</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nx</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">ny</span><span class="p">,</span>
        <span class="n">float_minheap_array_t</span> <span class="o">*</span> <span class="n">res</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nx</span> <span class="o">&lt;</span> <span class="n">distance_compute_blas_threshold</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">knn_inner_product_sse</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">knn_inner_product_blas</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>



<span class="k">struct</span> <span class="n">NopDistanceCorrection</span> <span class="p">{</span>
  <span class="kt">float</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">float</span> <span class="n">dis</span><span class="p">,</span> <span class="kt">size_t</span> <span class="cm">/*qno*/</span><span class="p">,</span> <span class="kt">size_t</span> <span class="cm">/*bno*/</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">dis</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">knn_L2sqr</span> <span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span>
                <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">y</span><span class="p">,</span>
                <span class="kt">size_t</span> <span class="n">d</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nx</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">ny</span><span class="p">,</span>
                <span class="n">float_maxheap_array_t</span> <span class="o">*</span> <span class="n">res</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nx</span> <span class="o">&lt;</span> <span class="n">distance_compute_blas_threshold</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">knn_L2sqr_sse</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">NopDistanceCorrection</span> <span class="n">nop</span><span class="p">;</span>
        <span class="n">knn_L2sqr_blas</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">nop</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">BaseShiftDistanceCorrection</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">base_shift</span><span class="p">;</span>
    <span class="kt">float</span> <span class="nf">operator</span><span class="p">()(</span><span class="kt">float</span> <span class="n">dis</span><span class="p">,</span> <span class="kt">size_t</span> <span class="cm">/*qno*/</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">bno</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">dis</span> <span class="o">-</span> <span class="n">base_shift</span><span class="p">[</span><span class="n">bno</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">knn_L2sqr_base_shift</span> <span class="p">(</span>
         <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span>
         <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">y</span><span class="p">,</span>
         <span class="kt">size_t</span> <span class="n">d</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nx</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">ny</span><span class="p">,</span>
         <span class="n">float_maxheap_array_t</span> <span class="o">*</span> <span class="n">res</span><span class="p">,</span>
         <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">base_shift</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">BaseShiftDistanceCorrection</span> <span class="n">corr</span> <span class="o">=</span> <span class="p">{</span><span class="n">base_shift</span><span class="p">};</span>
    <span class="n">knn_L2sqr_blas</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">corr</span><span class="p">);</span>
<span class="p">}</span>



<span class="cm">/***************************************************************************</span>
<span class="cm"> * compute a subset of  distances</span>
<span class="cm"> ***************************************************************************/</span>

<span class="cm">/* compute the inner product between x and a subset y of ny vectors,</span>
<span class="cm">   whose indices are given by idy.  */</span>
<span class="kt">void</span> <span class="nf">fvec_inner_products_by_idx</span> <span class="p">(</span><span class="kt">float</span> <span class="o">*</span> <span class="n">__restrict</span> <span class="n">ip</span><span class="p">,</span>
                                 <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span>
                                 <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">y</span><span class="p">,</span>
                                 <span class="k">const</span> <span class="kt">int64_t</span> <span class="o">*</span> <span class="n">__restrict</span> <span class="n">ids</span><span class="p">,</span> <span class="cm">/* for y vecs */</span>
                                 <span class="kt">size_t</span> <span class="n">d</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nx</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">ny</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#pragma omp parallel for</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nx</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">const</span> <span class="kt">int64_t</span> <span class="o">*</span> <span class="n">__restrict</span> <span class="n">idsj</span> <span class="o">=</span> <span class="n">ids</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="n">ny</span><span class="p">;</span>
        <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">xj</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="n">d</span><span class="p">;</span>
        <span class="kt">float</span> <span class="o">*</span> <span class="n">__restrict</span> <span class="n">ipj</span> <span class="o">=</span> <span class="n">ip</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="n">ny</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ny</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">idsj</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="n">ipj</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">fvec_inner_product</span> <span class="p">(</span><span class="n">xj</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">d</span> <span class="o">*</span> <span class="n">idsj</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">d</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>



<span class="cm">/* compute the inner product between x and a subset y of ny vectors,</span>
<span class="cm">   whose indices are given by idy.  */</span>
<span class="kt">void</span> <span class="nf">fvec_L2sqr_by_idx</span> <span class="p">(</span><span class="kt">float</span> <span class="o">*</span> <span class="n">__restrict</span> <span class="n">dis</span><span class="p">,</span>
                        <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span>
                        <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">y</span><span class="p">,</span>
                        <span class="k">const</span> <span class="kt">int64_t</span> <span class="o">*</span> <span class="n">__restrict</span> <span class="n">ids</span><span class="p">,</span> <span class="cm">/* ids of y vecs */</span>
                        <span class="kt">size_t</span> <span class="n">d</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nx</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">ny</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#pragma omp parallel for</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nx</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">const</span> <span class="kt">int64_t</span> <span class="o">*</span> <span class="n">__restrict</span> <span class="n">idsj</span> <span class="o">=</span> <span class="n">ids</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="n">ny</span><span class="p">;</span>
        <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">xj</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="n">d</span><span class="p">;</span>
        <span class="kt">float</span> <span class="o">*</span> <span class="n">__restrict</span> <span class="n">disj</span> <span class="o">=</span> <span class="n">dis</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="n">ny</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ny</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">idsj</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="n">disj</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">fvec_L2sqr</span> <span class="p">(</span><span class="n">xj</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">d</span> <span class="o">*</span> <span class="n">idsj</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">d</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">pairwise_indexed_L2sqr</span> <span class="p">(</span>
        <span class="kt">size_t</span> <span class="n">d</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int64_t</span> <span class="o">*</span><span class="n">ix</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">y</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int64_t</span> <span class="o">*</span><span class="n">iy</span><span class="p">,</span>
        <span class="kt">float</span> <span class="o">*</span><span class="n">dis</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#pragma omp parallel for</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ix</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">iy</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">dis</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">fvec_L2sqr</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">d</span> <span class="o">*</span> <span class="n">ix</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">y</span> <span class="o">+</span> <span class="n">d</span> <span class="o">*</span> <span class="n">iy</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">d</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">pairwise_indexed_inner_product</span> <span class="p">(</span>
        <span class="kt">size_t</span> <span class="n">d</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int64_t</span> <span class="o">*</span><span class="n">ix</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">y</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int64_t</span> <span class="o">*</span><span class="n">iy</span><span class="p">,</span>
        <span class="kt">float</span> <span class="o">*</span><span class="n">dis</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#pragma omp parallel for</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ix</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">iy</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">dis</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">fvec_inner_product</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">d</span> <span class="o">*</span> <span class="n">ix</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">y</span> <span class="o">+</span> <span class="n">d</span> <span class="o">*</span> <span class="n">iy</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">d</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="cm">/* Find the nearest neighbors for nx queries in a set of ny vectors</span>
<span class="cm">   indexed by ids. May be useful for re-ranking a pre-selected vector list */</span>
<span class="kt">void</span> <span class="nf">knn_inner_products_by_idx</span> <span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span>
                                <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">y</span><span class="p">,</span>
                                <span class="k">const</span> <span class="kt">int64_t</span> <span class="o">*</span> <span class="n">ids</span><span class="p">,</span>
                                <span class="kt">size_t</span> <span class="n">d</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nx</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">ny</span><span class="p">,</span>
                                <span class="n">float_minheap_array_t</span> <span class="o">*</span> <span class="n">res</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">k</span> <span class="o">=</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">k</span><span class="p">;</span>

<span class="cp">#pragma omp parallel for</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nx</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">x_</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">d</span><span class="p">;</span>
        <span class="k">const</span> <span class="kt">int64_t</span> <span class="o">*</span> <span class="n">idsi</span> <span class="o">=</span> <span class="n">ids</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">ny</span><span class="p">;</span>
        <span class="kt">size_t</span> <span class="n">j</span><span class="p">;</span>
        <span class="kt">float</span> <span class="o">*</span> <span class="n">__restrict</span> <span class="n">simi</span> <span class="o">=</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">get_val</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="kt">int64_t</span> <span class="o">*</span> <span class="n">__restrict</span> <span class="n">idxi</span> <span class="o">=</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">get_ids</span> <span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="n">minheap_heapify</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">simi</span><span class="p">,</span> <span class="n">idxi</span><span class="p">);</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">ny</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">idsi</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
            <span class="kt">float</span> <span class="n">ip</span> <span class="o">=</span> <span class="n">fvec_inner_product</span> <span class="p">(</span><span class="n">x_</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">d</span> <span class="o">*</span> <span class="n">idsi</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">d</span><span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">ip</span> <span class="o">&gt;</span> <span class="n">simi</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">minheap_pop</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">simi</span><span class="p">,</span> <span class="n">idxi</span><span class="p">);</span>
                <span class="n">minheap_push</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">simi</span><span class="p">,</span> <span class="n">idxi</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">idsi</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">minheap_reorder</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">simi</span><span class="p">,</span> <span class="n">idxi</span><span class="p">);</span>
    <span class="p">}</span>

<span class="p">}</span>

<span class="kt">void</span> <span class="nf">knn_L2sqr_by_idx</span> <span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span>
                       <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">y</span><span class="p">,</span>
                       <span class="k">const</span> <span class="kt">int64_t</span> <span class="o">*</span> <span class="n">__restrict</span> <span class="n">ids</span><span class="p">,</span>
                       <span class="kt">size_t</span> <span class="n">d</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nx</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">ny</span><span class="p">,</span>
                       <span class="n">float_maxheap_array_t</span> <span class="o">*</span> <span class="n">res</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">k</span> <span class="o">=</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">k</span><span class="p">;</span>

<span class="cp">#pragma omp parallel for</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nx</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">x_</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">d</span><span class="p">;</span>
        <span class="k">const</span> <span class="kt">int64_t</span> <span class="o">*</span> <span class="n">__restrict</span> <span class="n">idsi</span> <span class="o">=</span> <span class="n">ids</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">ny</span><span class="p">;</span>
        <span class="kt">float</span> <span class="o">*</span> <span class="n">__restrict</span> <span class="n">simi</span> <span class="o">=</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">get_val</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="kt">int64_t</span> <span class="o">*</span> <span class="n">__restrict</span> <span class="n">idxi</span> <span class="o">=</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">get_ids</span> <span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="n">maxheap_heapify</span> <span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">k</span><span class="p">,</span> <span class="n">simi</span><span class="p">,</span> <span class="n">idxi</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">ny</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">float</span> <span class="n">disij</span> <span class="o">=</span> <span class="n">fvec_L2sqr</span> <span class="p">(</span><span class="n">x_</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">d</span> <span class="o">*</span> <span class="n">idsi</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">d</span><span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">disij</span> <span class="o">&lt;</span> <span class="n">simi</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">maxheap_pop</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">simi</span><span class="p">,</span> <span class="n">idxi</span><span class="p">);</span>
                <span class="n">maxheap_push</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">simi</span><span class="p">,</span> <span class="n">idxi</span><span class="p">,</span> <span class="n">disij</span><span class="p">,</span> <span class="n">idsi</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">maxheap_reorder</span> <span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">k</span><span class="p">,</span> <span class="n">simi</span><span class="p">,</span> <span class="n">idxi</span><span class="p">);</span>
    <span class="p">}</span>

<span class="p">}</span>





<span class="cm">/***************************************************************************</span>
<span class="cm"> * Range search</span>
<span class="cm"> ***************************************************************************/</span>

<span class="cm">/** Find the nearest neighbors for nx queries in a set of ny vectors</span>
<span class="cm"> * compute_l2 = compute pairwise squared L2 distance rather than inner prod</span>
<span class="cm"> */</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="kt">bool</span> <span class="n">compute_l2</span><span class="o">&gt;</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">range_search_blas</span> <span class="p">(</span>
        <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">y</span><span class="p">,</span>
        <span class="kt">size_t</span> <span class="n">d</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nx</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">ny</span><span class="p">,</span>
        <span class="kt">float</span> <span class="n">radius</span><span class="p">,</span>
        <span class="n">RangeSearchResult</span> <span class="o">*</span><span class="n">result</span><span class="p">)</span>
<span class="p">{</span>

    <span class="c1">// BLAS does not like empty matrices</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nx</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">ny</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

    <span class="cm">/* block sizes */</span>
    <span class="k">const</span> <span class="kt">size_t</span> <span class="n">bs_x</span> <span class="o">=</span> <span class="mi">4096</span><span class="p">,</span> <span class="n">bs_y</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
    <span class="c1">// const size_t bs_x = 16, bs_y = 16;</span>
    <span class="kt">float</span> <span class="o">*</span><span class="n">ip_block</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">float</span><span class="p">[</span><span class="n">bs_x</span> <span class="o">*</span> <span class="n">bs_y</span><span class="p">];</span>
    <span class="n">ScopeDeleter</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">del0</span><span class="p">(</span><span class="n">ip_block</span><span class="p">);</span>

    <span class="kt">float</span> <span class="o">*</span><span class="n">x_norms</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">,</span> <span class="o">*</span><span class="n">y_norms</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">ScopeDeleter</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">del1</span><span class="p">,</span> <span class="n">del2</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">compute_l2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">x_norms</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">float</span><span class="p">[</span><span class="n">nx</span><span class="p">];</span>
        <span class="n">del1</span><span class="p">.</span><span class="n">set</span> <span class="p">(</span><span class="n">x_norms</span><span class="p">);</span>
        <span class="n">fvec_norms_L2sqr</span> <span class="p">(</span><span class="n">x_norms</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">nx</span><span class="p">);</span>

        <span class="n">y_norms</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">float</span><span class="p">[</span><span class="n">ny</span><span class="p">];</span>
        <span class="n">del2</span><span class="p">.</span><span class="n">set</span> <span class="p">(</span><span class="n">y_norms</span><span class="p">);</span>
        <span class="n">fvec_norms_L2sqr</span> <span class="p">(</span><span class="n">y_norms</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">ny</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">vector</span> <span class="o">&lt;</span><span class="n">RangeSearchPartialResult</span> <span class="o">*&gt;</span> <span class="n">partial_results</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">j0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j0</span> <span class="o">&lt;</span> <span class="n">ny</span><span class="p">;</span> <span class="n">j0</span> <span class="o">+=</span> <span class="n">bs_y</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">size_t</span> <span class="n">j1</span> <span class="o">=</span> <span class="n">j0</span> <span class="o">+</span> <span class="n">bs_y</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">j1</span> <span class="o">&gt;</span> <span class="n">ny</span><span class="p">)</span> <span class="n">j1</span> <span class="o">=</span> <span class="n">ny</span><span class="p">;</span>
        <span class="n">RangeSearchPartialResult</span> <span class="o">*</span> <span class="n">pres</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RangeSearchPartialResult</span> <span class="p">(</span><span class="n">result</span><span class="p">);</span>
        <span class="n">partial_results</span><span class="p">.</span><span class="n">push_back</span> <span class="p">(</span><span class="n">pres</span><span class="p">);</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i0</span> <span class="o">&lt;</span> <span class="n">nx</span><span class="p">;</span> <span class="n">i0</span> <span class="o">+=</span> <span class="n">bs_x</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">size_t</span> <span class="n">i1</span> <span class="o">=</span> <span class="n">i0</span> <span class="o">+</span> <span class="n">bs_x</span><span class="p">;</span>
            <span class="k">if</span><span class="p">(</span><span class="n">i1</span> <span class="o">&gt;</span> <span class="n">nx</span><span class="p">)</span> <span class="n">i1</span> <span class="o">=</span> <span class="n">nx</span><span class="p">;</span>

            <span class="cm">/* compute the actual dot products */</span>
            <span class="p">{</span>
                <span class="kt">float</span> <span class="n">one</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">zero</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="n">FINTEGER</span> <span class="n">nyi</span> <span class="o">=</span> <span class="n">j1</span> <span class="o">-</span> <span class="n">j0</span><span class="p">,</span> <span class="n">nxi</span> <span class="o">=</span> <span class="n">i1</span> <span class="o">-</span> <span class="n">i0</span><span class="p">,</span> <span class="n">di</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>
                <span class="n">sgemm_</span> <span class="p">(</span><span class="s">&quot;Transpose&quot;</span><span class="p">,</span> <span class="s">&quot;Not transpose&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nyi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nxi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">di</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">one</span><span class="p">,</span>
                        <span class="n">y</span> <span class="o">+</span> <span class="n">j0</span> <span class="o">*</span> <span class="n">d</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">di</span><span class="p">,</span>
                        <span class="n">x</span> <span class="o">+</span> <span class="n">i0</span> <span class="o">*</span> <span class="n">d</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">di</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zero</span><span class="p">,</span>
                        <span class="n">ip_block</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nyi</span><span class="p">);</span>
            <span class="p">}</span>


            <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">i0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">i1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">ip_line</span> <span class="o">=</span> <span class="n">ip_block</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">i0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">j1</span> <span class="o">-</span> <span class="n">j0</span><span class="p">);</span>

                <span class="n">RangeQueryResult</span> <span class="o">&amp;</span> <span class="n">qres</span> <span class="o">=</span> <span class="n">pres</span><span class="o">-&gt;</span><span class="n">new_result</span> <span class="p">(</span><span class="n">i</span><span class="p">);</span>

                <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="n">j0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">j1</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                    <span class="kt">float</span> <span class="n">ip</span> <span class="o">=</span> <span class="o">*</span><span class="n">ip_line</span><span class="o">++</span><span class="p">;</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">compute_l2</span><span class="p">)</span> <span class="p">{</span>
                        <span class="kt">float</span> <span class="n">dis</span> <span class="o">=</span>  <span class="n">x_norms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">y_norms</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">ip</span><span class="p">;</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">dis</span> <span class="o">&lt;</span> <span class="n">radius</span><span class="p">)</span> <span class="p">{</span>
                            <span class="n">qres</span><span class="p">.</span><span class="n">add</span> <span class="p">(</span><span class="n">dis</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
                        <span class="p">}</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">ip</span> <span class="o">&gt;</span> <span class="n">radius</span><span class="p">)</span> <span class="p">{</span>
                            <span class="n">qres</span><span class="p">.</span><span class="n">add</span> <span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
                        <span class="p">}</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">InterruptCallback</span><span class="o">::</span><span class="n">check</span> <span class="p">();</span>
    <span class="p">}</span>

    <span class="n">RangeSearchPartialResult</span><span class="o">::</span><span class="n">merge</span> <span class="p">(</span><span class="n">partial_results</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">template</span> <span class="o">&lt;</span><span class="kt">bool</span> <span class="n">compute_l2</span><span class="o">&gt;</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">range_search_sse</span> <span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span>
                <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">y</span><span class="p">,</span>
                <span class="kt">size_t</span> <span class="n">d</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nx</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">ny</span><span class="p">,</span>
                <span class="kt">float</span> <span class="n">radius</span><span class="p">,</span>
                <span class="n">RangeSearchResult</span> <span class="o">*</span><span class="n">res</span><span class="p">)</span>
<span class="p">{</span>

<span class="cp">#pragma omp parallel</span>
    <span class="p">{</span>
        <span class="n">RangeSearchPartialResult</span> <span class="n">pres</span> <span class="p">(</span><span class="n">res</span><span class="p">);</span>

<span class="cp">#pragma omp for</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nx</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">x_</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">d</span><span class="p">;</span>
            <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">y_</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>
            <span class="kt">size_t</span> <span class="n">j</span><span class="p">;</span>

            <span class="n">RangeQueryResult</span> <span class="o">&amp;</span> <span class="n">qres</span> <span class="o">=</span> <span class="n">pres</span><span class="p">.</span><span class="n">new_result</span> <span class="p">(</span><span class="n">i</span><span class="p">);</span>

            <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">ny</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">compute_l2</span><span class="p">)</span> <span class="p">{</span>
                    <span class="kt">float</span> <span class="n">disij</span> <span class="o">=</span> <span class="n">fvec_L2sqr</span> <span class="p">(</span><span class="n">x_</span><span class="p">,</span> <span class="n">y_</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">disij</span> <span class="o">&lt;</span> <span class="n">radius</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">qres</span><span class="p">.</span><span class="n">add</span> <span class="p">(</span><span class="n">disij</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
                    <span class="p">}</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="kt">float</span> <span class="n">ip</span> <span class="o">=</span> <span class="n">fvec_inner_product</span> <span class="p">(</span><span class="n">x_</span><span class="p">,</span> <span class="n">y_</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">ip</span> <span class="o">&gt;</span> <span class="n">radius</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">qres</span><span class="p">.</span><span class="n">add</span> <span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
                    <span class="p">}</span>
                <span class="p">}</span>
                <span class="n">y_</span> <span class="o">+=</span> <span class="n">d</span><span class="p">;</span>
            <span class="p">}</span>

        <span class="p">}</span>
        <span class="n">pres</span><span class="p">.</span><span class="n">finalize</span> <span class="p">();</span>
    <span class="p">}</span>

    <span class="c1">// check just at the end because the use case is typically just</span>
    <span class="c1">// when the nb of queries is low.</span>
    <span class="n">InterruptCallback</span><span class="o">::</span><span class="n">check</span><span class="p">();</span>
<span class="p">}</span>





<span class="kt">void</span> <span class="n">range_search_L2sqr</span> <span class="p">(</span>
        <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">y</span><span class="p">,</span>
        <span class="kt">size_t</span> <span class="n">d</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nx</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">ny</span><span class="p">,</span>
        <span class="kt">float</span> <span class="n">radius</span><span class="p">,</span>
        <span class="n">RangeSearchResult</span> <span class="o">*</span><span class="n">res</span><span class="p">)</span>
<span class="p">{</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">nx</span> <span class="o">&lt;</span> <span class="n">distance_compute_blas_threshold</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">range_search_sse</span><span class="o">&lt;</span><span class="nb">true</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">range_search_blas</span><span class="o">&lt;</span><span class="nb">true</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">range_search_inner_product</span> <span class="p">(</span>
        <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">y</span><span class="p">,</span>
        <span class="kt">size_t</span> <span class="n">d</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nx</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">ny</span><span class="p">,</span>
        <span class="kt">float</span> <span class="n">radius</span><span class="p">,</span>
        <span class="n">RangeSearchResult</span> <span class="o">*</span><span class="n">res</span><span class="p">)</span>
<span class="p">{</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">nx</span> <span class="o">&lt;</span> <span class="n">distance_compute_blas_threshold</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">range_search_sse</span><span class="o">&lt;</span><span class="nb">false</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">range_search_blas</span><span class="o">&lt;</span><span class="nb">false</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="n">pairwise_L2sqr</span> <span class="p">(</span><span class="kt">int64_t</span> <span class="n">d</span><span class="p">,</span>
                     <span class="kt">int64_t</span> <span class="n">nq</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">xq</span><span class="p">,</span>
                     <span class="kt">int64_t</span> <span class="n">nb</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">xb</span><span class="p">,</span>
                     <span class="kt">float</span> <span class="o">*</span><span class="n">dis</span><span class="p">,</span>
                     <span class="kt">int64_t</span> <span class="n">ldq</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">ldb</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">ldd</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nq</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">nb</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ldq</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="n">ldq</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ldb</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="n">ldb</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ldd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="n">ldd</span> <span class="o">=</span> <span class="n">nb</span><span class="p">;</span>

    <span class="c1">// store in beginning of distance matrix to avoid malloc</span>
    <span class="kt">float</span> <span class="o">*</span><span class="n">b_norms</span> <span class="o">=</span> <span class="n">dis</span><span class="p">;</span>

<span class="cp">#pragma omp parallel for</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int64_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nb</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">b_norms</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">fvec_norm_L2sqr</span> <span class="p">(</span><span class="n">xb</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">ldb</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>

<span class="cp">#pragma omp parallel for</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int64_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nq</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">float</span> <span class="n">q_norm</span> <span class="o">=</span> <span class="n">fvec_norm_L2sqr</span> <span class="p">(</span><span class="n">xq</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">ldq</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int64_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nb</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
            <span class="n">dis</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">ldd</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">q_norm</span> <span class="o">+</span> <span class="n">b_norms</span> <span class="p">[</span><span class="n">j</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="p">{</span>
        <span class="kt">float</span> <span class="n">q_norm</span> <span class="o">=</span> <span class="n">fvec_norm_L2sqr</span> <span class="p">(</span><span class="n">xq</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int64_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nb</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
            <span class="n">dis</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">q_norm</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="p">{</span>
        <span class="n">FINTEGER</span> <span class="n">nbi</span> <span class="o">=</span> <span class="n">nb</span><span class="p">,</span> <span class="n">nqi</span> <span class="o">=</span> <span class="n">nq</span><span class="p">,</span> <span class="n">di</span> <span class="o">=</span> <span class="n">d</span><span class="p">,</span> <span class="n">ldqi</span> <span class="o">=</span> <span class="n">ldq</span><span class="p">,</span> <span class="n">ldbi</span> <span class="o">=</span> <span class="n">ldb</span><span class="p">,</span> <span class="n">lddi</span> <span class="o">=</span> <span class="n">ldd</span><span class="p">;</span>
        <span class="kt">float</span> <span class="n">one</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">minus_2</span> <span class="o">=</span> <span class="o">-</span><span class="mf">2.0</span><span class="p">;</span>

        <span class="n">sgemm_</span> <span class="p">(</span><span class="s">&quot;Transposed&quot;</span><span class="p">,</span> <span class="s">&quot;Not transposed&quot;</span><span class="p">,</span>
                <span class="o">&amp;</span><span class="n">nbi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nqi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">di</span><span class="p">,</span>
                <span class="o">&amp;</span><span class="n">minus_2</span><span class="p">,</span>
                <span class="n">xb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ldbi</span><span class="p">,</span>
                <span class="n">xq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ldqi</span><span class="p">,</span>
                <span class="o">&amp;</span><span class="n">one</span><span class="p">,</span> <span class="n">dis</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lddi</span><span class="p">);</span>
    <span class="p">}</span>

<span class="p">}</span>


<span class="p">}</span> <span class="c1">// namespace faiss</span>
</pre></div>

<h4 id="414-hamminghhamming-inlhhammingcpp">4.1.4 hamming.h,hamming-inl.h和hamming.cpp文件<a class="headerlink" href="#414-hamminghhamming-inlhhammingcpp" title="Permanent link">&para;</a></h4>
<ul>
<li>
<p><strong><code>hamming.h</code>文件</strong></p>
</li>
<li>
<p><strong><code>hamming-inl.h</code>文件</strong></p>
</li>
</ul>
<h3 id="42-impl">4.2 <code>impl</code>目录<a class="headerlink" href="#42-impl" title="Permanent link">&para;</a></h3>
<h4 id="421-faissexceptionhfaissexceptioncpp">4.2.1 <code>FaissException.h</code>和<code>FaissException.cpp</code>文件<a class="headerlink" href="#421-faissexceptionhfaissexceptioncpp" title="Permanent link">&para;</a></h4>
<ul>
<li><strong><code>FaissException.h</code>文件</strong></li>
</ul>
<div class="highlight"><pre><span></span><span class="cp">#ifndef FAISS_EXCEPTION_INCLUDED</span>
<span class="cp">#define FAISS_EXCEPTION_INCLUDED</span>

<span class="cp">#include</span> <span class="cpf">&lt;exception&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">faiss</span> <span class="p">{</span>

    <span class="c1">/// Base class for Faiss exceptions</span>
    <span class="k">class</span> <span class="nc">FaissException</span> <span class="o">:</span> <span class="k">public</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span> <span class="p">{</span>
        <span class="k">public</span><span class="o">:</span>
            <span class="k">explicit</span> <span class="n">FaissException</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">);</span>
            <span class="n">FaissException</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">,</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">funcName</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">file</span><span class="p">,</span><span class="kt">int</span> <span class="n">line</span><span class="p">);</span>

            <span class="c1">/// from std::exception</span>
            <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="nf">what</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="k">override</span><span class="p">;</span>
            <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">msg</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="c1">/// Handle multiple exceptions from worker threads, throwing an appropriate</span>
    <span class="c1">/// exception that aggregates the information</span>
    <span class="c1">/// The pair int is the thread that generated the exception</span>
    <span class="kt">void</span> <span class="nf">handleExceptions</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">exception_ptr</span><span class="o">&gt;&gt;&amp;</span> <span class="n">exceptions</span><span class="p">);</span>

    <span class="c1">/// bare-bones unique_ptr this one deletes with delete []</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="n">ScopeDeleter</span> <span class="p">{</span>
        <span class="k">const</span> <span class="n">T</span> <span class="o">*</span> <span class="n">ptr</span><span class="p">;</span>
        <span class="k">explicit</span> <span class="nf">ScopeDeleter</span> <span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">)</span><span class="o">:</span> <span class="n">ptr</span> <span class="p">(</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{}</span>
        <span class="kt">void</span> <span class="nf">release</span> <span class="p">()</span> <span class="p">{</span><span class="n">ptr</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span> <span class="p">}</span>
        <span class="kt">void</span> <span class="nf">set</span> <span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="o">*</span> <span class="n">ptr_in</span><span class="p">)</span> <span class="p">{</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr_in</span><span class="p">;</span> <span class="p">}</span>
        <span class="kt">void</span> <span class="nf">swap</span> <span class="p">(</span><span class="n">ScopeDeleter</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">swap</span> <span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">other</span><span class="p">.</span><span class="n">ptr</span><span class="p">);</span> <span class="p">}</span>
        <span class="o">~</span><span class="n">ScopeDeleter</span> <span class="p">()</span> <span class="p">{</span> <span class="k">delete</span> <span class="p">[]</span> <span class="n">ptr</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">};</span>

    <span class="c1">/// same but deletes with the simple delete (least common case)</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="n">ScopeDeleter1</span> <span class="p">{</span>
        <span class="k">const</span> <span class="n">T</span> <span class="o">*</span> <span class="n">ptr</span><span class="p">;</span>
        <span class="k">explicit</span> <span class="nf">ScopeDeleter1</span> <span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">)</span><span class="o">:</span> <span class="n">ptr</span> <span class="p">(</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{}</span>
        <span class="kt">void</span> <span class="nf">release</span> <span class="p">()</span> <span class="p">{</span><span class="n">ptr</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span> <span class="p">}</span>
        <span class="kt">void</span> <span class="nf">set</span> <span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="o">*</span> <span class="n">ptr_in</span><span class="p">)</span> <span class="p">{</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr_in</span><span class="p">;</span> <span class="p">}</span>
        <span class="kt">void</span> <span class="nf">swap</span> <span class="p">(</span><span class="n">ScopeDeleter1</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">swap</span> <span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">other</span><span class="p">.</span><span class="n">ptr</span><span class="p">);</span> <span class="p">}</span>
        <span class="o">~</span><span class="n">ScopeDeleter1</span> <span class="p">()</span> <span class="p">{</span> <span class="k">delete</span> <span class="n">ptr</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>
<span class="cp">#endif</span>
</pre></div>

<ul>
<li><strong><code>FaissException.cpp</code>文件</strong></li>
</ul>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;faiss/impl/FaissException.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;sstream&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">faiss</span> <span class="p">{</span>
    <span class="n">FaissException</span><span class="o">::</span><span class="n">FaissException</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">)</span> <span class="o">:</span> <span class="n">msg</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
    <span class="n">FaissException</span><span class="o">::</span><span class="n">FaissException</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">,</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">funcName</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">file</span><span class="p">,</span> <span class="kt">int</span> <span class="n">line</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="k">nullptr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Error in %s at %s:%d: %s&quot;</span><span class="p">,</span><span class="n">funcName</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">m</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>
        <span class="n">msg</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">snprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">msg</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="s">&quot;Error in %s at %s:%d: %s&quot;</span><span class="p">,</span> <span class="n">funcName</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">m</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">FaissException</span><span class="o">::</span><span class="n">what</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">msg</span><span class="p">.</span><span class="n">c_str</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">handleExceptions</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">exception_ptr</span><span class="o">&gt;&gt;&amp;</span> <span class="n">exceptions</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">exceptions</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// throw the single received exception directly</span>
            <span class="n">std</span><span class="o">::</span><span class="n">rethrow_exception</span><span class="p">(</span><span class="n">exceptions</span><span class="p">.</span><span class="n">front</span><span class="p">().</span><span class="n">second</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">exceptions</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// multiple exceptions; aggregate them and return a single exception</span>
            <span class="n">std</span><span class="o">::</span><span class="n">stringstream</span> <span class="n">ss</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">p</span> <span class="p">:</span> <span class="n">exceptions</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">try</span> <span class="p">{</span>
                    <span class="n">std</span><span class="o">::</span><span class="n">rethrow_exception</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="p">);</span>
                <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span> <span class="n">ex</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">ex</span><span class="p">.</span><span class="n">what</span><span class="p">())</span> <span class="p">{</span>
                        <span class="c1">// exception message available</span>
                        <span class="n">ss</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Exception thrown from index &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">ex</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="c1">// No message available</span>
                        <span class="n">ss</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Unknown exception thrown from index &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span> <span class="k">catch</span> <span class="p">(...)</span> <span class="p">{</span>
                    <span class="n">ss</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Unknown exception thrown from index &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">throw</span> <span class="n">FaissException</span><span class="p">(</span><span class="n">ss</span><span class="p">.</span><span class="n">str</span><span class="p">());</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<h4 id="42-faissasserth">4.2.* <code>FaissAssert.h</code>文件<a class="headerlink" href="#42-faissasserth" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><span class="cp">#ifndef FAISS_ASSERT_INCLUDED</span>
<span class="cp">#define FAISS_ASSERT_INCLUDED</span>

<span class="cp">#include</span> <span class="cpf">&lt;faiss/impl/FaissException.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>

<span class="c1">/// Assertions</span>
<span class="cp">#define FAISS_ASSERT(X)                                                 \</span>
<span class="cp">  do {                                                                  \</span>
<span class="cp">    if (! (X)) {                                                        \</span>
<span class="cp">      fprintf(stderr, &quot;Faiss assertion &#39;%s&#39; failed in %s &quot;              \</span>
<span class="cp">               &quot;at %s:%d\n&quot;,                                            \</span>
<span class="cp">               #X, __PRETTY_FUNCTION__, __FILE__, __LINE__);            \</span>
<span class="cp">      abort();                                                          \</span>
<span class="cp">    }                                                                   \</span>
<span class="cp">  } while (false)</span>

<span class="cp">#define FAISS_ASSERT_MSG(X, MSG)                                        \</span>
<span class="cp">  do {                                                                  \</span>
<span class="cp">    if (! (X)) {                                                        \</span>
<span class="cp">      fprintf(stderr, &quot;Faiss assertion &#39;%s&#39; failed in %s &quot;              \</span>
<span class="cp">               &quot;at %s:%d; details: &quot; MSG &quot;\n&quot;,                          \</span>
<span class="cp">               #X, __PRETTY_FUNCTION__, __FILE__, __LINE__);            \</span>
<span class="cp">      abort();                                                          \</span>
<span class="cp">    }                                                                   \</span>
<span class="cp">  } while (false)</span>

<span class="cp">#define FAISS_ASSERT_FMT(X, FMT, ...)                                   \</span>
<span class="cp">  do {                                                                  \</span>
<span class="cp">    if (! (X)) {                                                        \</span>
<span class="cp">      fprintf(stderr, &quot;Faiss assertion &#39;%s&#39; failed in %s &quot;              \</span>
<span class="cp">               &quot;at %s:%d; details: &quot; FMT &quot;\n&quot;,                          \</span>
<span class="cp">               #X, __PRETTY_FUNCTION__, __FILE__, __LINE__, __VA_ARGS__); \</span>
<span class="cp">      abort();                                                          \</span>
<span class="cp">    }                                                                   \</span>
<span class="cp">  } while (false)</span>

<span class="c1">///</span>
<span class="c1">/// Exceptions for returning user errors</span>
<span class="c1">///</span>

<span class="cp">#define FAISS_THROW_MSG(MSG)                                            \</span>
<span class="cp">  do {                                                                  \</span>
<span class="cp">    throw faiss::FaissException(MSG, __PRETTY_FUNCTION__, __FILE__, __LINE__); \</span>
<span class="cp">  } while (false)</span>

<span class="cp">#define FAISS_THROW_FMT(FMT, ...)                                       \</span>
<span class="cp">  do {                                                                  \</span>
<span class="cp">    std::string __s;                                                    \</span>
<span class="cp">    int __size = snprintf(nullptr, 0, FMT, __VA_ARGS__);                \</span>
<span class="cp">    __s.resize(__size + 1);                                             \</span>
<span class="cp">    snprintf(&amp;__s[0], __s.size(), FMT, __VA_ARGS__);                    \</span>
<span class="cp">    throw faiss::FaissException(__s, __PRETTY_FUNCTION__, __FILE__, __LINE__); \</span>
<span class="cp">  } while (false)</span>

<span class="c1">///</span>
<span class="c1">/// Exceptions thrown upon a conditional failure</span>

<span class="cp">#define FAISS_THROW_IF_NOT(X)                           \</span>
<span class="cp">  do {                                                  \</span>
<span class="cp">    if (!(X)) {                                         \</span>
<span class="cp">      FAISS_THROW_FMT(&quot;Error: &#39;%s&#39; failed&quot;, #X);        \</span>
<span class="cp">    }                                                   \</span>
<span class="cp">  } while (false)</span>

<span class="cp">#define FAISS_THROW_IF_NOT_MSG(X, MSG)                  \</span>
<span class="cp">  do {                                                  \</span>
<span class="cp">    if (!(X)) {                                         \</span>
<span class="cp">      FAISS_THROW_FMT(&quot;Error: &#39;%s&#39; failed: &quot; MSG, #X);  \</span>
<span class="cp">    }                                                   \</span>
<span class="cp">  } while (false)</span>

<span class="cp">#define FAISS_THROW_IF_NOT_FMT(X, FMT, ...)                             \</span>
<span class="cp">  do {                                                                  \</span>
<span class="cp">    if (!(X)) {                                                         \</span>
<span class="cp">      FAISS_THROW_FMT(&quot;Error: &#39;%s&#39; failed: &quot; FMT, #X, __VA_ARGS__);     \</span>
<span class="cp">    }                                                                   \</span>
<span class="cp">  } while (false)</span>

<span class="cp">#endif</span>
</pre></div>

<h3 id="43-index">4.3 <code>Index</code>相关文件<a class="headerlink" href="#43-index" title="Permanent link">&para;</a></h3>
<h4 id="431-metrictypeh">4.3.1 <code>MetricType.h</code>文件<a class="headerlink" href="#431-metrictypeh" title="Permanent link">&para;</a></h4>
<ul>
<li><strong><code>MetricType.h</code>文件</strong></li>
</ul>
<div class="highlight"><pre><span></span><span class="cp">#ifndef FAISS_METRIC_TYPE_H</span>
<span class="cp">#define FAISS_METRIC_TYPE_H</span>

<span class="n">namespace</span> <span class="n">faiss</span> <span class="p">{</span>

    <span class="c1">/// The metric space for vector comparison for Faiss indices and algorithms.</span>
    <span class="c1">///</span>
    <span class="c1">/// Most algorithms support both inner product and L2, with the flat</span>
    <span class="c1">/// (brute-force) indices supporting additional metric types for vector</span>
    <span class="c1">/// comparison.</span>
    <span class="k">enum</span> <span class="n">MetricType</span> <span class="p">{</span>
        <span class="n">METRIC_INNER_PRODUCT</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>  <span class="c1">///&lt; maximum inner product search</span>
        <span class="n">METRIC_L2</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>             <span class="c1">///&lt; squared L2 search</span>
        <span class="n">METRIC_L1</span><span class="p">,</span>                 <span class="c1">///&lt; L1 (aka cityblock)</span>
        <span class="n">METRIC_Linf</span><span class="p">,</span>               <span class="c1">///&lt; infinity distance</span>
        <span class="n">METRIC_Lp</span><span class="p">,</span>                 <span class="c1">///&lt; L_p distance, p is given by a faiss::Index</span>
                               <span class="c1">/// metric_arg</span>

        <span class="c1">/// some additional metrics defined in scipy.spatial.distance</span>
        <span class="n">METRIC_Canberra</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
        <span class="n">METRIC_BrayCurtis</span><span class="p">,</span>
        <span class="n">METRIC_JensenShannon</span><span class="p">,</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="cp">#endif</span>
</pre></div>

<h4 id="432-vectortransformhvectortransformcpp">4.3.2 <code>VectorTransform.h</code>和<code>VectorTransform.cpp</code>文件<a class="headerlink" href="#432-vectortransformhvectortransformcpp" title="Permanent link">&para;</a></h4>
<ul>
<li>**<code>VectorTransform.h</code>文件</li>
</ul>
<div class="highlight"><pre><span></span>
</pre></div>

<h4 id="432-indexhindexcpp">4.3.2 <code>Index.h</code>和<code>Index.cpp</code>文件<a class="headerlink" href="#432-indexhindexcpp" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><span class="cp">#ifndef FAISS_INDEX_H</span>
<span class="cp">#define FAISS_INDEX_H</span>

<span class="cp">#include</span> <span class="cpf">&lt;faiss/MetricType.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;typeinfo&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;sstream&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&lt;faiss/impl/AuxIndexStructures.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;faiss/impl/FaissAssert.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;faiss/utils/distances.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cstring&gt;</span><span class="cp"></span>

<span class="cp">#define FAISS_VERSION_MAJOR 1</span>
<span class="cp">#define FAISS_VERSION_MINOR 6</span>
<span class="cp">#define FAISS_VERSION_PATCH 3</span>

<span class="cm">/**</span>
<span class="cm"> * @namespace faiss</span>
<span class="cm"> *</span>
<span class="cm"> * Throughout the library, vectors are provided as float * pointers.</span>
<span class="cm"> * Most algorithms can be optimized when several vectors are processed</span>
<span class="cm"> * (added/searched) together in a batch. In this case, they are passed</span>
<span class="cm"> * in as a matrix. When n vectors of size d are provided as float * x,</span>
<span class="cm"> * component j of vector i is</span>
<span class="cm"> *</span>
<span class="cm"> *   x[ i * d + j ]</span>
<span class="cm"> *</span>
<span class="cm"> * where 0 &lt;= i &lt; n and 0 &lt;= j &lt; d. In other words, matrices are</span>
<span class="cm"> * always compact. When specifying the size of the matrix, we call it</span>
<span class="cm"> * an n*d matrix, which implies a row-major storage.</span>
<span class="cm"> */</span>


<span class="k">namespace</span> <span class="n">faiss</span> <span class="p">{</span>

    <span class="c1">/// Forward declarations see AuxIndexStructures.h</span>
    <span class="k">struct</span> <span class="n">IDSelector</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">RangeSearchResult</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">DistanceComputer</span><span class="p">;</span>

    <span class="cm">/** Abstract structure for an index, supports adding vectors and searching them.</span>
<span class="cm">     *</span>
<span class="cm">     * All vectors provided at add or search time are 32-bit float arrays,</span>
<span class="cm">     * although the internal representation may vary.</span>
<span class="cm">     */</span>
    <span class="k">struct</span> <span class="n">Index</span> <span class="p">{</span>
        <span class="k">using</span> <span class="n">idx_t</span> <span class="o">=</span> <span class="kt">int64_t</span><span class="p">;</span>  <span class="c1">///&lt; all indices are this type</span>
        <span class="k">using</span> <span class="n">component_t</span> <span class="o">=</span> <span class="kt">float</span><span class="p">;</span>
        <span class="k">using</span> <span class="n">distance_t</span> <span class="o">=</span> <span class="kt">float</span><span class="p">;</span>

        <span class="kt">int</span> <span class="n">d</span><span class="p">;</span>                 <span class="c1">///&lt; vector dimension</span>
        <span class="n">idx_t</span> <span class="n">ntotal</span><span class="p">;</span>          <span class="c1">///&lt; total nb of indexed vectors</span>
        <span class="kt">bool</span> <span class="n">verbose</span><span class="p">;</span>          <span class="c1">///&lt; verbosity level</span>

        <span class="c1">/// set if the Index does not require training, or if training is done already</span>
        <span class="kt">bool</span> <span class="n">is_trained</span><span class="p">;</span>

        <span class="c1">/// type of metric this index uses for search</span>
        <span class="n">MetricType</span> <span class="n">metric_type</span><span class="p">;</span>
        <span class="kt">float</span> <span class="n">metric_arg</span><span class="p">;</span>     <span class="c1">///&lt; argument of the metric type</span>

        <span class="k">explicit</span> <span class="nf">Index</span> <span class="p">(</span><span class="n">idx_t</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MetricType</span> <span class="n">metric</span> <span class="o">=</span> <span class="n">METRIC_L2</span><span class="p">)</span><span class="o">:</span> 
            <span class="n">d</span><span class="p">(</span><span class="n">d</span><span class="p">),</span> <span class="n">ntotal</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="n">verbose</span><span class="p">(</span><span class="nb">false</span><span class="p">),</span> <span class="n">is_trained</span><span class="p">(</span><span class="nb">true</span><span class="p">),</span> <span class="n">metric_type</span> <span class="p">(</span><span class="n">metric</span><span class="p">),</span><span class="n">metric_arg</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>

        <span class="k">virtual</span> <span class="o">~</span><span class="n">Index</span> <span class="p">(){</span> <span class="p">}</span>

        <span class="cm">/** Perform training on a representative set of vectors</span>
<span class="cm">         *</span>
<span class="cm">         * @param n      nb of training vectors</span>
<span class="cm">         * @param x      training vecors, size n * d</span>
<span class="cm">         */</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">train</span><span class="p">(</span><span class="n">idx_t</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span><span class="o">*</span> <span class="n">x</span><span class="p">){</span>
            <span class="c1">// does nothing by default</span>
        <span class="p">}</span>

        <span class="cm">/** Add n vectors of dimension d to the index.</span>
<span class="cm">         *</span>
<span class="cm">         * Vectors are implicitly assigned labels ntotal .. ntotal + n - 1</span>
<span class="cm">         * This function slices the input vectors in chuncks smaller than</span>
<span class="cm">         * blocksize_add and calls add_core.</span>
<span class="cm">         * @param x      input matrix, size n * d</span>
<span class="cm">         */</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">add</span> <span class="p">(</span><span class="n">idx_t</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="cm">/** Same as add, but stores xids instead of sequential ids.</span>
<span class="cm">         *</span>
<span class="cm">         * The default implementation fails with an assertion, as it is</span>
<span class="cm">         * not supported by all indexes.</span>
<span class="cm">         *</span>
<span class="cm">         * @param xids if non-null, ids to store for the vectors (size n)</span>
<span class="cm">         */</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">add_with_ids</span> <span class="p">(</span><span class="n">idx_t</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="n">idx_t</span> <span class="o">*</span><span class="n">xids</span><span class="p">){</span>
            <span class="n">FAISS_THROW_MSG</span> <span class="p">(</span><span class="s">&quot;add_with_ids not implemented for this type of index&quot;</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="cm">/** query n vectors of dimension d to the index.</span>
<span class="cm">         *</span>
<span class="cm">         * return at most k vectors. If there are not enough results for a</span>
<span class="cm">         * query, the result array is padded with -1s.</span>
<span class="cm">         *</span>
<span class="cm">         * @param x           input vectors to search, size n * d</span>
<span class="cm">         * @param labels      output labels of the NNs, size n*k</span>
<span class="cm">         * @param distances   output pairwise distances, size n*k</span>
<span class="cm">         */</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">search</span> <span class="p">(</span><span class="n">idx_t</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">idx_t</span> <span class="n">k</span><span class="p">,</span><span class="kt">float</span> <span class="o">*</span><span class="n">distances</span><span class="p">,</span> <span class="n">idx_t</span> <span class="o">*</span><span class="n">labels</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="cm">/** query n vectors of dimension d to the index.</span>
<span class="cm">         *</span>
<span class="cm">         * return all vectors with distance &lt; radius. Note that many</span>
<span class="cm">         * indexes do not implement the range_search (only the k-NN search</span>
<span class="cm">         * is mandatory).</span>
<span class="cm">         *</span>
<span class="cm">         * @param x           input vectors to search, size n * d</span>
<span class="cm">         * @param radius      search radius</span>
<span class="cm">         * @param result      result table</span>
<span class="cm">         */</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">range_search</span> <span class="p">(</span><span class="n">idx_t</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">radius</span><span class="p">,</span><span class="n">RangeSearchResult</span> <span class="o">*</span><span class="n">result</span><span class="p">)</span> <span class="k">const</span><span class="p">{</span>
            <span class="n">FAISS_THROW_MSG</span> <span class="p">(</span><span class="s">&quot;range search not implemented&quot;</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="cm">/** return the indexes of the k vectors closest to the query x.</span>
<span class="cm">         *</span>
<span class="cm">         * This function is identical as search but only return labels of neighbors.</span>
<span class="cm">         * @param x           input vectors to search, size n * d</span>
<span class="cm">         * @param labels      output labels of the NNs, size n*k</span>
<span class="cm">         */</span>
        <span class="kt">void</span> <span class="nf">assign</span> <span class="p">(</span><span class="n">idx_t</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="n">idx_t</span> <span class="o">*</span> <span class="n">labels</span><span class="p">,</span> <span class="n">idx_t</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">){</span>
            <span class="kt">float</span> <span class="o">*</span> <span class="n">distances</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">float</span><span class="p">[</span><span class="n">n</span> <span class="o">*</span> <span class="n">k</span><span class="p">];</span>
            <span class="n">ScopeDeleter</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">del</span><span class="p">(</span><span class="n">distances</span><span class="p">);</span>
            <span class="n">search</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">distances</span><span class="p">,</span> <span class="n">labels</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">/// removes all elements from the database.</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">reset</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="cm">/** removes IDs from the index. Not supported by all</span>
<span class="cm">         * indexes. Returns the number of elements removed.</span>
<span class="cm">         */</span>
        <span class="k">virtual</span> <span class="kt">size_t</span> <span class="nf">remove_ids</span> <span class="p">(</span><span class="k">const</span> <span class="n">IDSelector</span> <span class="o">&amp;</span> <span class="n">sel</span><span class="p">){</span>
            <span class="n">FAISS_THROW_MSG</span> <span class="p">(</span><span class="s">&quot;remove_ids not implemented for this type of index&quot;</span><span class="p">);</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/** Reconstruct a stored vector (or an approximation if lossy coding)</span>
<span class="cm">         *</span>
<span class="cm">         * this function may not be defined for some indexes</span>
<span class="cm">         * @param key         id of the vector to reconstruct</span>
<span class="cm">         * @param recons      reconstucted vector (size d)</span>
<span class="cm">         */</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">reconstruct</span> <span class="p">(</span><span class="n">idx_t</span> <span class="n">key</span><span class="p">,</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">recons</span><span class="p">)</span> <span class="k">const</span><span class="p">{</span>
            <span class="n">FAISS_THROW_MSG</span> <span class="p">(</span><span class="s">&quot;reconstruct not implemented for this type of index&quot;</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="cm">/** Reconstruct vectors i0 to i0 + ni - 1</span>
<span class="cm">         *</span>
<span class="cm">         * this function may not be defined for some indexes</span>
<span class="cm">         * @param recons      reconstucted vector (size ni * d)</span>
<span class="cm">         */</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">reconstruct_n</span> <span class="p">(</span><span class="n">idx_t</span> <span class="n">i0</span><span class="p">,</span> <span class="n">idx_t</span> <span class="n">ni</span><span class="p">,</span> <span class="kt">float</span> <span class="o">*</span><span class="n">recons</span><span class="p">)</span> <span class="k">const</span><span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">idx_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ni</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">reconstruct</span> <span class="p">(</span><span class="n">i0</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">recons</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">d</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="cm">/** Similar to search, but also reconstructs the stored vectors (or an</span>
<span class="cm">         * approximation in the case of lossy coding) for the search results.</span>
<span class="cm">         *</span>
<span class="cm">         * If there are not enough results for a query, the resulting arrays</span>
<span class="cm">         * is padded with -1s.</span>
<span class="cm">         *</span>
<span class="cm">         * @param recons      reconstructed vectors size (n, k, d)</span>
<span class="cm">         **/</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">search_and_reconstruct</span> <span class="p">(</span><span class="n">idx_t</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">idx_t</span> <span class="n">k</span><span class="p">,</span>
                <span class="kt">float</span> <span class="o">*</span><span class="n">distances</span><span class="p">,</span> <span class="n">idx_t</span> <span class="o">*</span><span class="n">labels</span><span class="p">,</span><span class="kt">float</span> <span class="o">*</span><span class="n">recons</span><span class="p">)</span> <span class="k">const</span><span class="p">{</span>
            <span class="n">search</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">distances</span><span class="p">,</span> <span class="n">labels</span><span class="p">);</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">idx_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">idx_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">idx_t</span> <span class="n">ij</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">k</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span>
                    <span class="n">idx_t</span> <span class="n">key</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="n">ij</span><span class="p">];</span>
                    <span class="kt">float</span><span class="o">*</span> <span class="n">reconstructed</span> <span class="o">=</span> <span class="n">recons</span> <span class="o">+</span> <span class="n">ij</span> <span class="o">*</span> <span class="n">d</span><span class="p">;</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                        <span class="c1">// Fill with NaNs</span>
                        <span class="n">memset</span><span class="p">(</span><span class="n">reconstructed</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">reconstructed</span><span class="p">)</span> <span class="o">*</span> <span class="n">d</span><span class="p">);</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="n">reconstruct</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">reconstructed</span><span class="p">);</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="cm">/** Computes a residual vector after indexing encoding.</span>
<span class="cm">         *</span>
<span class="cm">         * The residual vector is the difference between a vector and the</span>
<span class="cm">         * reconstruction that can be decoded from its representation in</span>
<span class="cm">         * the index. The residual can be used for multiple-stage indexing</span>
<span class="cm">         * methods, like IndexIVF&#39;s methods.</span>
<span class="cm">         *</span>
<span class="cm">         * @param x           input vector, size d</span>
<span class="cm">         * @param residual    output residual vector, size d</span>
<span class="cm">         * @param key         encoded index, as returned by search and assign</span>
<span class="cm">         */</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">compute_residual</span> <span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span><span class="kt">float</span> <span class="o">*</span> <span class="n">residual</span><span class="p">,</span> <span class="n">idx_t</span> <span class="n">key</span><span class="p">)</span> <span class="k">const</span><span class="p">{</span>
            <span class="n">reconstruct</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">residual</span><span class="p">);</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">residual</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">residual</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="cm">/** Computes a residual vector after indexing encoding (batch form).</span>
<span class="cm">         * Equivalent to calling compute_residual for each vector.</span>
<span class="cm">         *</span>
<span class="cm">         * The residual vector is the difference between a vector and the</span>
<span class="cm">         * reconstruction that can be decoded from its representation in</span>
<span class="cm">         * the index. The residual can be used for multiple-stage indexing</span>
<span class="cm">         * methods, like IndexIVF&#39;s methods.</span>
<span class="cm">         *</span>
<span class="cm">         * @param n           number of vectors</span>
<span class="cm">         * @param xs          input vectors, size (n x d)</span>
<span class="cm">         * @param residuals   output residual vectors, size (n x d)</span>
<span class="cm">         * @param keys        encoded index, as returned by search and assign</span>
<span class="cm">         */</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">compute_residual_n</span> <span class="p">(</span><span class="n">idx_t</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span><span class="o">*</span> <span class="n">xs</span><span class="p">,</span><span class="kt">float</span><span class="o">*</span> <span class="n">residuals</span><span class="p">,</span><span class="k">const</span> <span class="n">idx_t</span><span class="o">*</span> <span class="n">keys</span><span class="p">)</span> <span class="k">const</span><span class="p">{</span>
            <span class="cp">#pragma omp parallel for</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">idx_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">compute_residual</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xs</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">d</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">residuals</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">d</span><span class="p">],</span> <span class="n">keys</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
                <span class="p">}</span>
        <span class="p">}</span>

        <span class="cm">/** Get a DistanceComputer (defined in AuxIndexStructures) object</span>
<span class="cm">         * for this kind of index.</span>
<span class="cm">         *</span>
<span class="cm">         * DistanceComputer is implemented for indexes that support random</span>
<span class="cm">         * access of their vectors.</span>
<span class="cm">         */</span>
        <span class="k">virtual</span> <span class="n">DistanceComputer</span> <span class="o">*</span> <span class="nf">get_distance_computer</span><span class="p">()</span> <span class="k">const</span><span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">metric_type</span> <span class="o">==</span> <span class="n">METRIC_L2</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="k">new</span> <span class="n">GenericDistanceComputer</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">FAISS_THROW_MSG</span> <span class="p">(</span><span class="s">&quot;get_distance_computer() not implemented&quot;</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>


        <span class="cm">/* The standalone codec interface */</span>

        <span class="cm">/** size of the produced codes in bytes */</span>
        <span class="k">virtual</span> <span class="kt">size_t</span> <span class="nf">sa_code_size</span> <span class="p">()</span> <span class="k">const</span><span class="p">{</span>
            <span class="n">FAISS_THROW_MSG</span> <span class="p">(</span><span class="s">&quot;standalone codec not implemented for this type of index&quot;</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="cm">/** encode a set of vectors</span>
<span class="cm">         *</span>
<span class="cm">         * @param n       number of vectors</span>
<span class="cm">         * @param x       input vectors, size n * d</span>
<span class="cm">         * @param bytes   output encoded vectors, size n * sa_code_size()</span>
<span class="cm">         */</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">sa_encode</span> <span class="p">(</span><span class="n">idx_t</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">bytes</span><span class="p">)</span> <span class="k">const</span><span class="p">{</span>
            <span class="n">FAISS_THROW_MSG</span> <span class="p">(</span><span class="s">&quot;standalone codec not implemented for this type of index&quot;</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="cm">/** encode a set of vectors</span>
<span class="cm">         *</span>
<span class="cm">         * @param n       number of vectors</span>
<span class="cm">         * @param bytes   input encoded vectors, size n * sa_code_size()</span>
<span class="cm">         * @param x       output vectors, size n * d</span>
<span class="cm">         */</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">sa_decode</span> <span class="p">(</span><span class="n">idx_t</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">bytes</span><span class="p">,</span><span class="kt">float</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="k">const</span><span class="p">{</span>
            <span class="n">FAISS_THROW_MSG</span> <span class="p">(</span><span class="s">&quot;standalone codec not implemented for this type of index&quot;</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="k">namespace</span> <span class="p">{</span>

        <span class="c1">// storage that explicitly reconstructs vectors before computing distances</span>
        <span class="k">struct</span> <span class="nl">GenericDistanceComputer</span> <span class="p">:</span> <span class="n">DistanceComputer</span> <span class="p">{</span>
            <span class="kt">size_t</span> <span class="n">d</span><span class="p">;</span>
            <span class="k">const</span> <span class="n">Index</span><span class="o">&amp;</span> <span class="n">storage</span><span class="p">;</span>
            <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">buf</span><span class="p">;</span>
            <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>

            <span class="k">explicit</span> <span class="nf">GenericDistanceComputer</span><span class="p">(</span><span class="k">const</span> <span class="n">Index</span><span class="o">&amp;</span> <span class="n">storage</span><span class="p">)</span> <span class="o">:</span> <span class="n">storage</span><span class="p">(</span><span class="n">storage</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">storage</span><span class="p">.</span><span class="n">d</span><span class="p">;</span>
                <span class="n">buf</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">d</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="kt">float</span> <span class="nf">operator</span> <span class="p">()</span> <span class="p">(</span><span class="n">idx_t</span> <span class="n">i</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
                <span class="n">storage</span><span class="p">.</span><span class="n">reconstruct</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">buf</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>
                <span class="k">return</span> <span class="n">fvec_L2sqr</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">buf</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">d</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="kt">float</span> <span class="nf">symmetric_dis</span><span class="p">(</span><span class="n">idx_t</span> <span class="n">i</span><span class="p">,</span> <span class="n">idx_t</span> <span class="n">j</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
                <span class="n">storage</span><span class="p">.</span><span class="n">reconstruct</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">buf</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>
                <span class="n">storage</span><span class="p">.</span><span class="n">reconstruct</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">buf</span><span class="p">.</span><span class="n">data</span><span class="p">()</span> <span class="o">+</span> <span class="n">d</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">fvec_L2sqr</span><span class="p">(</span><span class="n">buf</span><span class="p">.</span><span class="n">data</span><span class="p">()</span> <span class="o">+</span> <span class="n">d</span><span class="p">,</span> <span class="n">buf</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">d</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="kt">void</span> <span class="nf">set_query</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
                <span class="n">q</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">};</span>
    <span class="p">}</span>  <span class="c1">// namespace</span>
<span class="p">}</span>
<span class="cp">#endif</span>
</pre></div>

<h4 id="433-indexflathindexflatcpp">4.3.3 <code>IndexFlat.h</code>和<code>IndexFlat.cpp</code>文件<a class="headerlink" href="#433-indexflathindexflatcpp" title="Permanent link">&para;</a></h4>
<ul>
<li>
<p>**<code>IndexFlat.h</code>文件</p>
</li>
<li>
<p><strong><code>IndexFlat.cpp</code>文件</strong></p>
</li>
</ul>
<div class="highlight"><pre><span></span><span class="cp">#ifndef INDEX_FLAT_H</span>
<span class="cp">#define INDEX_FLAT_H</span>

<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;faiss/Index.h&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">faiss</span> <span class="p">{</span>

    <span class="c1">/// Index that stores the full vectors and performs exhaustive search </span>
    <span class="k">struct</span> <span class="nl">IndexFlat</span><span class="p">:</span> <span class="n">Index</span> <span class="p">{</span>
        <span class="c1">/// database vectors, size ntotal * d</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">xb</span><span class="p">;</span>
        <span class="k">explicit</span> <span class="nf">IndexFlat</span> <span class="p">(</span><span class="n">idx_t</span> <span class="n">d</span><span class="p">,</span> <span class="n">MetricType</span> <span class="n">metric</span> <span class="o">=</span> <span class="n">METRIC_L2</span><span class="p">);</span>
        <span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="n">idx_t</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span><span class="o">*</span> <span class="n">x</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
        <span class="kt">void</span> <span class="nf">reset</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>
        <span class="kt">void</span> <span class="nf">search</span><span class="p">(</span><span class="n">idx_t</span> <span class="n">n</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">float</span><span class="o">*</span> <span class="n">x</span><span class="p">,</span><span class="n">idx_t</span> <span class="n">k</span><span class="p">,</span><span class="kt">float</span><span class="o">*</span> <span class="n">distances</span><span class="p">,</span><span class="n">idx_t</span><span class="o">*</span> <span class="n">labels</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
        <span class="kt">void</span> <span class="nf">range_search</span><span class="p">(</span><span class="n">idx_t</span> <span class="n">n</span><span class="p">,</span><span class="k">const</span> <span class="kt">float</span><span class="o">*</span> <span class="n">x</span><span class="p">,</span><span class="kt">float</span> <span class="n">radius</span><span class="p">,</span><span class="n">RangeSearchResult</span><span class="o">*</span> <span class="n">result</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>

    <span class="kt">void</span> <span class="nf">reconstruct</span><span class="p">(</span><span class="n">idx_t</span> <span class="n">key</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">recons</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>

    <span class="cm">/** compute distance with a subset of vectors</span>
<span class="cm">     *</span>
<span class="cm">     * @param x       query vectors, size n * d</span>
<span class="cm">     * @param labels  indices of the vectors that should be compared</span>
<span class="cm">     *                for each query vector, size n * k</span>
<span class="cm">     * @param distances</span>
<span class="cm">     *                corresponding output distances, size n * k</span>
<span class="cm">     */</span>
    <span class="kt">void</span> <span class="nf">compute_distance_subset</span> <span class="p">(</span>
            <span class="n">idx_t</span> <span class="n">n</span><span class="p">,</span>
            <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span>
            <span class="n">idx_t</span> <span class="n">k</span><span class="p">,</span>
            <span class="kt">float</span> <span class="o">*</span><span class="n">distances</span><span class="p">,</span>
            <span class="k">const</span> <span class="n">idx_t</span> <span class="o">*</span><span class="n">labels</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="cm">/** remove some ids. NB that Because of the structure of the</span>
<span class="cm">     * indexing structure, the semantics of this operation are</span>
<span class="cm">     * different from the usual ones: the new ids are shifted */</span>
    <span class="kt">size_t</span> <span class="nf">remove_ids</span><span class="p">(</span><span class="k">const</span> <span class="n">IDSelector</span><span class="o">&amp;</span> <span class="n">sel</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>

    <span class="n">IndexFlat</span> <span class="p">()</span> <span class="p">{}</span>

    <span class="n">DistanceComputer</span> <span class="o">*</span> <span class="n">get_distance_computer</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>

    <span class="cm">/* The stanadlone codec interface (just memcopies in this case) */</span>
    <span class="kt">size_t</span> <span class="nf">sa_code_size</span> <span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>

    <span class="kt">void</span> <span class="nf">sa_encode</span> <span class="p">(</span><span class="n">idx_t</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span>
                          <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">bytes</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>

    <span class="kt">void</span> <span class="nf">sa_decode</span> <span class="p">(</span><span class="n">idx_t</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">bytes</span><span class="p">,</span>
                            <span class="kt">float</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>

<span class="p">};</span>



<span class="k">struct</span> <span class="nl">IndexFlatIP</span><span class="p">:</span><span class="n">IndexFlat</span> <span class="p">{</span>
    <span class="k">explicit</span> <span class="n">IndexFlatIP</span> <span class="p">(</span><span class="n">idx_t</span> <span class="n">d</span><span class="p">)</span><span class="o">:</span> <span class="n">IndexFlat</span> <span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">METRIC_INNER_PRODUCT</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">IndexFlatIP</span> <span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>


<span class="k">struct</span> <span class="nl">IndexFlatL2</span><span class="p">:</span><span class="n">IndexFlat</span> <span class="p">{</span>
    <span class="k">explicit</span> <span class="n">IndexFlatL2</span> <span class="p">(</span><span class="n">idx_t</span> <span class="n">d</span><span class="p">)</span><span class="o">:</span> <span class="n">IndexFlat</span> <span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">METRIC_L2</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">IndexFlatL2</span> <span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>


<span class="c1">// same as an IndexFlatL2 but a value is subtracted from each distance</span>
<span class="k">struct</span> <span class="nl">IndexFlatL2BaseShift</span><span class="p">:</span> <span class="n">IndexFlatL2</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">shift</span><span class="p">;</span>

    <span class="n">IndexFlatL2BaseShift</span> <span class="p">(</span><span class="n">idx_t</span> <span class="n">d</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nshift</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">shift</span><span class="p">);</span>

    <span class="kt">void</span> <span class="nf">search</span><span class="p">(</span>
        <span class="n">idx_t</span> <span class="n">n</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">float</span><span class="o">*</span> <span class="n">x</span><span class="p">,</span>
        <span class="n">idx_t</span> <span class="n">k</span><span class="p">,</span>
        <span class="kt">float</span><span class="o">*</span> <span class="n">distances</span><span class="p">,</span>
        <span class="n">idx_t</span><span class="o">*</span> <span class="n">labels</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/** Index that queries in a base_index (a fast one) and refines the</span>
<span class="cm"> *  results with an exact search, hopefully improving the results.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="nl">IndexRefineFlat</span><span class="p">:</span> <span class="n">Index</span> <span class="p">{</span>

    <span class="c1">/// storage for full vectors</span>
    <span class="n">IndexFlat</span> <span class="n">refine_index</span><span class="p">;</span>

    <span class="c1">/// faster index to pre-select the vectors that should be filtered</span>
    <span class="n">Index</span> <span class="o">*</span><span class="n">base_index</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">own_fields</span><span class="p">;</span>  <span class="c1">///&lt; should the base index be deallocated?</span>

    <span class="c1">/// factor between k requested in search and the k requested from</span>
    <span class="c1">/// the base_index (should be &gt;= 1)</span>
    <span class="kt">float</span> <span class="n">k_factor</span><span class="p">;</span>

    <span class="k">explicit</span> <span class="nf">IndexRefineFlat</span> <span class="p">(</span><span class="n">Index</span> <span class="o">*</span><span class="n">base_index</span><span class="p">);</span>

    <span class="n">IndexRefineFlat</span> <span class="p">();</span>

    <span class="kt">void</span> <span class="nf">train</span><span class="p">(</span><span class="n">idx_t</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span><span class="o">*</span> <span class="n">x</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>

    <span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="n">idx_t</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span><span class="o">*</span> <span class="n">x</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>

    <span class="kt">void</span> <span class="nf">reset</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>

    <span class="kt">void</span> <span class="nf">search</span><span class="p">(</span>
        <span class="n">idx_t</span> <span class="n">n</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">float</span><span class="o">*</span> <span class="n">x</span><span class="p">,</span>
        <span class="n">idx_t</span> <span class="n">k</span><span class="p">,</span>
        <span class="kt">float</span><span class="o">*</span> <span class="n">distances</span><span class="p">,</span>
        <span class="n">idx_t</span><span class="o">*</span> <span class="n">labels</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>

    <span class="o">~</span><span class="n">IndexRefineFlat</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>
<span class="p">};</span>


<span class="c1">/// optimized version for 1D &quot;vectors&quot;.</span>
<span class="k">struct</span> <span class="nl">IndexFlat1D</span><span class="p">:</span><span class="n">IndexFlatL2</span> <span class="p">{</span>
    <span class="kt">bool</span> <span class="n">continuous_update</span><span class="p">;</span> <span class="c1">///&lt; is the permutation updated continuously?</span>

    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">idx_t</span><span class="o">&gt;</span> <span class="n">perm</span><span class="p">;</span> <span class="c1">///&lt; sorted database indices</span>

    <span class="k">explicit</span> <span class="nf">IndexFlat1D</span> <span class="p">(</span><span class="kt">bool</span> <span class="n">continuous_update</span><span class="o">=</span><span class="nb">true</span><span class="p">);</span>

    <span class="c1">/// if not continuous_update, call this between the last add and</span>
    <span class="c1">/// the first search</span>
    <span class="kt">void</span> <span class="nf">update_permutation</span> <span class="p">();</span>

    <span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="n">idx_t</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span><span class="o">*</span> <span class="n">x</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>

    <span class="kt">void</span> <span class="nf">reset</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>

    <span class="c1">/// Warn: the distances returned are L1 not L2</span>
    <span class="kt">void</span> <span class="nf">search</span><span class="p">(</span>
        <span class="n">idx_t</span> <span class="n">n</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">float</span><span class="o">*</span> <span class="n">x</span><span class="p">,</span>
        <span class="n">idx_t</span> <span class="n">k</span><span class="p">,</span>
        <span class="kt">float</span><span class="o">*</span> <span class="n">distances</span><span class="p">,</span>
        <span class="n">idx_t</span><span class="o">*</span> <span class="n">labels</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
<span class="p">};</span>


<span class="p">}</span>

<span class="cp">#endif</span>
</pre></div>

<ul>
<li><strong><code>IndexFlat.cpp</code>文件</strong></li>
</ul>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;faiss/IndexFlat.h&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&lt;cstring&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;faiss/utils/distances.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;faiss/utils/extra_distances.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;faiss/utils/utils.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;faiss/utils/Heap.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;faiss/impl/FaissAssert.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;faiss/impl/AuxIndexStructures.h&gt;</span><span class="cp"></span>


<span class="k">namespace</span> <span class="n">faiss</span> <span class="p">{</span>
    <span class="n">IndexFlat</span><span class="o">::</span><span class="n">IndexFlat</span> <span class="p">(</span><span class="n">idx_t</span> <span class="n">d</span><span class="p">,</span> <span class="n">MetricType</span> <span class="n">metric</span><span class="p">)</span><span class="o">:</span><span class="n">Index</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">metric</span><span class="p">)</span> <span class="p">{}</span>



<span class="kt">void</span> <span class="n">IndexFlat</span><span class="o">::</span><span class="n">add</span> <span class="p">(</span><span class="n">idx_t</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">xb</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">xb</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">n</span> <span class="o">*</span> <span class="n">d</span><span class="p">);</span>
    <span class="n">ntotal</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="n">IndexFlat</span><span class="o">::</span><span class="n">reset</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">xb</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
    <span class="n">ntotal</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="n">IndexFlat</span><span class="o">::</span><span class="n">search</span> <span class="p">(</span><span class="n">idx_t</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">idx_t</span> <span class="n">k</span><span class="p">,</span>
                               <span class="kt">float</span> <span class="o">*</span><span class="n">distances</span><span class="p">,</span> <span class="n">idx_t</span> <span class="o">*</span><span class="n">labels</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="c1">// we see the distances and labels as heaps</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">metric_type</span> <span class="o">==</span> <span class="n">METRIC_INNER_PRODUCT</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">float_minheap_array_t</span> <span class="n">res</span> <span class="o">=</span> <span class="p">{</span>
            <span class="kt">size_t</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="kt">size_t</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="n">labels</span><span class="p">,</span> <span class="n">distances</span><span class="p">};</span>
        <span class="n">knn_inner_product</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xb</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">d</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">ntotal</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">res</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">metric_type</span> <span class="o">==</span> <span class="n">METRIC_L2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">float_maxheap_array_t</span> <span class="n">res</span> <span class="o">=</span> <span class="p">{</span>
            <span class="kt">size_t</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="kt">size_t</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="n">labels</span><span class="p">,</span> <span class="n">distances</span><span class="p">};</span>
        <span class="n">knn_L2sqr</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xb</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">d</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">ntotal</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">res</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">float_maxheap_array_t</span> <span class="n">res</span> <span class="o">=</span> <span class="p">{</span>
            <span class="kt">size_t</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="kt">size_t</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="n">labels</span><span class="p">,</span> <span class="n">distances</span><span class="p">};</span>
        <span class="n">knn_extra_metrics</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xb</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">d</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">ntotal</span><span class="p">,</span>
                           <span class="n">metric_type</span><span class="p">,</span> <span class="n">metric_arg</span><span class="p">,</span>
                           <span class="o">&amp;</span><span class="n">res</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">IndexFlat</span><span class="o">::</span><span class="n">range_search</span> <span class="p">(</span><span class="n">idx_t</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">radius</span><span class="p">,</span>
                              <span class="n">RangeSearchResult</span> <span class="o">*</span><span class="n">result</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">metric_type</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nl">METRIC_INNER_PRODUCT</span><span class="p">:</span>
        <span class="n">range_search_inner_product</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xb</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">d</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">ntotal</span><span class="p">,</span>
                                    <span class="n">radius</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">METRIC_L2</span><span class="p">:</span>
        <span class="n">range_search_L2sqr</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xb</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">d</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">ntotal</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">default</span><span class="o">:</span>
        <span class="n">FAISS_THROW_MSG</span><span class="p">(</span><span class="s">&quot;metric type not supported&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="n">IndexFlat</span><span class="o">::</span><span class="n">compute_distance_subset</span> <span class="p">(</span>
            <span class="n">idx_t</span> <span class="n">n</span><span class="p">,</span>
            <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span>
            <span class="n">idx_t</span> <span class="n">k</span><span class="p">,</span>
            <span class="kt">float</span> <span class="o">*</span><span class="n">distances</span><span class="p">,</span>
            <span class="k">const</span> <span class="n">idx_t</span> <span class="o">*</span><span class="n">labels</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">metric_type</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nl">METRIC_INNER_PRODUCT</span><span class="p">:</span>
            <span class="n">fvec_inner_products_by_idx</span> <span class="p">(</span>
                 <span class="n">distances</span><span class="p">,</span>
                 <span class="n">x</span><span class="p">,</span> <span class="n">xb</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">labels</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">METRIC_L2</span><span class="p">:</span>
            <span class="n">fvec_L2sqr_by_idx</span> <span class="p">(</span>
                 <span class="n">distances</span><span class="p">,</span>
                 <span class="n">x</span><span class="p">,</span> <span class="n">xb</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">labels</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">default</span><span class="o">:</span>
            <span class="n">FAISS_THROW_MSG</span><span class="p">(</span><span class="s">&quot;metric type not supported&quot;</span><span class="p">);</span>
    <span class="p">}</span>

<span class="p">}</span>

<span class="kt">size_t</span> <span class="n">IndexFlat</span><span class="o">::</span><span class="n">remove_ids</span> <span class="p">(</span><span class="k">const</span> <span class="n">IDSelector</span> <span class="o">&amp;</span> <span class="n">sel</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">idx_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">idx_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ntotal</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">sel</span><span class="p">.</span><span class="n">is_member</span> <span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
            <span class="c1">// should be removed</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">memmove</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">xb</span><span class="p">[</span><span class="n">d</span> <span class="o">*</span> <span class="n">j</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">xb</span><span class="p">[</span><span class="n">d</span> <span class="o">*</span> <span class="n">i</span><span class="p">],</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xb</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">d</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">j</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="kt">size_t</span> <span class="n">nremove</span> <span class="o">=</span> <span class="n">ntotal</span> <span class="o">-</span> <span class="n">j</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nremove</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ntotal</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
        <span class="n">xb</span><span class="p">.</span><span class="n">resize</span> <span class="p">(</span><span class="n">ntotal</span> <span class="o">*</span> <span class="n">d</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">nremove</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">namespace</span> <span class="p">{</span>


<span class="k">struct</span> <span class="nl">FlatL2Dis</span> <span class="p">:</span> <span class="n">DistanceComputer</span> <span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">d</span><span class="p">;</span>
    <span class="n">Index</span><span class="o">::</span><span class="n">idx_t</span> <span class="n">nb</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">ndis</span><span class="p">;</span>

    <span class="kt">float</span> <span class="nf">operator</span> <span class="p">()</span> <span class="p">(</span><span class="n">idx_t</span> <span class="n">i</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
        <span class="n">ndis</span><span class="o">++</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">fvec_L2sqr</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">b</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">float</span> <span class="nf">symmetric_dis</span><span class="p">(</span><span class="n">idx_t</span> <span class="n">i</span><span class="p">,</span> <span class="n">idx_t</span> <span class="n">j</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">fvec_L2sqr</span><span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="n">d</span><span class="p">,</span> <span class="n">b</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">explicit</span> <span class="nf">FlatL2Dis</span><span class="p">(</span><span class="k">const</span> <span class="n">IndexFlat</span><span class="o">&amp;</span> <span class="n">storage</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">d</span><span class="p">(</span><span class="n">storage</span><span class="p">.</span><span class="n">d</span><span class="p">),</span>
          <span class="n">nb</span><span class="p">(</span><span class="n">storage</span><span class="p">.</span><span class="n">ntotal</span><span class="p">),</span>
          <span class="n">q</span><span class="p">(</span><span class="n">q</span><span class="p">),</span>
          <span class="n">b</span><span class="p">(</span><span class="n">storage</span><span class="p">.</span><span class="n">xb</span><span class="p">.</span><span class="n">data</span><span class="p">()),</span>
          <span class="n">ndis</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>

    <span class="kt">void</span> <span class="nf">set_query</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nl">FlatIPDis</span> <span class="p">:</span> <span class="n">DistanceComputer</span> <span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">d</span><span class="p">;</span>
    <span class="n">Index</span><span class="o">::</span><span class="n">idx_t</span> <span class="n">nb</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">ndis</span><span class="p">;</span>

    <span class="kt">float</span> <span class="nf">operator</span> <span class="p">()</span> <span class="p">(</span><span class="n">idx_t</span> <span class="n">i</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
        <span class="n">ndis</span><span class="o">++</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">fvec_inner_product</span> <span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">b</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">float</span> <span class="nf">symmetric_dis</span><span class="p">(</span><span class="n">idx_t</span> <span class="n">i</span><span class="p">,</span> <span class="n">idx_t</span> <span class="n">j</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">fvec_inner_product</span> <span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="n">d</span><span class="p">,</span> <span class="n">b</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">explicit</span> <span class="nf">FlatIPDis</span><span class="p">(</span><span class="k">const</span> <span class="n">IndexFlat</span><span class="o">&amp;</span> <span class="n">storage</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">d</span><span class="p">(</span><span class="n">storage</span><span class="p">.</span><span class="n">d</span><span class="p">),</span>
          <span class="n">nb</span><span class="p">(</span><span class="n">storage</span><span class="p">.</span><span class="n">ntotal</span><span class="p">),</span>
          <span class="n">q</span><span class="p">(</span><span class="n">q</span><span class="p">),</span>
          <span class="n">b</span><span class="p">(</span><span class="n">storage</span><span class="p">.</span><span class="n">xb</span><span class="p">.</span><span class="n">data</span><span class="p">()),</span>
          <span class="n">ndis</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>

    <span class="kt">void</span> <span class="nf">set_query</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>




<span class="p">}</span>  <span class="c1">// namespace</span>


<span class="n">DistanceComputer</span> <span class="o">*</span> <span class="n">IndexFlat</span><span class="o">::</span><span class="n">get_distance_computer</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">metric_type</span> <span class="o">==</span> <span class="n">METRIC_L2</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">FlatL2Dis</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">metric_type</span> <span class="o">==</span> <span class="n">METRIC_INNER_PRODUCT</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">FlatIPDis</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">get_extra_distance_computer</span> <span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">metric_type</span><span class="p">,</span> <span class="n">metric_arg</span><span class="p">,</span>
                                            <span class="n">ntotal</span><span class="p">,</span> <span class="n">xb</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="n">IndexFlat</span><span class="o">::</span><span class="n">reconstruct</span> <span class="p">(</span><span class="n">idx_t</span> <span class="n">key</span><span class="p">,</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">recons</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">memcpy</span> <span class="p">(</span><span class="n">recons</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">xb</span><span class="p">[</span><span class="n">key</span> <span class="o">*</span> <span class="n">d</span><span class="p">]),</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">recons</span><span class="p">)</span> <span class="o">*</span> <span class="n">d</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/* The standalone codec interface */</span>
<span class="kt">size_t</span> <span class="n">IndexFlat</span><span class="o">::</span><span class="n">sa_code_size</span> <span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span> <span class="o">*</span> <span class="n">d</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">IndexFlat</span><span class="o">::</span><span class="n">sa_encode</span> <span class="p">(</span><span class="n">idx_t</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">bytes</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">memcpy</span> <span class="p">(</span><span class="n">bytes</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span> <span class="o">*</span> <span class="n">d</span> <span class="o">*</span> <span class="n">n</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">IndexFlat</span><span class="o">::</span><span class="n">sa_decode</span> <span class="p">(</span><span class="n">idx_t</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">bytes</span><span class="p">,</span> <span class="kt">float</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">memcpy</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">bytes</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span> <span class="o">*</span> <span class="n">d</span> <span class="o">*</span> <span class="n">n</span><span class="p">);</span>
<span class="p">}</span>




<span class="cm">/***************************************************</span>
<span class="cm"> * IndexFlatL2BaseShift</span>
<span class="cm"> ***************************************************/</span>

<span class="n">IndexFlatL2BaseShift</span><span class="o">::</span><span class="n">IndexFlatL2BaseShift</span> <span class="p">(</span><span class="n">idx_t</span> <span class="n">d</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nshift</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">shift</span><span class="p">)</span><span class="o">:</span>
    <span class="n">IndexFlatL2</span> <span class="p">(</span><span class="n">d</span><span class="p">),</span> <span class="n">shift</span> <span class="p">(</span><span class="n">nshift</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">memcpy</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">shift</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">shift</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span> <span class="o">*</span> <span class="n">nshift</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">IndexFlatL2BaseShift</span><span class="o">::</span><span class="n">search</span> <span class="p">(</span>
            <span class="n">idx_t</span> <span class="n">n</span><span class="p">,</span>
            <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span>
            <span class="n">idx_t</span> <span class="n">k</span><span class="p">,</span>
            <span class="kt">float</span> <span class="o">*</span><span class="n">distances</span><span class="p">,</span>
            <span class="n">idx_t</span> <span class="o">*</span><span class="n">labels</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">FAISS_THROW_IF_NOT</span> <span class="p">(</span><span class="n">shift</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">ntotal</span><span class="p">);</span>

    <span class="n">float_maxheap_array_t</span> <span class="n">res</span> <span class="o">=</span> <span class="p">{</span>
        <span class="kt">size_t</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="kt">size_t</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="n">labels</span><span class="p">,</span> <span class="n">distances</span><span class="p">};</span>
    <span class="n">knn_L2sqr_base_shift</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xb</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">d</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">ntotal</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">res</span><span class="p">,</span> <span class="n">shift</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>
<span class="p">}</span>



<span class="cm">/***************************************************</span>
<span class="cm"> * IndexRefineFlat</span>
<span class="cm"> ***************************************************/</span>

<span class="n">IndexRefineFlat</span><span class="o">::</span><span class="n">IndexRefineFlat</span> <span class="p">(</span><span class="n">Index</span> <span class="o">*</span><span class="n">base_index</span><span class="p">)</span><span class="o">:</span>
    <span class="n">Index</span> <span class="p">(</span><span class="n">base_index</span><span class="o">-&gt;</span><span class="n">d</span><span class="p">,</span> <span class="n">base_index</span><span class="o">-&gt;</span><span class="n">metric_type</span><span class="p">),</span>
    <span class="n">refine_index</span> <span class="p">(</span><span class="n">base_index</span><span class="o">-&gt;</span><span class="n">d</span><span class="p">,</span> <span class="n">base_index</span><span class="o">-&gt;</span><span class="n">metric_type</span><span class="p">),</span>
    <span class="n">base_index</span> <span class="p">(</span><span class="n">base_index</span><span class="p">),</span> <span class="n">own_fields</span> <span class="p">(</span><span class="nb">false</span><span class="p">),</span>
    <span class="n">k_factor</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">is_trained</span> <span class="o">=</span> <span class="n">base_index</span><span class="o">-&gt;</span><span class="n">is_trained</span><span class="p">;</span>
    <span class="n">FAISS_THROW_IF_NOT_MSG</span> <span class="p">(</span><span class="n">base_index</span><span class="o">-&gt;</span><span class="n">ntotal</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span>
                      <span class="s">&quot;base_index should be empty in the beginning&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">IndexRefineFlat</span><span class="o">::</span><span class="n">IndexRefineFlat</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">base_index</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">own_fields</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">k_factor</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="n">IndexRefineFlat</span><span class="o">::</span><span class="n">train</span> <span class="p">(</span><span class="n">idx_t</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">base_index</span><span class="o">-&gt;</span><span class="n">train</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
    <span class="n">is_trained</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">IndexRefineFlat</span><span class="o">::</span><span class="n">add</span> <span class="p">(</span><span class="n">idx_t</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">FAISS_THROW_IF_NOT</span> <span class="p">(</span><span class="n">is_trained</span><span class="p">);</span>
    <span class="n">base_index</span><span class="o">-&gt;</span><span class="n">add</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
    <span class="n">refine_index</span><span class="p">.</span><span class="n">add</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
    <span class="n">ntotal</span> <span class="o">=</span> <span class="n">refine_index</span><span class="p">.</span><span class="n">ntotal</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">IndexRefineFlat</span><span class="o">::</span><span class="n">reset</span> <span class="p">()</span>
<span class="p">{</span>
    <span class="n">base_index</span><span class="o">-&gt;</span><span class="n">reset</span> <span class="p">();</span>
    <span class="n">refine_index</span><span class="p">.</span><span class="n">reset</span> <span class="p">();</span>
    <span class="n">ntotal</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">namespace</span> <span class="p">{</span>
<span class="k">typedef</span> <span class="n">faiss</span><span class="o">::</span><span class="n">Index</span><span class="o">::</span><span class="n">idx_t</span> <span class="n">idx_t</span><span class="p">;</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">C</span><span class="o">&gt;</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">reorder_2_heaps</span> <span class="p">(</span>
      <span class="n">idx_t</span> <span class="n">n</span><span class="p">,</span>
      <span class="n">idx_t</span> <span class="n">k</span><span class="p">,</span> <span class="n">idx_t</span> <span class="o">*</span><span class="n">labels</span><span class="p">,</span> <span class="kt">float</span> <span class="o">*</span><span class="n">distances</span><span class="p">,</span>
      <span class="n">idx_t</span> <span class="n">k_base</span><span class="p">,</span> <span class="k">const</span> <span class="n">idx_t</span> <span class="o">*</span><span class="n">base_labels</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">base_distances</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#pragma omp parallel for</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">idx_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">idx_t</span> <span class="o">*</span><span class="n">idxo</span> <span class="o">=</span> <span class="n">labels</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">k</span><span class="p">;</span>
        <span class="kt">float</span> <span class="o">*</span><span class="n">diso</span> <span class="o">=</span> <span class="n">distances</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">k</span><span class="p">;</span>
        <span class="k">const</span> <span class="n">idx_t</span> <span class="o">*</span><span class="n">idxi</span> <span class="o">=</span> <span class="n">base_labels</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">k_base</span><span class="p">;</span>
        <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">disi</span> <span class="o">=</span> <span class="n">base_distances</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">k_base</span><span class="p">;</span>

        <span class="n">heap_heapify</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">diso</span><span class="p">,</span> <span class="n">idxo</span><span class="p">,</span> <span class="n">disi</span><span class="p">,</span> <span class="n">idxi</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">k_base</span> <span class="o">!=</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// add remaining elements</span>
            <span class="n">heap_addn</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">diso</span><span class="p">,</span> <span class="n">idxo</span><span class="p">,</span> <span class="n">disi</span> <span class="o">+</span> <span class="n">k</span><span class="p">,</span> <span class="n">idxi</span> <span class="o">+</span> <span class="n">k</span><span class="p">,</span> <span class="n">k_base</span> <span class="o">-</span> <span class="n">k</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">heap_reorder</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">diso</span><span class="p">,</span> <span class="n">idxo</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="p">}</span>


<span class="kt">void</span> <span class="n">IndexRefineFlat</span><span class="o">::</span><span class="n">search</span> <span class="p">(</span>
              <span class="n">idx_t</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">idx_t</span> <span class="n">k</span><span class="p">,</span>
              <span class="kt">float</span> <span class="o">*</span><span class="n">distances</span><span class="p">,</span> <span class="n">idx_t</span> <span class="o">*</span><span class="n">labels</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">FAISS_THROW_IF_NOT</span> <span class="p">(</span><span class="n">is_trained</span><span class="p">);</span>
    <span class="n">idx_t</span> <span class="n">k_base</span> <span class="o">=</span> <span class="n">idx_t</span> <span class="p">(</span><span class="n">k</span> <span class="o">*</span> <span class="n">k_factor</span><span class="p">);</span>
    <span class="n">idx_t</span> <span class="o">*</span> <span class="n">base_labels</span> <span class="o">=</span> <span class="n">labels</span><span class="p">;</span>
    <span class="kt">float</span> <span class="o">*</span> <span class="n">base_distances</span> <span class="o">=</span> <span class="n">distances</span><span class="p">;</span>
    <span class="n">ScopeDeleter</span><span class="o">&lt;</span><span class="n">idx_t</span><span class="o">&gt;</span> <span class="n">del1</span><span class="p">;</span>
    <span class="n">ScopeDeleter</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">del2</span><span class="p">;</span>


    <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">!=</span> <span class="n">k_base</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">base_labels</span> <span class="o">=</span> <span class="k">new</span> <span class="n">idx_t</span> <span class="p">[</span><span class="n">n</span> <span class="o">*</span> <span class="n">k_base</span><span class="p">];</span>
        <span class="n">del1</span><span class="p">.</span><span class="n">set</span> <span class="p">(</span><span class="n">base_labels</span><span class="p">);</span>
        <span class="n">base_distances</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">float</span> <span class="p">[</span><span class="n">n</span> <span class="o">*</span> <span class="n">k_base</span><span class="p">];</span>
        <span class="n">del2</span><span class="p">.</span><span class="n">set</span> <span class="p">(</span><span class="n">base_distances</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">base_index</span><span class="o">-&gt;</span><span class="n">search</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">k_base</span><span class="p">,</span> <span class="n">base_distances</span><span class="p">,</span> <span class="n">base_labels</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">*</span> <span class="n">k_base</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">assert</span> <span class="p">(</span><span class="n">base_labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span>
                <span class="n">base_labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">ntotal</span><span class="p">);</span>

    <span class="c1">// compute refined distances</span>
    <span class="n">refine_index</span><span class="p">.</span><span class="n">compute_distance_subset</span> <span class="p">(</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">k_base</span><span class="p">,</span> <span class="n">base_distances</span><span class="p">,</span> <span class="n">base_labels</span><span class="p">);</span>

    <span class="c1">// sort and store result</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">metric_type</span> <span class="o">==</span> <span class="n">METRIC_L2</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">typedef</span> <span class="n">CMax</span> <span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">idx_t</span><span class="o">&gt;</span> <span class="n">C</span><span class="p">;</span>
        <span class="n">reorder_2_heaps</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span> <span class="p">(</span>
            <span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">distances</span><span class="p">,</span>
            <span class="n">k_base</span><span class="p">,</span> <span class="n">base_labels</span><span class="p">,</span> <span class="n">base_distances</span><span class="p">);</span>

    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">metric_type</span> <span class="o">==</span> <span class="n">METRIC_INNER_PRODUCT</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">typedef</span> <span class="n">CMin</span> <span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span> <span class="n">idx_t</span><span class="o">&gt;</span> <span class="n">C</span><span class="p">;</span>
        <span class="n">reorder_2_heaps</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span> <span class="p">(</span>
            <span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">distances</span><span class="p">,</span>
            <span class="n">k_base</span><span class="p">,</span> <span class="n">base_labels</span><span class="p">,</span> <span class="n">base_distances</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">FAISS_THROW_MSG</span><span class="p">(</span><span class="s">&quot;Metric type not supported&quot;</span><span class="p">);</span>
    <span class="p">}</span>

<span class="p">}</span>



<span class="n">IndexRefineFlat</span><span class="o">::~</span><span class="n">IndexRefineFlat</span> <span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">own_fields</span><span class="p">)</span> <span class="k">delete</span> <span class="n">base_index</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/***************************************************</span>
<span class="cm"> * IndexFlat1D</span>
<span class="cm"> ***************************************************/</span>


<span class="n">IndexFlat1D</span><span class="o">::</span><span class="n">IndexFlat1D</span> <span class="p">(</span><span class="kt">bool</span> <span class="n">continuous_update</span><span class="p">)</span><span class="o">:</span>
    <span class="n">IndexFlatL2</span> <span class="p">(</span><span class="mi">1</span><span class="p">),</span>
    <span class="n">continuous_update</span> <span class="p">(</span><span class="n">continuous_update</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="c1">/// if not continuous_update, call this between the last add and</span>
<span class="c1">/// the first search</span>
<span class="kt">void</span> <span class="n">IndexFlat1D</span><span class="o">::</span><span class="n">update_permutation</span> <span class="p">()</span>
<span class="p">{</span>
    <span class="n">perm</span><span class="p">.</span><span class="n">resize</span> <span class="p">(</span><span class="n">ntotal</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ntotal</span> <span class="o">&lt;</span> <span class="mi">1000000</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fvec_argsort</span> <span class="p">(</span><span class="n">ntotal</span><span class="p">,</span> <span class="n">xb</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="p">(</span><span class="kt">size_t</span><span class="o">*</span><span class="p">)</span><span class="n">perm</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">fvec_argsort_parallel</span> <span class="p">(</span><span class="n">ntotal</span><span class="p">,</span> <span class="n">xb</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="p">(</span><span class="kt">size_t</span><span class="o">*</span><span class="p">)</span><span class="n">perm</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">IndexFlat1D</span><span class="o">::</span><span class="n">add</span> <span class="p">(</span><span class="n">idx_t</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">IndexFlatL2</span><span class="o">::</span><span class="n">add</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">continuous_update</span><span class="p">)</span>
        <span class="n">update_permutation</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">IndexFlat1D</span><span class="o">::</span><span class="n">reset</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">IndexFlatL2</span><span class="o">::</span><span class="n">reset</span><span class="p">();</span>
    <span class="n">perm</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">IndexFlat1D</span><span class="o">::</span><span class="n">search</span> <span class="p">(</span>
            <span class="n">idx_t</span> <span class="n">n</span><span class="p">,</span>
            <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span>
            <span class="n">idx_t</span> <span class="n">k</span><span class="p">,</span>
            <span class="kt">float</span> <span class="o">*</span><span class="n">distances</span><span class="p">,</span>
            <span class="n">idx_t</span> <span class="o">*</span><span class="n">labels</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="n">FAISS_THROW_IF_NOT_MSG</span> <span class="p">(</span><span class="n">perm</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">ntotal</span><span class="p">,</span>
                    <span class="s">&quot;Call update_permutation before search&quot;</span><span class="p">);</span>

<span class="cp">#pragma omp parallel for</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">idx_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

        <span class="kt">float</span> <span class="n">q</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="c1">// query</span>
        <span class="kt">float</span> <span class="o">*</span><span class="n">D</span> <span class="o">=</span> <span class="n">distances</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">k</span><span class="p">;</span>
        <span class="n">idx_t</span> <span class="o">*</span><span class="n">I</span> <span class="o">=</span> <span class="n">labels</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">k</span><span class="p">;</span>

        <span class="c1">// binary search</span>
        <span class="n">idx_t</span> <span class="n">i0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i1</span> <span class="o">=</span> <span class="n">ntotal</span><span class="p">;</span>
        <span class="n">idx_t</span> <span class="n">wp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">xb</span><span class="p">[</span><span class="n">perm</span><span class="p">[</span><span class="n">i0</span><span class="p">]]</span> <span class="o">&gt;</span> <span class="n">q</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">i1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">goto</span> <span class="n">finish_right</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">xb</span><span class="p">[</span><span class="n">perm</span><span class="p">[</span><span class="n">i1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">&lt;=</span> <span class="n">q</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">i0</span> <span class="o">=</span> <span class="n">i1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">goto</span> <span class="n">finish_left</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">i0</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">i1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">idx_t</span> <span class="n">imed</span> <span class="o">=</span> <span class="p">(</span><span class="n">i0</span> <span class="o">+</span> <span class="n">i1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">xb</span><span class="p">[</span><span class="n">perm</span><span class="p">[</span><span class="n">imed</span><span class="p">]]</span> <span class="o">&lt;=</span> <span class="n">q</span><span class="p">)</span> <span class="n">i0</span> <span class="o">=</span> <span class="n">imed</span><span class="p">;</span>
            <span class="k">else</span>                    <span class="n">i1</span> <span class="o">=</span> <span class="n">imed</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// query is between xb[perm[i0]] and xb[perm[i1]]</span>
        <span class="c1">// expand to nearest neighs</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">wp</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">float</span> <span class="n">xleft</span> <span class="o">=</span> <span class="n">xb</span><span class="p">[</span><span class="n">perm</span><span class="p">[</span><span class="n">i0</span><span class="p">]];</span>
            <span class="kt">float</span> <span class="n">xright</span> <span class="o">=</span> <span class="n">xb</span><span class="p">[</span><span class="n">perm</span><span class="p">[</span><span class="n">i1</span><span class="p">]];</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">q</span> <span class="o">-</span> <span class="n">xleft</span> <span class="o">&lt;</span> <span class="n">xright</span> <span class="o">-</span> <span class="n">q</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">D</span><span class="p">[</span><span class="n">wp</span><span class="p">]</span> <span class="o">=</span> <span class="n">q</span> <span class="o">-</span> <span class="n">xleft</span><span class="p">;</span>
                <span class="n">I</span><span class="p">[</span><span class="n">wp</span><span class="p">]</span> <span class="o">=</span> <span class="n">perm</span><span class="p">[</span><span class="n">i0</span><span class="p">];</span>
                <span class="n">i0</span><span class="o">--</span><span class="p">;</span> <span class="n">wp</span><span class="o">++</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">i0</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="k">goto</span> <span class="n">finish_right</span><span class="p">;</span> <span class="p">}</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">D</span><span class="p">[</span><span class="n">wp</span><span class="p">]</span> <span class="o">=</span> <span class="n">xright</span> <span class="o">-</span> <span class="n">q</span><span class="p">;</span>
                <span class="n">I</span><span class="p">[</span><span class="n">wp</span><span class="p">]</span> <span class="o">=</span> <span class="n">perm</span><span class="p">[</span><span class="n">i1</span><span class="p">];</span>
                <span class="n">i1</span><span class="o">++</span><span class="p">;</span> <span class="n">wp</span><span class="o">++</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">i1</span> <span class="o">&gt;=</span> <span class="n">ntotal</span><span class="p">)</span> <span class="p">{</span> <span class="k">goto</span> <span class="n">finish_left</span><span class="p">;</span> <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

    <span class="nl">finish_right</span><span class="p">:</span>
        <span class="c1">// grow to the right from i1</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">wp</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i1</span> <span class="o">&lt;</span> <span class="n">ntotal</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">D</span><span class="p">[</span><span class="n">wp</span><span class="p">]</span> <span class="o">=</span> <span class="n">xb</span><span class="p">[</span><span class="n">perm</span><span class="p">[</span><span class="n">i1</span><span class="p">]]</span> <span class="o">-</span> <span class="n">q</span><span class="p">;</span>
                <span class="n">I</span><span class="p">[</span><span class="n">wp</span><span class="p">]</span> <span class="o">=</span> <span class="n">perm</span><span class="p">[</span><span class="n">i1</span><span class="p">];</span>
                <span class="n">i1</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">D</span><span class="p">[</span><span class="n">wp</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;::</span><span class="n">infinity</span><span class="p">();</span>
                <span class="n">I</span><span class="p">[</span><span class="n">wp</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">wp</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

    <span class="nl">finish_left</span><span class="p">:</span>
        <span class="c1">// grow to the left from i0</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">wp</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i0</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">D</span><span class="p">[</span><span class="n">wp</span><span class="p">]</span> <span class="o">=</span> <span class="n">q</span> <span class="o">-</span> <span class="n">xb</span><span class="p">[</span><span class="n">perm</span><span class="p">[</span><span class="n">i0</span><span class="p">]];</span>
                <span class="n">I</span><span class="p">[</span><span class="n">wp</span><span class="p">]</span> <span class="o">=</span> <span class="n">perm</span><span class="p">[</span><span class="n">i0</span><span class="p">];</span>
                <span class="n">i0</span><span class="o">--</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">D</span><span class="p">[</span><span class="n">wp</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;::</span><span class="n">infinity</span><span class="p">();</span>
                <span class="n">I</span><span class="p">[</span><span class="n">wp</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">wp</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="nl">done</span><span class="p">:</span>  <span class="p">;</span>
    <span class="p">}</span>

<span class="p">}</span>



<span class="p">}</span> <span class="c1">// namespace faiss</span>
</pre></div>

<h4 id="434-indexlshhindexlshcpp">4.3.4 IndexLSH.h和IndexLSH.cpp文件<a class="headerlink" href="#434-indexlshhindexlshcpp" title="Permanent link">&para;</a></h4>
<ul>
<li><strong><code>IndexLSH.h</code>文件</strong></li>
</ul>
<div class="highlight"><pre><span></span><span class="cp">#ifndef INDEX_LSH_H</span>
<span class="cp">#define INDEX_LSH_H</span>

<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&lt;faiss/Index.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;faiss/VectorTransform.h&gt;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">faiss</span> <span class="p">{</span>


    <span class="cm">/** The sign of each vector component is put in a binary signature */</span>
    <span class="k">struct</span> <span class="nl">IndexLSH</span><span class="p">:</span><span class="n">Index</span> <span class="p">{</span>
        <span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="kt">uint8_t</span><span class="p">;</span>

        <span class="kt">int</span> <span class="n">nbits</span><span class="p">;</span>              <span class="c1">///&lt; nb of bits per vector</span>
        <span class="kt">int</span> <span class="n">bytes_per_vec</span><span class="p">;</span>      <span class="c1">///&lt; nb of 8-bits per encoded vector</span>
        <span class="kt">bool</span> <span class="n">rotate_data</span><span class="p">;</span>       <span class="c1">///&lt; whether to apply a random rotation to input</span>
        <span class="kt">bool</span> <span class="n">train_thresholds</span><span class="p">;</span>  <span class="c1">///&lt; whether we train thresholds or use 0</span>

        <span class="n">RandomRotationMatrix</span> <span class="n">rrot</span><span class="p">;</span> <span class="c1">///&lt; optional random rotation</span>

        <span class="n">std</span><span class="o">::</span><span class="n">vector</span> <span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">thresholds</span><span class="p">;</span> <span class="c1">///&lt; thresholds to compare with</span>

        <span class="c1">/// encoded dataset</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">codes</span><span class="p">;</span>

        <span class="n">IndexLSH</span> <span class="p">(</span><span class="n">idx_t</span> <span class="n">d</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nbits</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">rotate_data</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">train_thresholds</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>

        <span class="cm">/** Preprocesses and resizes the input to the size required to</span>
<span class="cm">         * binarize the data</span>
<span class="cm">         * @param x input vectors, size n * d</span>
<span class="cm">         * @return output vectors, size n * bits. May be the same pointer</span>
<span class="cm">         *         as x, otherwise it should be deleted by the caller</span>
<span class="cm">         */</span>
        <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="nf">apply_preprocess</span> <span class="p">(</span><span class="n">idx_t</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

        <span class="kt">void</span> <span class="nf">train</span><span class="p">(</span><span class="n">idx_t</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span><span class="o">*</span> <span class="n">x</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>

        <span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="n">idx_t</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span><span class="o">*</span> <span class="n">x</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>

        <span class="kt">void</span> <span class="nf">search</span><span class="p">(</span><span class="n">idx_t</span> <span class="n">n</span><span class="p">,</span><span class="k">const</span> <span class="kt">float</span><span class="o">*</span> <span class="n">x</span><span class="p">,</span><span class="n">idx_t</span> <span class="n">k</span><span class="p">,</span><span class="kt">float</span><span class="o">*</span> <span class="n">distances</span><span class="p">,</span><span class="n">idx_t</span><span class="o">*</span> <span class="n">labels</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>

        <span class="kt">void</span> <span class="nf">reset</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>

        <span class="c1">/// transfer the thresholds to a pre-processing stage (and unset train_thresholds)</span>
        <span class="kt">void</span> <span class="nf">transfer_thresholds</span> <span class="p">(</span><span class="n">LinearTransform</span> <span class="o">*</span> <span class="n">vt</span><span class="p">);</span>

        <span class="o">~</span><span class="n">IndexLSH</span><span class="p">()</span> <span class="k">override</span> <span class="p">{}</span>

        <span class="n">IndexLSH</span> <span class="p">();</span>

        <span class="cm">/* standalone codec interface.</span>
<span class="cm">         * The vectors are decoded to +/- 1 (not 0, 1) */</span>

        <span class="kt">size_t</span> <span class="nf">sa_code_size</span> <span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>

        <span class="kt">void</span> <span class="nf">sa_encode</span> <span class="p">(</span><span class="n">idx_t</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">bytes</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>

        <span class="kt">void</span> <span class="nf">sa_decode</span> <span class="p">(</span><span class="n">idx_t</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">bytes</span><span class="p">,</span> <span class="kt">float</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">}</span>
<span class="cp">#endif</span>
</pre></div>

<ul>
<li><strong><code>IndexLSH.cpp</code>文件</strong></li>
</ul>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;faiss/IndexLSH.h&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cstring&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&lt;faiss/utils/utils.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;faiss/utils/hamming.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;faiss/impl/FaissAssert.h&gt;</span><span class="cp"></span>


<span class="n">namespace</span> <span class="n">faiss</span> <span class="p">{</span>

    <span class="cm">/***************************************************************</span>
<span class="cm">     * IndexLSH</span>
<span class="cm">     ***************************************************************/</span>
    <span class="n">IndexLSH</span><span class="o">::</span><span class="n">IndexLSH</span> <span class="p">(</span><span class="n">idx_t</span> <span class="n">d</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nbits</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">rotate_data</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">train_thresholds</span><span class="p">)</span><span class="o">:</span>
        <span class="n">Index</span><span class="p">(</span><span class="n">d</span><span class="p">),</span> <span class="n">nbits</span><span class="p">(</span><span class="n">nbits</span><span class="p">),</span> <span class="n">rotate_data</span><span class="p">(</span><span class="n">rotate_data</span><span class="p">),</span>
        <span class="n">train_thresholds</span> <span class="p">(</span><span class="n">train_thresholds</span><span class="p">),</span> <span class="n">rrot</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">nbits</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">is_trained</span> <span class="o">=</span> <span class="o">!</span><span class="n">train_thresholds</span><span class="p">;</span>

            <span class="n">bytes_per_vec</span> <span class="o">=</span> <span class="p">(</span><span class="n">nbits</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">rotate_data</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">rrot</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">FAISS_THROW_IF_NOT</span> <span class="p">(</span><span class="n">d</span> <span class="o">&gt;=</span> <span class="n">nbits</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">IndexLSH</span><span class="o">::</span><span class="n">IndexLSH</span> <span class="p">()</span><span class="o">:</span> <span class="n">nbits</span> <span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">bytes_per_vec</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">rotate_data</span> <span class="p">(</span><span class="nb">false</span><span class="p">),</span> <span class="n">train_thresholds</span> <span class="p">(</span><span class="nb">false</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>


    <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span> <span class="n">IndexLSH</span><span class="o">::</span><span class="n">apply_preprocess</span> <span class="p">(</span><span class="n">idx_t</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>

        <span class="kt">float</span> <span class="o">*</span><span class="n">xt</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">rotate_data</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// also applies bias if exists</span>
            <span class="n">xt</span> <span class="o">=</span> <span class="n">rrot</span><span class="p">.</span><span class="n">apply</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">!=</span> <span class="n">nbits</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">assert</span> <span class="p">(</span><span class="n">nbits</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">);</span>
            <span class="n">xt</span> <span class="o">=</span> <span class="n">new</span> <span class="kt">float</span> <span class="p">[</span><span class="n">nbits</span> <span class="o">*</span> <span class="n">n</span><span class="p">];</span>
            <span class="kt">float</span> <span class="o">*</span><span class="n">xp</span> <span class="o">=</span> <span class="n">xt</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">idx_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">xl</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">d</span><span class="p">;</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nbits</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
                    <span class="o">*</span><span class="n">xp</span><span class="o">++</span> <span class="o">=</span> <span class="n">xl</span> <span class="p">[</span><span class="n">j</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">train_thresholds</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">xt</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">xt</span> <span class="o">=</span> <span class="n">new</span> <span class="kt">float</span> <span class="p">[</span><span class="n">nbits</span> <span class="o">*</span> <span class="n">n</span><span class="p">];</span>
                <span class="n">memcpy</span> <span class="p">(</span><span class="n">xt</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">n</span> <span class="o">*</span> <span class="n">nbits</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="kt">float</span> <span class="o">*</span><span class="n">xp</span> <span class="o">=</span> <span class="n">xt</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">idx_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nbits</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
                    <span class="o">*</span><span class="n">xp</span><span class="o">++</span> <span class="o">-=</span> <span class="n">thresholds</span> <span class="p">[</span><span class="n">j</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">xt</span> <span class="o">?</span> <span class="nl">xt</span> <span class="p">:</span> <span class="n">x</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">IndexLSH</span><span class="o">::</span><span class="n">train</span> <span class="p">(</span><span class="n">idx_t</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">train_thresholds</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">thresholds</span><span class="p">.</span><span class="n">resize</span> <span class="p">(</span><span class="n">nbits</span><span class="p">);</span>
            <span class="n">train_thresholds</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
            <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">xt</span> <span class="o">=</span> <span class="n">apply_preprocess</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
            <span class="n">ScopeDeleter</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">del</span> <span class="p">(</span><span class="n">xt</span> <span class="o">==</span> <span class="n">x</span> <span class="o">?</span> <span class="nl">nullptr</span> <span class="p">:</span> <span class="n">xt</span><span class="p">);</span>
            <span class="n">train_thresholds</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

            <span class="kt">float</span> <span class="o">*</span> <span class="n">transposed_x</span> <span class="o">=</span> <span class="n">new</span> <span class="kt">float</span> <span class="p">[</span><span class="n">n</span> <span class="o">*</span> <span class="n">nbits</span><span class="p">];</span>
            <span class="n">ScopeDeleter</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">del2</span> <span class="p">(</span><span class="n">transposed_x</span><span class="p">);</span>

            <span class="k">for</span> <span class="p">(</span><span class="n">idx_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">idx_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nbits</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
                    <span class="n">transposed_x</span> <span class="p">[</span><span class="n">j</span> <span class="o">*</span> <span class="n">n</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">xt</span> <span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">nbits</span> <span class="o">+</span> <span class="n">j</span><span class="p">];</span>

            <span class="k">for</span> <span class="p">(</span><span class="n">idx_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nbits</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="kt">float</span> <span class="o">*</span><span class="n">xi</span> <span class="o">=</span> <span class="n">transposed_x</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">n</span><span class="p">;</span>
                <span class="c1">// std::nth_element</span>
                <span class="n">std</span><span class="o">::</span><span class="n">sort</span> <span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">xi</span> <span class="o">+</span> <span class="n">n</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="n">thresholds</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">xi</span> <span class="p">[</span><span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">];</span>
                <span class="k">else</span>
                    <span class="n">thresholds</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">xi</span> <span class="p">[</span><span class="n">n</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">xi</span> <span class="p">[</span><span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">is_trained</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>


    <span class="kt">void</span> <span class="n">IndexLSH</span><span class="o">::</span><span class="n">add</span> <span class="p">(</span><span class="n">idx_t</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">FAISS_THROW_IF_NOT</span> <span class="p">(</span><span class="n">is_trained</span><span class="p">);</span>
        <span class="n">codes</span><span class="p">.</span><span class="n">resize</span> <span class="p">((</span><span class="n">ntotal</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">bytes_per_vec</span><span class="p">);</span>

        <span class="n">sa_encode</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">codes</span><span class="p">[</span><span class="n">ntotal</span> <span class="o">*</span> <span class="n">bytes_per_vec</span><span class="p">]);</span>
        <span class="n">ntotal</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
    <span class="p">}</span>


    <span class="kt">void</span> <span class="n">IndexLSH</span><span class="o">::</span><span class="n">search</span> <span class="p">(</span> <span class="n">idx_t</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">idx_t</span> <span class="n">k</span><span class="p">,</span> <span class="kt">float</span> <span class="o">*</span><span class="n">distances</span><span class="p">,</span> <span class="n">idx_t</span> <span class="o">*</span><span class="n">labels</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="n">FAISS_THROW_IF_NOT</span> <span class="p">(</span><span class="n">is_trained</span><span class="p">);</span>
        <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">xt</span> <span class="o">=</span> <span class="n">apply_preprocess</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
        <span class="n">ScopeDeleter</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">del</span> <span class="p">(</span><span class="n">xt</span> <span class="o">==</span> <span class="n">x</span> <span class="o">?</span> <span class="nl">nullptr</span> <span class="p">:</span> <span class="n">xt</span><span class="p">);</span>

        <span class="kt">uint8_t</span> <span class="o">*</span> <span class="n">qcodes</span> <span class="o">=</span> <span class="n">new</span> <span class="kt">uint8_t</span> <span class="p">[</span><span class="n">n</span> <span class="o">*</span> <span class="n">bytes_per_vec</span><span class="p">];</span>
        <span class="n">ScopeDeleter</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">del2</span> <span class="p">(</span><span class="n">qcodes</span><span class="p">);</span>

        <span class="n">fvecs2bitvecs</span> <span class="p">(</span><span class="n">xt</span><span class="p">,</span> <span class="n">qcodes</span><span class="p">,</span> <span class="n">nbits</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>

        <span class="kt">int</span> <span class="o">*</span> <span class="n">idistances</span> <span class="o">=</span> <span class="n">new</span> <span class="kt">int</span> <span class="p">[</span><span class="n">n</span> <span class="o">*</span> <span class="n">k</span><span class="p">];</span>
        <span class="n">ScopeDeleter</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">del3</span> <span class="p">(</span><span class="n">idistances</span><span class="p">);</span>

        <span class="n">int_maxheap_array_t</span> <span class="n">res</span> <span class="o">=</span> <span class="p">{</span> <span class="kt">size_t</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="kt">size_t</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="n">labels</span><span class="p">,</span> <span class="n">idistances</span><span class="p">};</span>

        <span class="n">hammings_knn_hc</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">res</span><span class="p">,</span> <span class="n">qcodes</span><span class="p">,</span> <span class="n">codes</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">ntotal</span><span class="p">,</span> <span class="n">bytes_per_vec</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>


        <span class="c1">// convert distances to floats</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span> <span class="o">*</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">distances</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">idistances</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>


    <span class="kt">void</span> <span class="n">IndexLSH</span><span class="o">::</span><span class="n">transfer_thresholds</span> <span class="p">(</span><span class="n">LinearTransform</span> <span class="o">*</span><span class="n">vt</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">train_thresholds</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="n">FAISS_THROW_IF_NOT</span> <span class="p">(</span><span class="n">nbits</span> <span class="o">==</span> <span class="n">vt</span><span class="o">-&gt;</span><span class="n">d_out</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vt</span><span class="o">-&gt;</span><span class="n">have_bias</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">vt</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">.</span><span class="n">resize</span> <span class="p">(</span><span class="n">nbits</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
            <span class="n">vt</span><span class="o">-&gt;</span><span class="n">have_bias</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nbits</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">vt</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="n">thresholds</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">train_thresholds</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="n">thresholds</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">IndexLSH</span><span class="o">::</span><span class="n">reset</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">codes</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
        <span class="n">ntotal</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>


    <span class="kt">size_t</span> <span class="n">IndexLSH</span><span class="o">::</span><span class="n">sa_code_size</span> <span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">bytes_per_vec</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">IndexLSH</span><span class="o">::</span><span class="n">sa_encode</span> <span class="p">(</span><span class="n">idx_t</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">bytes</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="n">FAISS_THROW_IF_NOT</span> <span class="p">(</span><span class="n">is_trained</span><span class="p">);</span>
        <span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">xt</span> <span class="o">=</span> <span class="n">apply_preprocess</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
        <span class="n">ScopeDeleter</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">del</span> <span class="p">(</span><span class="n">xt</span> <span class="o">==</span> <span class="n">x</span> <span class="o">?</span> <span class="nl">nullptr</span> <span class="p">:</span> <span class="n">xt</span><span class="p">);</span>
        <span class="n">fvecs2bitvecs</span> <span class="p">(</span><span class="n">xt</span><span class="p">,</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">nbits</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">IndexLSH</span><span class="o">::</span><span class="n">sa_decode</span> <span class="p">(</span><span class="n">idx_t</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">bytes</span><span class="p">,</span> <span class="kt">float</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="kt">float</span> <span class="o">*</span><span class="n">xt</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
        <span class="n">ScopeDeleter</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">del</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">rotate_data</span> <span class="o">||</span> <span class="n">nbits</span> <span class="o">!=</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">xt</span> <span class="o">=</span> <span class="n">new</span> <span class="kt">float</span> <span class="p">[</span><span class="n">n</span> <span class="o">*</span> <span class="n">nbits</span><span class="p">];</span>
            <span class="n">del</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="n">xt</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">bitvecs2fvecs</span> <span class="p">(</span><span class="n">bytes</span><span class="p">,</span> <span class="n">xt</span><span class="p">,</span> <span class="n">nbits</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">train_thresholds</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">float</span> <span class="o">*</span><span class="n">xp</span> <span class="o">=</span> <span class="n">xt</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">idx_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nbits</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                    <span class="o">*</span><span class="n">xp</span><span class="o">++</span> <span class="o">+=</span> <span class="n">thresholds</span> <span class="p">[</span><span class="n">j</span><span class="p">];</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">rotate_data</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">rrot</span><span class="p">.</span><span class="n">reverse_transform</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">xt</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nbits</span> <span class="o">!=</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">idx_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">memcpy</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">d</span><span class="p">,</span> <span class="n">xt</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">nbits</span><span class="p">,</span> <span class="n">nbits</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">xt</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="c1">// namespace faiss</span>
</pre></div>

<p>参考链接:</p>
<ul>
<li><a href="https://www.cnblogs.com/yhzhou/p/10568728.html">Faiss流程与原理分析</a></li>
<li><a href="https://www.infoq.cn/article/2017/11/Faiss-Facebook">Faiss:Facebook 开源的相似性搜索类库</a></li>
<li></li>
</ul>

  <br>
    <style>
blockquote{
    font-size: 99%;
}
</style>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  CommonHTML: {
    scale: 85
  }
});
</script>
<script type="text/javascript" async
src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


    
    
      
    

    <br>
</div>

</body>
</html>