<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <meta name="author" content="wjizhong">
    <link rel="canonical" href="https://wjizhong.github.io/%E6%AF%94%E8%B5%9B%E5%86%85%E5%AE%B9/leetcode/%E9%A2%98%E7%9B%AE0239_%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/">
    <link rel="shortcut icon" href="https://pic.pngsucai.com/00/18/26/4a7884c36067e596.jpg">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>题目0239:滑动窗口最大值 - 图像/视频算法</title>
    <link href="../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../css/highlight.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\u9898\u76ee0239:\u6ed1\u52a8\u7a97\u53e3\u6700\u5927\u503c", url: "#_top", level:1, children: [
              {title: "\u9898\u76ee\u63cf\u8ff0", url: "#_1", level:2, children: [ 
              ]},
              {title: "\u89e3\u9898\u6280\u5de7", url: "#_2", level:2, children: [ 
              ]},
          ]},
        ];
    </script>
    <script src="../../../js/base.js"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    <style>
blockquote{
    font-size: 99%;
}
</style>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  CommonHTML: {
    scale: 100
  }
});
</script>
<script type="text/javascript" async
src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


    
    
      
    

    

    <h1 id="0239">题目0239:滑动窗口最大值</h1>
<h2 id="_1">题目描述</h2>
<p>给定一个数组nums,有一个大小为k的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的k个数字。滑动窗口每次只向右移动一位。</p>
<p>返回滑动窗口中的最大值。</p>
<p>进阶:你能在线性时间复杂度内解决此题吗?</p>
<p>示例:</p>
<pre><code>输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
输出: [3,3,5,5,6,7] 
解释: 

  滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
</code></pre>

<p>提示:</p>
<blockquote>
<p>1 &lt;= nums.length &lt;= 10^5</p>
<p>-10^4 &lt;= nums[i] &lt;= 10^4</p>
<p>1 &lt;= k &lt;= nums.length</p>
</blockquote>
<h2 id="_2">解题技巧</h2>
<ul>
<li><strong>方法一:暴力法</strong></li>
</ul>
<p>最简单直接的方法是遍历每个滑动窗口,找到每个窗口的最大值。一共有N-k+1个滑动窗口,每个有k个元素,于是算法的时间复杂度为O(Nk),表现较差。</p>
<p>实现</p>
<pre><code class="python">class Solution:
    def maxSlidingWindow(self, nums: 'List[int]', k: 'int') -&gt; 'List[int]':
        n = len(nums)
        if n * k == 0:
            return []

        return [max(nums[i:i + k]) for i in range(n - k + 1)]
</code></pre>

<p>复杂度分析</p>
<blockquote>
<p>时间复杂度:<span><span class="MathJax_Preview">{O}(N k)</span><script type="math/tex">{O}(N k)</script></span>。其中N为数组中元素个数。</p>
<p>空间复杂度:<span><span class="MathJax_Preview">{O}(N - k + 1)</span><script type="math/tex">{O}(N - k + 1)</script></span>,用于输出数组。</p>
</blockquote>
<ul>
<li><strong>方法二:双向队列</strong></li>
</ul>
<p>如何优化时间复杂度呢?首先想到的是使用堆,因为在最大堆中heap[0]永远是最大的元素。在大小为k的堆中插入一个元素消耗<span><span class="MathJax_Preview">\log(k)</span><script type="math/tex">\log(k)</script></span>时间,因此算法的时间复杂度为<span><span class="MathJax_Preview">{O}(N \log(k))</span><script type="math/tex">{O}(N \log(k))</script></span>。</p>
<p>能否得到只要<span><span class="MathJax_Preview">{O}(N)</span><script type="math/tex">{O}(N)</script></span>的算法?</p>
<p>我们可以使用双向队列,该数据结构可以从两端以常数时间压入/弹出元素。</p>
<p>存储双向队列的索引比存储元素更方便,因为两者都能在数组解析中使用。</p>
<p>算法,算法非常直截了当:</p>
<blockquote>
<ul>
<li>处理前k个元素,初始化双向队列。</li>
<li>遍历整个数组。在每一步清理双向队列:</li>
<li>只保留当前滑动窗口中有的元素的索引。</li>
<li>移除比当前元素小的所有元素,它们不可能是最大的。</li>
<li>将当前元素添加到双向队列中。</li>
<li>将deque[0]添加到输出中。</li>
<li>返回输出数组。</li>
</ul>
</blockquote>
<p>实现</p>
<pre><code class="python">from collections import deque
class Solution:
    def maxSlidingWindow(self, nums: 'List[int]', k: 'int') -&gt; 'List[int]':
        # base cases
        n = len(nums)
        if n * k == 0:
            return []
        if k == 1:
            return nums

        def clean_deque(i):
            # remove indexes of elements not from sliding window
            if deq and deq[0] == i - k:
                deq.popleft()

            # remove from deq indexes of all elements 
            # which are smaller than current element nums[i]
            while deq and nums[i] &gt; nums[deq[-1]]:
                deq.pop()

        # init deque and output
        deq = deque()
        max_idx = 0
        for i in range(k):
            clean_deque(i)
            deq.append(i)
            # compute max in nums[:k]
            if nums[i] &gt; nums[max_idx]:
                max_idx = i
        output = [nums[max_idx]]

        # build output
        for i in range(k, n):
            clean_deque(i)          
            deq.append(i)
            output.append(nums[deq[0]])
        return output
</code></pre>

<p>复杂度分析</p>
<blockquote>
<p>时间复杂度:<span><span class="MathJax_Preview">{O}(N)</span><script type="math/tex">{O}(N)</script></span>,每个元素被处理两次-其索引被添加到双向队列中和被双向队列删除。</p>
<p>空间复杂度:<span><span class="MathJax_Preview">{O}(N)</span><script type="math/tex">{O}(N)</script></span>,输出数组使用了<span><span class="MathJax_Preview">{O}(N - k + 1)</span><script type="math/tex">{O}(N - k + 1)</script></span>空间,双向队列使用了<span><span class="MathJax_Preview">{O}(k)</span><script type="math/tex">{O}(k)</script></span>。</p>
</blockquote>
<ul>
<li><strong>方法三:动态规划</strong></li>
</ul>
<p>这是另一个O(N)的算法。本算法的优点是不需要使用数组/列表之外的任何数据结构。</p>
<p>算法的思想是将输入数组分割成有k个元素的块。若n%k != 0,则最后一块的元素个数可能更少。</p>
<p><img alt="" src="http://pic.leetcode-cn.com/95c5c42bcedb9c417b96925e5204e5bdad34456e29bd1b61a41138abd80e4b0b-image.png" /></p>
<p>开头元素为i,结尾元素为j的当前滑动窗口可能在一个块内,也可能在两个块中。</p>
<p><img alt="" src="http://pic.leetcode-cn.com/27af2b52e80803bcb7a8285dbd27cfa9292a6cf6dd0a6454454d6d3357da15c6-image.png" /></p>
<p>情况1比较简单。建立数组left,其中left[j]是从块的开始到下标j最大的元素,方向左-&gt;右。</p>
<p>为了处理更复杂的情况2,我们需要数组right,其中right[j]是从块的结尾到下标j最大的元素,方向右-&gt;左。right数组和left除了方向不同以外基本一致。</p>
<p><img alt="" src="http://pic.leetcode-cn.com/b404188e760dd82a2bd4ebf4f6fe2e8b3c229bb506ed2f3cc8a01675744c351b-image.png" /></p>
<p>两数组一起可以提供两个块内元素的全部信息。考虑从下标i到下标j的滑动窗口。根据定义,right[i]是左侧块内的最大元素,left[j]是右侧块内的最大元素。因此滑动窗口中的最大元素为max(right[i], left[j])。</p>
<p><img alt="" src="http://pic.leetcode-cn.com/3074f1eb068151ebdebbf1b605234815c64d0bf7812d33c8eb5ba044ab625300-image.png" /></p>
<p>算法,算法十分直截了当:</p>
<blockquote>
<ul>
<li>从左到右遍历数组,建立数组 left。</li>
<li>从右到左遍历数组,建立数组 right。</li>
</ul>
</blockquote>
<p>建立输出数组max(right[i], left[i + k - 1]),其中i取值范围为(0, n - k + 1)。</p>
<p><img alt="" src="../images/sliding_window_maximum.gif" /></p>
<p>实现:</p>
<pre><code class="python">class Solution:
    def maxSlidingWindow(self, nums: 'List[int]', k: 'int') -&gt; 'List[int]':
        n = len(nums)
        if n * k == 0:
            return []
        if k == 1:
            return nums

        left = [0] * n
        left[0] = nums[0]
        right = [0] * n
        right[n - 1] = nums[n - 1]
        for i in range(1, n):
            # from left to right
            if i % k == 0:
                # block start
                left[i] = nums[i]
            else:
                left[i] = max(left[i - 1], nums[i])
            # from right to left
            j = n - i - 1
            if (j + 1) % k == 0:
                # block end
                right[j] = nums[j]
            else:
                right[j] = max(right[j + 1], nums[j])

        output = []
        for i in range(n - k + 1):
            output.append(max(left[i + k - 1], right[i]))

        return output
</code></pre>

<p>复杂度分析</p>
<blockquote>
<p>时间复杂度:O(N),我们对长度为N的数组处理了3次。</p>
<p>空间复杂度:O(N),用于存储长度为N的left和right数组,以及长度为N-k+1的输出数组。</p>
</blockquote>

  <br>
    <style>
blockquote{
    font-size: 99%;
}
</style>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  CommonHTML: {
    scale: 100
  }
});
</script>
<script type="text/javascript" async
src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


    
    
      
    

    <br>
</div>

</body>
</html>