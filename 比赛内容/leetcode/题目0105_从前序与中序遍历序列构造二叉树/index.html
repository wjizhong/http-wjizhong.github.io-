<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <meta name="author" content="wjizhong">
    <link rel="canonical" href="https://wjizhong.github.io/%E6%AF%94%E8%B5%9B%E5%86%85%E5%AE%B9/leetcode/%E9%A2%98%E7%9B%AE0105_%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/">
    <link rel="shortcut icon" href="https://pic.pngsucai.com/00/18/26/4a7884c36067e596.jpg">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>题目0105:从前序与中序遍历序列构造二叉树 - 图像/视频算法</title>
    <link href="../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../css/highlight.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\u9898\u76ee0105:\u4ece\u524d\u5e8f\u4e0e\u4e2d\u5e8f\u904d\u5386\u5e8f\u5217\u6784\u9020\u4e8c\u53c9\u6811", url: "#_top", level:1, children: [
              {title: "\u9898\u76ee\u63cf\u8ff0", url: "#_1", level:2, children: [ 
              ]},
              {title: "\u89e3\u9898\u6280\u5de7", url: "#_2", level:2, children: [ 
              ]},
          ]},
        ];
    </script>
    <script src="../../../js/base.js"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    <style>
blockquote{
    font-size: 99%;
}
</style>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  CommonHTML: {
    scale: 100
  }
});
</script>
<script type="text/javascript" async
src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


    
    
      
    

    

    <h1 id="0105">题目0105:从前序与中序遍历序列构造二叉树</h1>
<h2 id="_1">题目描述</h2>
<p>根据一棵树的前序遍历与中序遍历构造二叉树。</p>
<p>注意:你可以假设树中没有重复的元素。</p>
<p>例如,给出</p>
<pre><code>前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
</code></pre>

<p>返回如下的二叉树：</p>
<pre><code>    3
   / \
  9  20
    /  \
   15   7
</code></pre>

<h2 id="_2">解题技巧</h2>
<video src="../images/2d224baae58747fbafcd3005bb24efaf2520761e45060b78316dc5e0a24ff07d.mp4" controls></video>

<p>二叉树前序遍历的顺序为:</p>
<blockquote>
<p>先遍历根节点;</p>
<p>随后递归地遍历左子树;</p>
<p>最后递归地遍历右子树。</p>
</blockquote>
<p>二叉树中序遍历的顺序为:</p>
<blockquote>
<p>先递归地遍历左子树;</p>
<p>随后遍历根节点;</p>
<p>最后递归地遍历右子树。</p>
</blockquote>
<p>在递归地遍历某个子树的过程中,我们也是将这颗子树看成一颗全新的树,按照上述的顺序进行遍历。挖掘前序遍历和中序遍历的性质,我们就可以得出本题的做法。</p>
<ul>
<li><strong>方法一:递归</strong></li>
</ul>
<p>思路:对于任意一颗树而言.前序遍历的形式总是<code>[ 根节点, [左子树的前序遍历结果], [右子树的前序遍历结果] ]</code>,即根节点总是前序遍历中的第一个节点。而中序遍历的形式总是<code>[ [左子树的中序遍历结果], 根节点, [右子树的中序遍历结果] ]</code>,只要我们在中序遍历中定位到根节点,那么我们就可以分别知道左子树和右子树中的节点数目。由于同一颗子树的前序遍历和中序遍历的长度显然是相同的,因此我们就可以对应到前序遍历的结果中,对上述形式中的所有左右括号进行定位。</p>
<p>这样以来,我们就知道了左子树的前序遍历和中序遍历结果,以及右子树的前序遍历和中序遍历结果,我们就可以递归地对构造出左子树和右子树,再将这两颗子树接到根节点的左右位置。</p>
<p>细节:在中序遍历中对根节点进行定位时,一种简单的方法是直接扫描整个中序遍历的结果并找出根节点,但这样做的时间复杂度较高。我们可以考虑使用哈希映射(HashMap)来帮助我们快速地定位根节点。对于哈希映射中的每个键值对,键表示一个元素(节点的值),值表示其在中序遍历中的出现位置。在构造二叉树的过程之前,我们可以对中序遍历的列表进行一遍扫描,就可以构造出这个哈希映射。在此后构造二叉树的过程中,我们就只需要O(1)的时间对根节点进行定位了。</p>
<p>下面的代码给出了详细的注释。</p>
<pre><code class="python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; TreeNode:
        def myBuildTree(preorder_left: int, preorder_right: int, inorder_left: int, inorder_right: int):
            if preorder_left &gt; preorder_right:
                return None

            # 前序遍历中的第一个节点就是根节点
            preorder_root = preorder_left
            # 在中序遍历中定位根节点
            inorder_root = index[preorder[preorder_root]]

            # 先把根节点建立出来
            root = TreeNode(preorder[preorder_root])
            # 得到左子树中的节点数目
            size_left_subtree = inorder_root - inorder_left
            # 递归地构造左子树，并连接到根节点
            # 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素
            root.left = myBuildTree(preorder_left + 1, preorder_left + size_left_subtree, inorder_left, inorder_root - 1)
            # 递归地构造右子树，并连接到根节点
            # 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素
            root.right = myBuildTree(preorder_left + size_left_subtree + 1, preorder_right, inorder_root + 1, inorder_right)
            return root

        n = len(preorder)
        # 构造哈希映射，帮助我们快速定位根节点
        index = {element: i for i, element in enumerate(inorder)}
        return myBuildTree(0, n - 1, 0, n - 1)
</code></pre>

<p>复杂度分析</p>
<blockquote>
<p>时间复杂度:O(n),其中n是树中的节点个数。</p>
<p>空间复杂度:O(n),除去返回的答案需要的O(n)空间之外,我们还需要使用O(n)的空间存储哈希映射,以及O(h)(其中h是树的高度)的空间表示递归时栈空间。这里 h &lt; n,所以总空间复杂度为O(n)。</p>
</blockquote>
<ul>
<li><strong>方法二:迭代</strong></li>
</ul>
<p>思路:迭代法是一种非常巧妙的实现方法。</p>
<p>对于前序遍历中的任意两个连续节点u和v,根据前序遍历的流程,我们可以知道u和v只有两种可能的关系:</p>
<blockquote>
<p>v是u的左儿子。这是因为在遍历到u之后,下一个遍历的节点就是u的左儿子,即v;</p>
<p>u没有左儿子,并且v是u的某个祖先节点(或者u本身)的右儿子。如果u没有左儿子,那么下一个遍历的节点就是u的右儿子。如果u没有右儿子,我们就会向上回溯,直到遇到第一个有右儿子(且u不在它的右儿子的子树中)的节点<span><span class="MathJax_Preview">u_a</span><script type="math/tex">u_a</script></span>,那么v就是<span><span class="MathJax_Preview">u_a</span><script type="math/tex">u_a</script></span>u的右儿子。</p>
</blockquote>
<p>第二种关系看上去有些复杂。我们举一个例子来说明其正确性,并在例子中给出我们的迭代算法。例子</p>
<p>我们以树</p>
<pre><code>        3
       / \
      9  20
     /  /  \
    8  15   7
   / \
  5  10
 /
4
</code></pre>

<p>为例，它的前序遍历和中序遍历分别为</p>
<pre><code>preorder = [3, 9, 8, 5, 4, 10, 20, 15, 7]
inorder = [4, 5, 8, 10, 9, 3, 15, 20, 7]
</code></pre>

<p>我们用一个栈stack来维护当前节点的所有还没有考虑过右儿子的祖先节点,栈顶就是当前节点。也就是说,只有在栈中的节点才可能连接一个新的右儿子。同时,我们用一个指针index指向中序遍历的某个位置,初始值为0。index对应的节点是当前节点不断往左走达到的最终节点,这也是符合中序遍历的,它的作用在下面的过程中会有所体现。</p>
<p>首先我们将根节点3入栈,再初始化index所指向的节点为4,随后对于前序遍历中的每个节点,我们依此判断它是栈顶节点的左儿子，还是栈中某个节点的右儿子。</p>
<p>我们遍历9。9一定是栈顶节点3的左儿子。我们使用反证法,假设9是3的右儿子,那么3没有左儿子,index应该恰好指向3,但实际上为4,因此产生了矛盾。所以我们将9作为3的左儿子,并将9入栈。</p>
<pre><code>stack = [3, 9]
index -&gt; inorder[0] = 4
</code></pre>

<p>我们遍历8,5和4。同理可得它们都是上一个节点(栈顶节点)的左儿子,所以它们会依次入栈。</p>
<pre><code>stack = [3, 9, 8, 5, 4]
index -&gt; inorder[0] = 4
</code></pre>

<p>我们遍历10,这时情况就不一样了。我们发现index恰好指向当前的栈顶节点4,也就是说4没有左儿子,那么10必须为栈中某个节点的右儿子。那么如何找到这个节点呢?栈中的节点的顺序和它们在前序遍历中出现的顺序是一致的,而且每一个节点的右儿子都还没有被遍历过,那么这些节点的顺序和它们在中序遍历中出现的顺序一定是相反的。</p>
<p>这是因为栈中的任意两个相邻的节点,前者都是后者的某个祖先。并且我们知道,栈中的任意一个节点的右儿子还没有被遍历过,说明后者一定是前者左儿子的子树中的节点,那么后者就先于前者出现在中序遍历中。</p>
<p>因此我们可以把index不断向右移动,并与栈顶节点进行比较。如果index对应的元素恰好等于栈顶节点,那么说明我们在中序遍历中找到了栈顶节点,所以将index增加1并弹出栈顶节点,直到index对应的元素不等于栈顶节点。按照这样的过程,我们弹出的最后一个节点x就是10的双亲节点,这是因为10出现在了x与x在栈中的下一个节点的中序遍历之间,因此10就是x的右儿子。</p>
<p>回到我们的例子，我们会依次从栈顶弹出4,5和8,并且将index向右移动了三次。我们将10作为最后弹出的节点8的右儿子,并将10 入栈。</p>
<pre><code>stack = [3, 9, 10]
index -&gt; inorder[3] = 10
</code></pre>

<p>我们遍历20。同理,index恰好指向当前栈顶节点10,那么我们会依次从栈顶弹出10,9和3,并且将index向右移动了三次。我们将20作为最后弹出的节点3的右儿子,并将20入栈。</p>
<pre><code>stack = [20]
index -&gt; inorder[6] = 15
</code></pre>

<p>我们遍历15,将15作为栈顶节点20的左儿子,并将15入栈。</p>
<pre><code>stack = [20, 15]
index -&gt; inorder[6] = 15
</code></pre>

<p>我们遍历7。index恰好指向当前栈顶节点15,那么我们会依次从栈顶弹出15和20,并且将index向右移动了两次。我们将7作为最后弹出的节点20的右儿子,并将7入栈。</p>
<pre><code>stack = [7]
index -&gt; inorder[8] = 7
</code></pre>

<p>此时遍历结束,我们就构造出了正确的二叉树。</p>
<p>我们归纳出上述例子中的算法流程:</p>
<blockquote>
<p>我们用一个栈和一个指针辅助进行二叉树的构造。初始时栈中存放了根节点(前序遍历的第一个节点),指针指向中序遍历的第一个节点;</p>
<p>我们依次枚举前序遍历中除了第一个节点以外的每个节点。如果index恰好指向栈顶节点,那么我们不断地弹出栈顶节点并向右移动index,并将当前节点作为最后一个弹出的节点的右儿子；如果index和栈顶节点不同,我们将当前节点作为栈顶节点的左儿子;</p>
</blockquote>
<p>无论是哪一种情况,我们最后都将当前的节点入栈。最后得到的二叉树即为答案。</p>
<pre><code class="python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; TreeNode:
        if not preorder:
            return None

        root = TreeNode(preorder[0])
        stack = [root]
        inorderIndex = 0
        for i in range(1, len(preorder)):
            preorderVal = preorder[i]
            node = stack[-1]
            if node.val != inorder[inorderIndex]:
                node.left = TreeNode(preorderVal)
                stack.append(node.left)
            else:
                while stack and stack[-1].val == inorder[inorderIndex]:
                    node = stack.pop()
                    inorderIndex += 1
                node.right = TreeNode(preorderVal)
                stack.append(node.right)

        return root
</code></pre>

<p>复杂度分析</p>
<blockquote>
<p>时间复杂度:O(n)其中n是树中的节点个数。</p>
<p>空间复杂度:O(n),除去返回的答案需要的O(n)空间之外,我们还需要使用O(h)(其中h是树的高度)的空间存储栈。这里h &lt; n,所以(在最坏情况下)总空间复杂度为O(n)。</p>
</blockquote>
<p>作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution/cong-qian-xu-yu-zhong-xu-bian-li-xu-lie-gou-zao-9/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>

  <br>
    <style>
blockquote{
    font-size: 99%;
}
</style>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  CommonHTML: {
    scale: 100
  }
});
</script>
<script type="text/javascript" async
src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


    
    
      
    

    <br>
</div>

</body>
</html>