# 计算机概论
## 一、计算机设备

### 1.1 CPU

CPU的全称是Central Processing Unit,它是你的电脑中最硬核的组件。CPU是能够让你的计算机叫计算机的核心组件,但是它却不能代表你的电脑,CPU与计算机的关系就相当于大脑和人的关系。它是一种小型的计算机芯片,它嵌入在台式机、笔记本电脑或者平板电脑的主板上。通过在单个计算机芯片上放置数十亿个微型晶体管来构建CPU。这些晶体管使它能够执行运行存储在系统内存中的程序所需的计算,也就是说CPU决定了你电脑的计算能力。

![](http://pic3.zhimg.com/80/v2-770bccc2c2c7b9bec2687e0bf0112f32_hd.jpg)

CPU的核心是从程序或应用程序获取指令并执行计算。此过程可以分为三个关键阶段:提取、解码和执行。CPU从系统的RAM中提取指令,然后解码该指令的实际内容,然后再由CPU的相关部分执行该指令。

RAM,随机存取存储器(英语:Random Access Memory,缩写RAM),也叫主存,是与CPU直接交换数据的内部存储器。它可以随时读写(刷新时除外),而且速度很快,通常作为操作系统或其他正在运行中的程序的临时数据存储介质。

下图展示了一般程序的运行流程(以C语言为例),可以说了解程序的运行流程是掌握程序运行机制的基础和前提。

![](http://pic2.zhimg.com/v2-159c3df2e62421c6a153c0106f82e821_r.jpg)

在这个流程中,CPU负责的就是解释和运行最终转换成机器语言的内容。CPU主要由两部分构成:控制单元和算术逻辑单元(ALU)。

> 控制单元:从内存中提取指令并解码执行
> 
> 算数逻辑单元(ALU):处理算数和逻辑运算

CPU是计算机的心脏和大脑,它和内存都是由许多晶体管组成的电子部件。它接收数据输入,执行指令并处理信息。它与输入/输出(I/O)设备进行通信,这些设备向CPU发送数据和从CPU接收数据。

从功能来看,CPU的内部由寄存器、控制器、运算器和时钟四部分组成,各部分之间通过电信号连通。

![](http://pic2.zhimg.com/v2-7b2a3ed45a401226a002b00444924331_r.jpg)

> **寄存器** 是中央处理器内的组成部分,它们可以用来暂存指令、数据和地址。可以将其看作是内存的一种。根据种类的不同,一个CPU内部会有20-100个寄存器
> 
> **控制器** 负责把内存上的指令、数据读入寄存器,并根据指令的结果控制计算机
> 
> **运算器** 负责运算从内存中读入寄存器的数据
> 
> **时钟** 负责发出CPU开始计时的时钟信号

接下来简单解释一下内存,为什么说CPU需要讲一下内存呢,因为内存是与CPU进行沟通的桥梁。计算机所有程序的运行都是在内存中运行的,内存又被称为主存,其作用是存放CPU中的运算数据,以及与硬盘等外部存储设备交换的数据。只要计算机在运行中,CPU就会把需要运算的数据调到主存中进行运算,当运算完成后CPU再将结果传送出来,主存的运行也决定了计算机的稳定运行。

主存通过控制芯片与CPU进行相连,由可读写的元素构成,每个字节(1 byte=8 bits)都带有一个地址编号,注意是一个字节,而不是一个位。CPU通过地址从主存中读取数据和指令,也可以根据地址写入数据。注意一点:当计算机关机时,内存中的指令和数据也会被清除。

* **CPU是寄存器的集合体**

在CPU的四个结构中,我们程序员只需要了解寄存器就可以了,其余三个不用过多关注,为什么这么说?因为程序是把寄存器作为对象来描述的。

说到寄存器,就不得不说到汇编语言,说到汇编语言,就不得不说到高级语言,说到高级语言就不得不牵扯出语言这个概念。

> * **计算机语言**

我们生而为人最明显的一个特征是我们能通过讲话来实现彼此的交流,但是计算机听不懂你说的话,你要想和他交流必须按照计算机指令来交换,这就涉及到语言的问题,计算机是由二进制构成的,它只能听的懂二进制也就是机器语言,但是普通人是无法看懂机器语言的,这个时候就需要一种电脑既能识别,人又能理解的语言,最先出现的就是汇编语言。但是汇编语言晦涩难懂,所以又出现了像是C,C++,Java的这种高级语言。

所以计算机语言一般分为两种:低级语言(机器语言,汇编语言)和高级语言。使用高级语言编写的程序,经过编译转换成机器语言后才能运行,而汇编语言经过汇编器才能转换为机器语言。

> * **汇编语言**

首先来看一段用汇编语言表示的代码清单

```c
mov eax, dword ptr [ebp-8]      /* 把数值从内存复制到eax */
add eax, dword ptr [ebp-0Ch]    /* 把eax的数值和内存的数值相加 */
mov dword ptr [ebp-4], eax      /* 把eax的数值(上一步的结果)存储在内存中 */
```

这是采用汇编语言(assembly)编写程序的一部分。汇编语言采用助记符(memonic)来编写程序,每一个原本是电信号的机器语言指令会有一个与其对应的助记符,例如mov,add分别是数据的存储(move)和相加(addition)的简写。汇编语言和机器语言是一一对应的,这一点和高级语言有很大的不同,通常我们将汇编语言编写的程序转换为机器语言的过程称为汇编;反之,机器语言转化为汇编语言的过程称为反汇编。

汇编语言能够帮助你理解计算机做了什么工作,机器语言级别的程序是通过寄存器来处理的,上面代码中的eax,ebp都是表示的寄存器,是CPU内部寄存器的名称,所以可以说CPU是一系列寄存器的集合体。在内存中的存储通过地址编号来表示,而寄存器的种类则通过名字来区分。

不同类型的CPU,其内部寄存器的种类,数量以及寄存器存储的数值范围都是不同的。不过,根据功能的不同,可以将寄存器划分为下面这几类:

![](http://pic2.zhimg.com/v2-240354c077a97ee549df0de631b40df9_r.jpg)

其中程序计数器、累加寄存器、标志寄存器、指令寄存器和栈寄存器都只有一个,其他寄存器一般有多个。

![](https://pic1.zhimg.com/v2-dd9c7504648bce2583bc764b0855ddd4_r.jpg)

> * **程序计数器**

程序计数器(Program Counter)是用来存储下一条指令所在单元的地址。程序执行时,PC的初值为程序第一条指令的地址,在顺序执行程序时,控制器首先按程序计数器所指出的指令地址从内存中取出一条指令,然后分析和执行该指令,同时将PC的值加1指向下一条要执行的指令。

我们还是以一个事例为准来详细的看一下程序计数器的执行过程

![](https://pic2.zhimg.com/v2-0f4f4a071c3be93a9effc14544d0cf4d_r.jpg)

这是一段进行相加的操作,程序启动,在经过编译解析后会由操作系统把硬盘中的程序复制到内存中,示例中的程序是将123和456执行相加操作,并将结果输出到显示器上。由于使用机器语言难以描述,所以这是经过翻译后的结果,实际上每个指令和数据都可能分布在不同的地址上,但为了方便说明,把组成一条指令的内存和数据放在了一个内存地址上。

地址0100是程序运行的起始位置。Windows等操作系统把程序从硬盘复制到内存后,会将程序计数器作为设定为起始位置0100,然后执行程序,每执行一条指令后,程序计数器的数值会增加1(或者直接指向下一条指令的地址),然后CPU就会根据程序计数器的数值,从内存中读取命令并执行,也就是说,程序计数器控制着程序的流程。

> * **条件分支和循环机制**

我们都学过高级语言,高级语言中的条件控制流程主要分为三种:顺序执行、条件分支、循环判断三种,顺序执行是按照地址的内容顺序的执行指令。条件分支是根据条件执行任意地址的指令,循环是重复执行同一地址的指令。

顺序执行的情况比较简单,每执行一条指令程序计数器的值就是+1,条件和循环分支会使程序计数器的值指向任意的地址,这样一来,程序便可以返回到上一个地址来重复执行同一个指令,或者跳转到任意指令。

下面以条件分支为例来说明程序的执行过程(循环也很相似)

![](http://pic3.zhimg.com/v2-c3c291167d68e17d4a6e07c81b533f36_r.jpg)

程序的开始过程和顺序流程是一样的,CPU从0100处开始执行命令,在0100和0101都是顺序执行,PC的值顺序+1,执行到0102地址的指令时,判断0106寄存器的数值大于0,跳转(jump)到0104地址的指令,将数值输出到显示器中,然后结束程序,0103的指令被跳过了,这就和我们程序中的if()判断是一样的,在不满足条件的情况下,指令会直接跳过。所以PC的执行过程也就没有直接+1,而是下一条指令的地址。

> * **标志寄存器**

条件和循环分支会使用到jump(跳转指令),会根据当前的指令来判断是否跳转,上面我们提到了标志寄存器,无论当前累加寄存器的运算结果是正数、负数还是零,标志寄存器都会将其保存(也负责溢出和奇偶校验)。

> **溢出(overflow)** :是指运算的结果超过了寄存器的长度范围
> 
> **奇偶校验(parity check)** :是指检查运算结果的值是偶数还是奇数

CPU在进行运算时,标志寄存器的数值会根据当前运算的结果自动设定,运算结果的正、负和零三种状态由标志寄存器的三个位表示。标志寄存器的第一个字节位、第二个字节位、第三个字节位各自的结果都为1时,分别代表着正数、零和负数。

![](http://pic3.zhimg.com/v2-979d0ce2cb7ea338e9bcd168465ee0fa_r.jpg)

CPU的执行机制比较有意思,假设累加寄存器中存储的XXX和通用寄存器中存储的YYY做比较,执行比较的背后,CPU的运算机制就会做减法运算。而无论减法运算的结果是正数、零还是负数,都会保存到标志寄存器中。结果为正表示XXX比YYY大,结果为零表示XXX和YYY相等,结果为负表示XXX比YYY小。程序比较的指令,实际上是在CPU内部做减法运算。

* **函数调用机制**

接下来,我们继续介绍函数调用机制,哪怕是高级语言编写的程序,函数调用处理也是通过把程序计数器的值设定成函数的存储地址来实现的。函数执行跳转指令后,必须进行返回处理,单纯的指令跳转没有意义,下面是一个实现函数跳转的例子

![](http://pic3.zhimg.com/v2-e6e79c501c3f477516207c537426f4a6_r.jpg)

图中将变量a和b分别赋值为123和456,调用MyFun(a,b)方法,进行指令跳转。图中的地址是将C语言编译成机器语言后运行时的地址,由于1行C程序在编译后通常会变为多行机器语言,所以图中的地址是分散的。在执行完MyFun(a,b)指令后,程序会返回到MyFun(a,b)的下一条指令,CPU继续执行下面的指令。

函数的调用和返回很重要的两个指令是call和return指令,再将函数的入口地址设定到程序计数器之前,call指令会把调用函数后要执行的指令地址存储在名为栈的主存内。函数处理完毕后,再通过函数的出口来执行return指令。return指令的功能是把保存在栈中的地址设定到程序计数器。MyFun函数在被调用之前,0154地址保存在栈中,MyFun函数处理完成后,会把0154的地址保存在程序计数器中。这个调用过程如下

![](http://pic4.zhimg.com/v2-4265e6cbeefc1b80ac7584f77c509bf3_r.jpg)

在一些高级语言的条件或者循环语句中,函数调用的处理会转换成call指令,函数结束后的处理则会转换成return指令。

* **通过地址和索引实现数组**

接下来我们看一下基址寄存器和变址寄存器,通过这两个寄存器,我们可以对主存上的特定区域进行划分,来实现类似数组的操作,首先,我们用十六进制数将计算机内存上的00000000-FFFFFFFF的地址划分出来。那么,凡是该范围的内存地址,只要有一个32位的寄存器,便可查看全部地址。但如果想要想数组那样分割特定的内存区域以达到连续查看的目的的话,使用两个寄存器会更加方便。

例如我们用两个寄存器(基址寄存器和变址寄存器)来表示内存的值

![](http://pic1.zhimg.com/v2-41538e08f444feb83cfe015dc687f11c_r.jpg)

这种表示方式很类似数组的构造,数组是指同样长度的数据在内存中进行连续排列的数据构造。用数组名表示数组全部的值,通过索引来区分数组的各个数据元素,例如:`a[0]-a[4]`,`[]`内的`0-4`就是数组的下标。

* **CPU指令执行过程**

那么CPU是如何执行一条条的指令的呢?几乎所有的冯·诺伊曼型计算机的CPU,其工作都可以分为5个阶段:取指令、指令译码、执行指令、访存取数、结果写回。

> **取指令阶段** 是将内存中的指令读取到CPU中寄存器的过程,程序寄存器用于存储下一条指令所在的地址
> 
> **指令译码阶段** 在取指令完成后,立马进入指令译码阶段,在指令译码阶段,指令译码器按照预定的指令格式,对取回的指令进行拆分和解释,识别区分出不同的指令类别以及各种获取操作数的方法。
>
> **执行指令阶段** 译码完成后,就需要执行这一条指令了,此阶段的任务是完成指令所规定的各种操作,具体实现指令的功能
> 
> **访问取数阶段** 根据指令的需要,有可能需要从内存中提取数据,此阶段的任务是:根据指令地址码,得到操作数在主存中的地址,并从主存中读取该操作数用于运算
> **结果写回阶段** 作为最后一个阶段,结果写回(Write Back,WB)阶段把执行指令阶段的运行结果数据"写回"到某种存储形式:结果数据经常被写到CPU的内部寄存器中,以便被后续的指令快速地存取;

## 二、互联网知识

### 2.1 统一资源标识符

在计算机术语中,统一资源标识符(Uniform Resource Identifier,缩写URI)是一个用于标识某一互联网资源名称的字符串。该种标识允许用户对网络中(一般指万维网)的资源通过特定的协议进行交互操作。URI的最常见的形式是统一资源定位符(Uniform Resource Locator,缩写为URL),经常指定为非正式的网址。更罕见的用法是统一资源名称(URN),其目的是通过提供一种途径,用于在特定的名字空间资源的标识,以补充网址。

**与URL和URN的关系:**

![](https://upload.wikimedia.org/wikipedia/commons/thumb/c/c3/URI_Euler_Diagram_no_lone_URIs.svg/360px-URI_Euler_Diagram_no_lone_URIs.svg.png)

URI可被视为定位符(URL),名称(URN)或两者兼备。统一资源名(URN)如同一个人的名称,而统一资源定位符(URL)代表一个人的住址。换言之,URN定义某事物的身份,而URL提供查找该事物的方法。

用于标识唯一书目的ISBN系统是一个典型的URN使用范例。例如,ISBN 0-486-27557-4无二义性地标识出莎士比亚的戏剧《罗密欧与朱丽叶》的某一特定版本。为获得该资源并阅读该书,人们需要它的位置,也就是一个URL地址。在类Unix操作系统中,一个典型的URL地址可能是一个文件目录,例如file:///home/username/RomeoAndJuliet.pdf。该URL标识出存储于本地硬盘中的电子书文件。因此,URL和URN有着互补的作用。

**技术观点:** URL是一种URI,它标识一个互联网资源,并指定对其进行操作或获取该资源的方法。可能通过对主要访问手段的描述,也可能通过网络“位置”进行标识。例如,`http://www.wikipedia.org/`这个URL,标识一个特定资源(首页)并表示该资源的某种形式(例如以编码字符表示的,首页的HTML代码)是可以通过HTTP协议从www.wikipedia.org这个网络主机获得的。URN是基于某名字空间通过名称指定资源的URI。人们可以通过URN来指出某个资源,而无需指出其位置和获得方式。资源无需是基于互联网的。例如,URN urn:ISBN 0-395-36341-1指定标识系统(即国际标准书号ISBN)和某资源在该系统中的唯一表示的URI。它可以允许人们在不指出其位置和获得方式的情况下谈论这本书。


**文法:** URI文法由URI协议名(例如"http","ftp","mailto"或"file"),一个冒号,和协议对应的内容所构成。特定的协议定义了协议内容的语法和语义,而所有的协议都必须遵循一定的URI文法通用规则,亦即为某些专门目的保留部分特殊字符。URI文法同时也就各种原因对协议内容加以其他的限制,例如,保证各种分层协议之间的协同性。百分号编码也为URI提供附加信息。

通用URI的格式如下:

```js
scheme:[//[user[:password]@]host[:port]][/path][?query][#fragment]
```

[URL](https://www.ietf.org/rfc/rfc1738.txt)被冒号分成了两部分,前面是scheme(方案),后面是scheme的描述部分。

scheme只能由以下元素组成:a-z(不区分大小写),数字,字符(加号+,句号.,连字符-)。shceme目前有这些类型:

| 类型 | 说明 |
| --- | --- |
| ftp | File Transfer protocol(文件传输协议) |
| http | Hypertext Transfer Protocol(超文本传输协议) |
| gopher | The Gopher protocol(Gopher协议) |
| mailto | Electronic mail address(电子邮件地址) |
| news | USENET news(USENET新闻) |
| nntp | USENET news using NNTP access(使用NNTP访问的USENET新闻) |
| telnet | Reference to interactive sessions(交互式会话访问) |
| wais | Wide Area Information Servers(广域信息服务系统) |
| file | Host-specific file names(特殊主机文件名) |
| prospero | Prospero Directory Service(prospero目录服务) |

当然,上述的scheme大部分是应用非常广泛的,我们可以自定义scheme,只要解析器支持即可,比如我们公司就根据URL设计了一条App跳转专用的URL,方便服务器分发跳转路径。

scheme的描述部分也可以拆解成以下的结构:

```js
<user>:<password>@<host>:<port>/<url-path>
```

根据方案的不同,这些部分是可以部分省略的,比如http通常不需要user和password。我们来依次看这些组成部分:

| 字段 | 说明 |
| --- | --- |
| user | 这个比较好理解,就是用户名,没有则省略 |
| password | 用户密码 |
| host | host(主机)是一个IP地址,由四组十进制数字以.分割组合而成。现在很多对客的地址都是用了域名,然后再通过DNS解析.DNS可以理解为将难以记住的ip地址和单词等组成的域名做映射,从而方便用户的使用。记住`https://www.baidu.com`可比记住192.292.22.22容易多了。很多的公司在使用的时候也会做DNS优化,即客户端等发出请求的时候,直接向对应的ip发送,从而节省DNS解析的时间,加快用户访问速度,有兴趣的可以网络搜索下 |
| port | port(端口)是用来区分不同的网络服务的,从而实现在一个IP的基础上,提供多个网络服务 |
| url-path | url路径提供了如何对特定资源访问的详细信息,一般都是文件夹的路径 |

例子:下图展示了两个URI例子及它们的组成部分。

![](http://wx2.sinaimg.cn/nmw690/006HJ6Ndly1g00hu1iyaej31ag0diwg5.jpg)


**URI引用:**

另一种类型的字符串——"URI引用"——代表一个URI并(相应地)代表被该URI所标识的资源。非正式使用中,URI和URI引用的区别少有被提及,但协议文档自然不应允许歧义的存在。

URI引用可取用的格式包括完整URI,URI中协议特定的部分,或其后附部分——甚至是空字符串。一个可选的片段标识符以#开头,可出现在URI引用的结尾。引用中,#之前的部分间接标识一个资源,而片段标识符则标识资源的某个部分。

为从URI引用获得URI,软件将URI引用与一个绝对"基址"基于一个固定算法合并,并转换为"绝对"形式。系统将URI引用视作相对于基址URI,虽然在绝对引用的情况下基址并无意义。基址URI一般标识包含URI引用的文档,但仍可被文档内包含的声明,或外部数据传输协议所包括的声明改写。若基址URI包括一个片段标识符,则该标识符在合并过程中被忽略。如果在URI引用中出现片段标识符,则在合并过程中被保留。

网络文档标记语言时常使用URI引用指向其它资源,如外部文档或同一逻辑文档的其他部分等。在HTML中,img元素的src属性值是URI引用,a或link元素的href属性值亦如是。在XML中,在一个DTD中的SYSTEM关键字之后出现的系统描述符是一个无片段的URI引用。在XSLT中,xsl:import元素/指令的href属性值是一个URI引用,document()函数的第一个参数与之相仿。

```js
# 绝对URI
http://example.org/absolute/URI/with/absolute/path/to/resource.txt
ftp://example.org/resource.txt
urn:issn:1535-3613
# URI引用
http://en.wikipedia.org/wiki/URI#Examples_of_URI_references ("http" 指定协议名, "en.wikipedia.org"是“典据”, "/wiki/URI"是指向英文维基页面的“路径”,而"#Examples_of_URI_references"是指向英文维基页面相应片段的“片段”。)
http://example.org/absolute/URI/with/absolute/path/to/resource.txt
//example.org/scheme-relative/URI/with/absolute/path/to/resource.txt
/relative/URI/with/absolute/path/to/resource.txt
relative/path/to/resource.txt
../../../resource.txt
./resource.txt#frag01
resource.txt
#frag01
(空字符串)
```

**URI解析:** "解析"一个URI意味着将一个相对URI引用转换为绝对形式,或者通过尝试获取一个可解引URI或一个URI引用所代表的资源来解引用这个URI。文档处理软件的"解析"部分通常同时提供这两种功能。

一个URI引用可以是一个同文档引用:一个指向包含URI引用自身的文档的引用。文档处理软件可有效地使用其当前的文档资源来完成对于同文档引用的解析而不需要重新获取一份资源。这只是一个建议——文档处理软件自然可以选用另外的方法来决定是否获取新资源。

### 2.2 TCP/IP模型

TCP/IP协议模型(Transmission Control Protocol/Internet Protocol),包含了一系列构成互联网基础的网络协议,是Internet的核心协议。

基于TCP/IP的参考模型将协议分成四个层次,它们分别是链路层、网络层、传输层和应用层。下图表示TCP/IP模型与OSI模型各层的对照关系。

![](https://pic4.zhimg.com/80/v2-d6a75e961a9d13228f57691662a5d3ab_1440w.jpg)

TCP/IP协议族按照层次由上到下,层层包装。最上面的是应用层,这里面有http,ftp等等我们熟悉的协议。而第二层则是传输层,著名的TCP和UDP协议就在这个层次。第三层是网络层,IP协议就在这里,它负责对数据加上IP地址和其他的数据以确定传输的目标。第四层是数据链路层,这个层次为待传送的数据加入一个以太网协议头,并进行CRC编码,为最后的数据传输做准备。

![](https://pic1.zhimg.com/v2-d31f27ac9bb86500477158bb4d7eba84_r.jpg)

上图清楚地表示了TCP/IP协议中每个层的作用,而TCP/IP协议通信的过程其实就对应着数据入栈与出栈的过程。入栈的过程,数据发送方每层不断地封装首部与尾部,添加一些传输的信息,确保能传输到目的地。出栈的过程,数据接收方每层不断地拆除首部与尾部,得到最终传输的数据。

![](https://pic4.zhimg.com/v2-6cacedff60b984ce8063f76c4f876da3_r.jpg)

上图以HTTP协议为例,具体说明。

* **数据链路层**

物理层负责0、1比特流与物理设备电压高低、光的闪灭之间的互换。数据链路层负责将0、1序列划分为数据帧从一个节点传输到临近的另一个节点,这些节点是通过MAC来唯一标识的(MAC,物理地址,一个主机会有一个MAC地址)。

![](https://pic3.zhimg.com/80/v2-14f2606cb192eb5fcfde945d334f7e92_1440w.jpg)

> 封装成帧:把网络层数据报加头和尾,封装成帧,帧头中包括源`MAC`地址和目的`MAC`地址。
>
> 透明传输:零比特填充、转义字符。
>
> 可靠传输: 在出错率很低的链路上很少用,但是无线链路WLAN会保证可靠传输。
>
> 差错检测(CRC):接收者检测错误,如果发现差错,丢弃该帧。

* **网络层**

**IP协议**

在数据链路层中我们一般通过MAC地址来识别不同的节点,而在IP层我们也要有一个类似的地址标识,这就是IP地址。32位IP地址分为网络位和地址位,这样做可以减少路由器中路由表记录的数目,有了网络地址,就可以限定拥有相同网络地址的终端都在同一个范围内,那么路由表只需要维护一条这个网络地址的方向,就可以找到相应的这些终端了。

> A类IP地址:0.0.0.0~127.0.0.0
>
> B类IP地址:128.0.0.1~191.255.0.0
>
> C类IP地址:192.168.0.0~239.255.255.0

![](https://pic2.zhimg.com/v2-9bd7f326cf85b36bdb1165109fb535c1_r.jpg)

八位的TTL字段,这个字段规定该数据包在穿过多少个路由之后才会被抛弃。某个IP数据包每穿过一个路由器,该数据包的TTL数值就会减少1,当该数据包的TTL成为零,它就会被自动抛弃。

这个字段的最大值也就是255,也就是说一个协议包也就在路由器里面穿行255次就会被抛弃了,根据系统的不同,这个数字也不一样,一般是32或者是64。

**ARP及RARP协议**

ARP是根据IP地址获取MAC地址的一种协议。ARP(地址解析)协议是一种解析协议,本来主机是完全不知道这个IP对应的是哪个主机的哪个接口,当主机要发送一个IP包的时候,会首先查一下自己的ARP高速缓存(就是一个IP-MAC地址对应表缓存)。

如果查询的IP－MAC值对不存在,那么主机就向网络发送一个ARP协议广播包,这个广播包里面就有待查询的IP地址,而直接收到这份广播的包的所有主机都会查询自己的IP地址,如果收到广播包的某一个主机发现自己符合条件,那么就准备好一个包含自己的MAC地址的ARP包传送给发送ARP广播的主机。

而广播主机拿到ARP包后会更新自己的ARP缓存(就是存放IP-MAC对应表的地方)。发送广播的主机就会用新的ARP缓存数据准备好数据链路层的的数据包发送工作。

RARP协议的工作与此相反,不做赘述。

**ICMP协议**

IP协议并不是一个可靠的协议,它不保证数据被送达,那么,自然的,保证数据送达的工作应该由其他的模块来完成。其中一个重要的模块就是ICMP(网络控制报文)协议。ICMP不是高层协议,而是IP层的协议。

当传送IP数据包发生错误。比如主机不可达,路由不可达等等,ICMP协议将会把错误信息封包,然后传送回给主机。给主机一个处理错误的机会,这 也就是为什么说建立在IP层以上的协议是可能做到安全的原因。

**检测工具**

ping可以说是ICMP的最著名的应用,是TCP/IP协议的一部分。利用"ping"命令可以检查网络是否连通,可以很好地帮助我们分析和判定网络故障。

例如:当我们某一个网站上不去的时候。通常会ping一下这个网站。ping会回显出一些有用的信息。一般的信息如下:

![](http://pic3.zhimg.com/80/v2-4d873acce057bdb9996dad9750b2f27e_1440w.jpg)

ping这个单词源自声纳定位,而这个程序的作用也确实如此,它利用ICMP协议包来侦测另一个主机是否可达。原理是用类型码为0的ICMP发请 求,受到请求的主机则用类型码为8的ICMP回应。ping程序来计算间隔时间,并计算有多少个包被送达。用户就可以判断网络大致的情况。我们可以看到, ping给出来了传送的时间和TTL的数据。

Traceroute是用来侦测主机到目的主机之间所经路由情况的重要工具,也是最便利的工具。

Traceroute的原理是非常非常的有意思,它收到到目的主机的IP后,首先给目的主机发送一个TTL=1的UDP数据包,而经过的第一个路由器收到这个数据包以后,就自动把TTL减1,而TTL变为0以后,路由器就把这个包给抛弃了,并同时产生一个主机不可达的ICMP数据报给主机。主机收到这个数据报以后再发一个TTL=2的UDP数据报给目的主机,然后刺激第二个路由器给主机发ICMP数据报。如此往复直到到达目的主机。这样,traceroute就拿到了所有的路由器IP。

**TCP/UDP**

TCP/UDP都是是传输层协议,但是两者具有不同的特性,同时也具有不同的应用场景,下面以图表的形式对比分析。

![](http://pic3.zhimg.com/v2-3cdbcf0100f88b32af1d2e0a52285c3a_r.jpg)

面向报文:面向报文的传输方式是应用层交给UDP多长的报文,UDP就照样发送,即一次发送一个报文。因此,应用程序必须选择合适大小的报文。若报文太长,则IP层需要分片,降低效率。若太短,会是IP太小。

面向字节流:面向字节流的话,虽然应用程序和TCP的交互是一次一个数据块(大小不等),但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲,当应用程序传送的数据块太长,TCP就可以把它划分短一些再传送。

TCP和UDP协议的一些应用

![](http://pic4.zhimg.com/v2-6cb1b65c9d1ae4c96914cd78e47da1ab_r.jpg)

什么时候应该使用TCP:当对网络通讯质量有要求的时候,比如:整个数据要准确无误的传递给对方,这往往用于一些要求可靠的应用,比如HTTP、HTTPS、FTP等传输文件的协议,POP、SMTP等邮件传输的协议。

什么时候应该使用UDP:当对网络通讯质量要求不高的时候,要求网络通讯速度能尽量的快,这时就可以使用UDP。

* **TCP连接的建立与终止**

**三次握手**

TCP是面向连接的,无论哪一方向另一方发送数据之前,都必须先在双方之间建立一条连接。在TCP/IP协议中,TCP协议提供可靠的连接服务,连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换 TCP窗口大小信息。

![](http://pic1.zhimg.com/80/v2-460c0ce6abfd79f18e35266ad5dbb6d4_1440w.jpg)

> 第一次握手: 建立连接。客户端发送连接请求报文段,将SYN位置为1,Sequence Number为x;然后,客户端进入`SYN_SEND`状态,等待服务器的确认;
>
> 第二次握手:服务器收到SYN报文段。服务器收到客户端的SYN报文段,需要对这个SYN报文段进行确认,设置Acknowledgment Number为x+1(Sequence Number+1);同时,自己自己还要发送SYN请求信息,将SYN位置为1,Sequence Number为y;服务器端将上述所有信息放到一个报文段(即SYN+ACK报文段)中,一并发送给客户端,此时服务器进入`SYN_RECV`状态;
>
> 第三次握手: 客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1,向服务器发送ACK报文段,这个报文段发送完毕以后,客户端和服务器端都进入ESTABLISHED状态,完成TCP三次握手。

为什么要三次握手:为了防止已失效的连接请求报文段突然又传送到了服务端,因而产生错误。

具体例子:"已失效的连接请求报文段"的产生在这样一种情况下:client发出的第一个连接请求报文段并没有丢失,而是在某个网络结点长时间的滞留了,以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后,就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段,同意建立连接。假设不采用“三次握手”,那么只要server发出确认,新的连接就建立了。由于现在client并没有发出建立连接的请求,因此不会理睬server的确认,也不会向server发送数据。但server却以为新的运输连接已经建立,并一直等待client发来数据。这样,server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况,client不会向server的确认发出确认。server由于收不到确认,就知道client并没有要求建立连接。”

**四次挥手**

当客户端和服务器通过三次握手建立了TCP连接以后,当数据传送完毕,肯定是要断开TCP连接的啊。那对于TCP的断开连接,这里就有了神秘的“四次分手”。

![](http://pic1.zhimg.com/80/v2-460c0ce6abfd79f18e35266ad5dbb6d4_1440w.jpg)

> 第一次分手: 主机1(可以使客户端,也可以是服务器端),设置Sequence Number,向主机2发送一个FIN报文段;此时,主机1进入`FIN_WAIT_1`状态;这表示主机1没有数据要发送给主机2了;
>
> 第二次分手: 主机2收到了主机1发送的FIN报文段,向主机1回一个ACK报文段,Acknowledgment Number为Sequence Number加1;主机1进入`FIN_WAIT_2`状态;主机2告诉主机1,我“同意”你的关闭请求;
>
> 第三次分手: 主机2向主机1发送FIN报文段,请求关闭连接,同时主机2进入`LAST_ACK`状态;
>
> 第四次分手: 主机1收到主机2发送的FIN报文段,向主机2发送ACK报文段,然后主机1进入`TIME_WAIT`状态;主机2收到主机1的ACK报文段以后,就关闭连接;此时,主机1等待2MSL后依然没有收到回复,则证明Server端已正常关闭,那好,主机1也可以关闭连接了。

为什么要四次分手?TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式,这就意味着,当主机1发出FIN报文段时,只是表示主机1已经没有数据要发送了,主机1告诉主机2,它的数据已经全部发送完毕了;但是,这个时候主机1还是可以接受来自主机2的数据;当主机2返回ACK报文段时,表示它已经知道主机1没有数据发送了,但是主机2还是可以发送数据到主机1的;当主机2也发送了FIN报文段时,这个时候就表示主机2也没有数据要发送了,就会告诉主机1,我也没有数据要发送了,之后彼此就会愉快的中断这次TCP连接。

* **TCP流量控制**

如果发送方把数据发送得过快,接收方可能会来不及接收,这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快,要让接收方来得及接收。

利用滑动窗口机制可以很方便地在TCP连接上实现对发送方的流量控制。

设A向B发送数据。在连接建立时,B告诉了A:“我的接收窗口是rwnd = 400”(这里的rwnd表示receiver window) 。因此,发送方的发送窗口不能超过接收方给出的接收窗口的数值。请注意,TCP的窗口单位是字节,不是报文段。假设每一个报文段为100字节长,而数据报文段序号的初始值设为1。大写ACK表示首部中的确认位ACK,小写ack表示确认字段的值ack。

![](http://pic3.zhimg.com/80/v2-3f201a9c8ec8ac605846af624e87ec0e_1440w.jpg)

从图中可以看出,B进行了三次流量控制。第一次把窗口减少到rwnd=300,第二次又减到了rwnd=100,最后减到rwnd=0,即不允许发送方再发送数据了。这种使发送方暂停发送的状态将持续到主机B重新发出一个新的窗口值为止。B向A发送的三个报文段都设置了ACK=1,只有在ACK=1时确认号字段才有意义。

TCP为每一个连接设有一个持续计时器(persistence timer)。只要TCP连接的一方收到对方的零窗口通知,就启动持续计时器。若持续计时器设置的时间到期,就发送一个零窗口控测报文段(携1字节的数据),那么收到这个报文段的一方就重新设置持续计时器。

* **TCP拥塞控制**

**慢开始和拥塞避免**

发送方维持一个拥塞窗口cwnd(congestion window)的状态变量。拥塞窗口的大小取决于网络的拥塞程度,并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口。

发送方控制拥塞窗口的原则是:只要网络没有出现拥塞,拥塞窗口就再增大一些,以便把更多的分组发送出去。但只要网络出现拥塞,拥塞窗口就减小一些,以减少注入到网络中的分组数。

**慢开始算法**

当主机开始发送数据时,如果立即所大量数据字节注入到网络,那么就有可能引起网络拥塞,因为现在并不清楚网络的负荷情况。

因此,较好的方法是先探测一下,即由小到大逐渐增大发送窗口,也就是说,由小到大逐渐增大拥塞窗口数值。

通常在刚刚开始发送报文段时,先把拥塞窗口cwnd设置为一个最大报文段MSS的数值。而在每收到一个对新的报文段的确认后,把拥塞窗口增加至多一个MSS的数值。用这样的方法逐步增大发送方的拥塞窗口cwnd,可以使分组注入到网络的速率更加合理。

![](http://pic1.zhimg.com/80/v2-3c66153a90845746b35e79218bdcd430_1440w.jpg)

每经过一个传输轮次,拥塞窗口cwnd就加倍。一个传输轮次所经历的时间其实就是往返时间RTT。不过“传输轮次”更加强调:把拥塞窗口cwnd所允许发送的报文段都连续发送出去,并收到了对已发送的最后一个字节的确认。

另,慢开始的“慢”并不是指cwnd的增长速率慢,而是指在TCP开始发送报文段时先设置cwnd=1,使得发送方在开始时只发送一个报文段(目的是试探一下网络的拥塞情况),然后再逐渐增大cwnd。

为了防止拥塞窗口cwnd增长过大引起网络拥塞,还需要设置一个慢开始门限ssthresh状态变量。慢开始门限ssthresh的用法如下:

> 当`cwnd<ssthresh`时,使用上述的慢开始算法。
>
> 当`cwnd>ssthresh`时,停止使用慢开始算法而改用拥塞避免算法。
>
> 当`cwnd=ssthresh`时,既可使用慢开始算法,也可使用拥塞控制避免算法。

**拥塞避免**

让拥塞窗口cwnd缓慢地增大,即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1,而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长,比慢开始算法的拥塞窗口增长速率缓慢得多。


无论在慢开始阶段还是在拥塞避免阶段,只要发送方判断网络出现拥塞(其根据就是没有收到确认),就要把慢开始门限ssthresh设置为出现拥塞时的发送 方窗口值的一半(但不能小于2)。然后把拥塞窗口cwnd重新设置为1,执行慢开始算法。

这样做的目的就是要迅速减少主机发送到网络中的分组数,使得发生 拥塞的路由器有足够时间把队列中积压的分组处理完毕。

如下图,用具体数值说明了上述拥塞控制的过程。现在发送窗口的大小和拥塞窗口一样大。

![](http://pic3.zhimg.com/80/v2-deb5779a8a9cbe34f7359742f56e1fca_1440w.jpg)

* **快重传和快恢复**

**快重传**

快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认(为的是使发送方及早知道有报文段没有到达对方)而不要等到自己发送数据时才进行捎带确认。

![](http://pic1.zhimg.com/80/v2-19a79f44076165f29a45a364906096b4_1440w.jpg)

接收方收到了M1和M2后都分别发出了确认。现在假定接收方没有收到M3但接着收到了M4。

显然,接收方不能确认M4,因为M4是收到的失序报文段。根据 可靠传输原理,接收方可以什么都不做,也可以在适当时机发送一次对M2的确认。

但按照快重传算法的规定,接收方应及时发送对M2的重复确认,这样做可以让 发送方及早知道报文段M3没有到达接收方。发送方接着发送了M5和M6。接收方收到这两个报文后,也还要再次发出对M2的重复确认。这样,发送方共收到了 接收方的四个对M2的确认,其中后三个都是重复确认。

快重传算法还规定,发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段M3,而不必 继续等待M3设置的重传计时器到期。

由于发送方尽早重传未被确认的报文段,因此采用快重传后可以使整个网络吞吐量提高约20%。

**快恢复**

与快重传配合使用的还有快恢复算法,其过程有以下两个要点:

![](http://pic1.zhimg.com/80/v2-cf3af75418ba1eb90d3ade5ebd205fd4_1440w.jpg)

> 当发送方连续收到三个重复确认,就执行“乘法减小”算法,把慢开始门限ssthresh减半。
>
> 与慢开始不同之处是现在不执行慢开始算法(即拥塞窗口cwnd现在不设置为1),而是把cwnd值设置为 慢开始门限ssthresh减半后的数值,然后开始执行拥塞避免算法(“加法增大”),使拥塞窗口缓慢地线性增大。

## 三、时间协议

### 3.1 格式标示符

常见的时间格式标识符:

| 符号 | 说明 |
| :--- | --- |
| %% | 显示一个百分号'%' |
| %a | 星期的简称,如:Sun/Mon/Tue/Wed/... |
| %A | 星期完整名字,如:Sunday/Monday/... |
| %b | 月份简称,如:Jan/Feb/... |
| %B | 月份全称,如:January/February/... |
| %c | 显示当前日期和时间,如:Thu Mar 3 23:05:25 2005 |
| %C | 世纪,如:现在是20世纪,输入date +"%C"显示20 |
| %d | 日期,如当前是8号,则显示:08  |
| %D | 完整日期,date +"%D"相当于date +"%m/%d/%y" |
| %e | 日期,用空格补全,而不是0,如当前日期:7号,则显示"7" |
| %F | 完整日期,相当于:date +"%Y-%m-%d" |
| %g | 年份后2位,如果是2017,则为:17 |
| %G | 年份全4位,如2017 |
| %h | 月份简称,如:Jan/Feb/Mar/...,跟%b相同 |
| %H | 小时(00/01/02/..23),24小时制 |
| %I | 小时(01/02/..12),12小时制  |
| %j | 一年的第几天(001/002/..366) |
| %k | 小时,填充空格,如(0/1/2/..23);相当于`%_H` |
| %l | 小时,填充空格(1/2/3/..12);相当于`%_I` |
| %m | 月份(01/02/03/..12) |
| %M | 分钟(00/01/02/..59) |
| %n | 换行,date +"%d%n%d",将会分成两行分别显示日期 |
| %N | 纳秒(000000000/000000001/..999999999) |
| %p | AM/PM,即上午或者下午 |
| %P | 跟%p意思一样,不过是小写字母,即am/pm |
| %r | 显示12小时制的当前时间,如:10:48:05 PM |
| %R | 24小时制的当前时间和分钟,相当于:%H:%M,22:49 |
| %s | 从1970-01-01 00:00:00UTC开始的秒数,相当于日期转时间戳 |
| %S | 秒(00/01/02/..60) |
| %t | 一个tab键,制表符 |
| %T | 当前时间,相当于:%H:%M:%S。如:22:52:07 |
| %u | 星期中的第几天(1/2/..7);1是星期一 |
| %U | 一年中的第几个星期(00..53),星期天作为一个星期的第一天 |
| %V | 一年中的第几个星期(ISO标准)(01..53),星期一作为一个星期的第一天 |
| %w | 星期中的第几天(0..6);0是星期天 |
| %W | 一年中的第几个星期(00..53),星期一作为一个星期的第一天 |
| %x | 当前日期(例如:03/07/17) |
| %X | 当前时间(例如:23:13:48) |
| %y | 年的后两位(00/02/..99) |
| %Y | 年,如:2017  |
| %z | `+hhmm`数字时区(例如:北京:+0800) |
| %:z | `+hh:mm`数字时区(例如:北京:+08:00) |
| %::z | `+hh:mm:ss`数字时区(例如:北京:+08:00:00) |
| %:::z | numerictime zone with:tonecessary precision(e.g.,-04,+05:30) |
| %Z | 字母时区缩写(如CST) |

### 3.2 date命令

* **显示当前时间和按指定格式显示时间**

```shell
date +"%Y/%m/%d %H:%m:%S"
```

* **时间解析,将输入的字符串解析为时间**

```shell
date -d "20170305"  //解析日期, 输出:Sun Mar  5 00:00:00 CST 2017。
date -d "03/05/2017"
date -d "2017/03/05 11:12:13" // 解析日期和时间, 输出: Sun Mar  5 11:12:13 CST 2017。
date -d "2017-03-05 21:12:17" +"%s" // 将输入时间转为时间戳,输出:1488719537。
date -d "2017-03-05 21:12:17" +"%Y/%m/%d %H:%M:%S"  // 时间格式转换,将输入日期转换为自定义格式。
```

* **时间数字、时间整数、时间戳转字符串和数字和字符串时间转换**

```shell
date --date @1488899583    // 将从1970-01-01 00:00:00 UTC开始的秒数,转为字符串时间
date --date @"1488899583"  // 同上,即时间戳转字符串,或者整数秒转字符串时间。
date +"%s"                 // 日期转时间戳,日期转整数。
```

* **设置当前时间**

```shell
date -s "2017/05/08 23:28:13"   // 设置日期和时间
date -s "2017/05/08" // 设置日期(注意,时间会同时被设置为00:00:00,慎用)。
date -s "23:28:13"   // 设置时间。
```

* **时间运算**

```shell
// 时间加减运算
// 直接用-d命令结合year/month/week/day/hour/minute/second, 单复数都行
date -d "+1 days" // 明天,当前时间加1天。
date -d "+2 days" // 后天,当前时间加2天。
date -d "+10 days" +"%Y%m%d %H:%M:%S" // 当前时间加10天,并按指定格式输出。
date -d "-1 days" // 昨天,当前时间减1天。
date -d "-2 days" // 前天,当前时间减2天。
date -d "2017/03/05 +1 days"    // 指定日期加1天。
date -d "2017/03/05 -1 days"    // 指定日期减1天。
date -d "2017/03/08 +600 seconds" // 指定日期加600秒。
date -d "2017/03/08 -600 seconds" // 指定日期减600秒。
date -d "2017/03/08 +600 minutes" // 指定日期加600分钟。
date -d "2017/03/08 -600 minutes" // 指定日期减600分钟。
date -d "2017/03/08 +10 year"     // 指定日期加10年。
date -d "Tue Mar 10 14:12:13 CST 2015  +1 days" // 指定日期时间,加一天。
date -d "15:21:11 03/18/2017  -1 days"  // 指定日期时间,减一天。注：时间放在日期的后面目前似乎不可用。
```

数字可以用next,last代替,明天,昨天也可以tomorrow，yesterday来制定

* **时间相关代码模版**

```shell
# 根据时间运行程序
startdate=2018090314
enddate=2018083022
for i in `seq 1 300`; do
    if [[ $startdate -lt $enddate ]]; then
        break
    fi

    # 拼接成YYYYmmdd HH的格式,否则使用下个命令中+%s,会无法转换
    startdate=${startdate:0:4}"-"${startdate:4:2}"-"${startdate:6:2}" "${startdate:8:2}
    # 转换成时间戳,+%s为时间格式
    startdate=$(date +%s -d "$startdate")
    # 每次执行后,开始日期减一个小时
    startdate=$(($startdate-1*60*60))
    # 时间戳转正常格式时间
    startdate=$(date +%Y%m%d%H -d "1970-01-01 UTC $startdate seconds")
    # 执行程序
    echo ${startdate}
done
```

### 3.3 python函数

#### 3.3.1 time模块

time模块中时间表现的格式主要有三种：

> * **timestamp时间戳**:时间戳表示的是从1970年1月1日00:00:00开始按秒计算的偏移量
> * **`struct_time`时间元组** 共有九个元素组。

```python
struct_time元组元素结构
    属性                            值
    tm_year（年）                  比如2011
    tm_mon（月）                   1 - 12
    tm_mday（日）                  1 - 31
    tm_hour（时）                  0 - 23
    tm_min（分）                   0 - 59
    tm_sec（秒）                   0 - 61
    tm_wday（weekday）             0 - 6（0表示周日）
    tm_yday（一年中的第几天）        1 - 366
    tm_isdst（是否是夏令时）        默认为-1
```

> * **format time格式化时间** 已格式化的结构使时间更具可读性。包括自定义格式和固定格式。

* **时间格式转换图**

![](http://images2015.cnblogs.com/blog/996085/201610/996085-20161026171443546-488752980.png)

```python
# 代码转化示例
import time

time.time()       # 生成timestamp : 1545018718.573361
time.localtime()  # 生成struct_time : time.struct_time(tm_year=2018, tm_mon=12, tm_mday=17, tm_hour=11, tm_min=56, tm_sec=8, tm_wday=0, tm_yday=351, tm_isdst=0)
time.mktime(time.localtime())    # struct_time to timestamp
time.localtime(time.time())      # timestamp to struct_time 本地时间

# 格林威治时间
time.gmtime()
time.gmtime(time.time())
time.strptime('2011-05-05 16:37:06', '%Y-%m-%d %X') # format_time to struct_time

# 生成format_time 以及struct_time to format_time
time.strftime("%Y-%m-%d %X")
time.strftime("%Y-%m-%d %X",time.localtime())

# 生成固定格式的时间表示格式
time.asctime(time.localtime())
time.ctime(time.time())
# Wed Oct 26 16:45:08 2016
```

#### 3.3.2 datetime模块

datatime模块重新封装了time模块,提供更多接口,提供的类有:date,time,datetime,timedelta,tzinfo。

* **date类:datetime.date(year, month, day)**

静态方法和字段:

```python
date.max、date.min:date对象所能表示的最大、最小日期;
date.resolution:date对象表示日期的最小单位。这里是天。
date.today():返回一个表示当前本地日期的date对象;
date.fromtimestamp(timestamp):根据给定的时间戮，返回一个date对象;
```
方法和属性:

```python
d1 = date(2011,06,03) # date对象
d1.year、date.month、date.day:年、月、日;
d1.replace(year, month, day):生成一个新的日期对象，用参数指定的年，月，日代替原有对象中的属性。（原有对象仍保持不变）
d1.timetuple():返回日期对应的time.struct_time对象;
d1.weekday():返回weekday，如果是星期一，返回0;如果是星期2，返回1，以此类推;
d1.isoweekday():返回weekday，如果是星期一，返回1;如果是星期2，返回2，以此类推;
d1.isocalendar():返回格式如(year，month，day)的元组;
d1.isoformat():返回格式如'YYYY-MM-DD’的字符串;
d1.strftime(fmt):和time模块format相同。
```

* **time类:datetime.time(hour[,minute[,second[,microsecond[,tzinfo]]]])**

静态方法和字段:

```python
time.min、time.max:time类所能表示的最小、最大时间。其中,time.min = time(0, 0, 0, 0), time.max = time(23, 59, 59, 999999);
time.resolution:时间的最小单位,这里是1微秒;
```

方法和属性:

```python
t1 = datetime.time(10,23,15)#time对象
t1.hour、t1.minute、t1.second、t1.microsecond:时、分、秒、微秒;
t1.tzinfo:时区信息;
t1.replace([ hour[ , minute[ , second[ , microsecond[ , tzinfo] ] ] ] ] ):创建一个新的时间对象,用参数指定的时、分、秒、微秒代替原有对象中的属性（原有对象仍保持不变）;
t1.isoformat():返回型如"HH:MM:SS"格式的字符串表示;
t1.strftime(fmt):同time模块中的format;
```

* **datetime类**

datetime相当于date和time结合起来。

```python
datetime.datetime(year,month,day[,hour[,minute[,second[,microsecond[,tzinfo]]]]])
```

静态方法和字段:

```python
datetime.today()：返回一个表示当前本地时间的datetime对象；
datetime.now([tz])：返回一个表示当前本地时间的datetime对象，如果提供了参数tz，则获取tz参数所指时区的本地时间；
datetime.utcnow()：返回一个当前utc时间的datetime对象；#格林威治时间
datetime.fromtimestamp(timestamp[, tz])：根据时间戮创建一个datetime对象，参数tz指定时区信息；
datetime.utcfromtimestamp(timestamp)：根据时间戮创建一个datetime对象；
datetime.combine(date, time)：根据date和time，创建一个datetime对象；
datetime.strptime(date_string, format)：将格式字符串转换为datetime对象；
```

方法和属性:

```python
dt=datetime.now() # datetime对象
dt.year、month、day、hour、minute、second、microsecond、tzinfo：
dt.date()：获取date对象；
dt.time()：获取time对象；
dt.replace ([ year[ , month[ , day[ , hour[ , minute[ , second[ , microsecond[ , tzinfo] ] ] ] ] ] ] ])：
dt.timetuple ()
dt.utctimetuple ()
dt.toordinal ()
dt.weekday ()
dt.isocalendar ()
dt.isoformat ([ sep] )
dt.ctime ()：返回一个日期时间的C格式字符串，等效于time.ctime(time.mktime(dt.timetuple()))；
dt.strftime (format)
```

* **timedelta类,时间加减**

在模板和tuple之间,有一个%号分隔,它代表了格式化操作。使用`timedelta`可以很方便的在日期上做天days,小时hour,分钟,秒,毫秒,微妙的时间计算,如果要计算月份则需要另外的办法。

```python
from  datetime import *

dt = datetime.now()
#日期减一天
dt1 = dt + timedelta(days=-1)#昨天
dt2 = dt - timedelta(days=1)#昨天
dt3 = dt + timedelta(days=1)#明天
delta_obj = dt3-dt
print type(delta_obj),delta_obj       # <type 'datetime.timedelta'> 1 day, 0:00:00
print delta_obj.days ,delta_obj.total_seconds()      # 1 86400.0
```

* **tzinfo时区类**

```python
from datetime import datetime, tzinfo,timedelta

"""
tzinfo是关于时区信息的类
tzinfo是一个抽象类，所以不能直接被实例化
"""
class UTC(tzinfo):
    """UTC"""
    def __init__(self,offset = 0):
        self._offset = offset

    def utcoffset(self, dt):
        return timedelta(hours=self._offset)

    def tzname(self, dt):
        return "UTC +%s" % self._offset

    def dst(self, dt):
        return timedelta(hours=self._offset)

# 北京时间
beijing = datetime(2011,11,11,0,0,0,tzinfo = UTC(8))
print("beijing time:",beijing)
# 曼谷时间
bangkok = datetime(2011,11,11,0,0,0,tzinfo = UTC(7))
print("bangkok time",bangkok)
# 北京时间转成曼谷时间
print("beijing-time to bangkok-time:",beijing.astimezone(UTC(7)))

# 计算时间差时也会考虑时区的问题
timespan = beijing - bangkok
print("时差:",timespan)
```

#### 3.3.3 calendar模块

calendar模块定义了Calendar类,它封装了值的计算,比如计算给定月份或年份中周的日期。此外,TextCalendar和HTMLCalendar类可以生成预格式化的输出。

* **格式化示例**

prmonth()方法是很简单,可以生成一个月的格式化文本输出。

```python
import calendar
c = calendar.TextCalendar(calendar.SUNDAY)
c.prmonth(2017, 7)
# 输出
#      July 2017
# Su Mo Tu We Th Fr Sa
#                    1
#  2  3  4  5  6  7  8
#  9 10 11 12 13 14 15
# 16 17 18 19 20 21 22
# 23 24 25 26 27 28 29
# 30 31
```

根据TextCalendar美国惯例,该示例配置为在周日开始周。默认是使用星期一开始一周的欧洲惯例。可以使用HTMLCalendar和formatmonth()生成类似HTML的表格。呈现的输出看起来与纯文本大致相同,但是用HTML标记包装。每个表格单元格都有一个与星期几相对应的类属性,因此HTML可以通过CSS设置样式。

要以不同于其中一个可用默认值的格式生成输出,请使用calendar计算日期并将值组织为周和月范围,然后迭代结果。Calendar模块的weekheader(),monthcalendar()和yeardays2calendar()方法对此特别有用。

调用yeardays2calendar()会生成一系列“月份行”列表。每个列表包括月份作为另一个周列表。这几周是由日期编号(1-31)和工作日编号(0-6)组成的元组列表。超出月份的天数为0。

```python
import calendar
import pprint

cal = calendar.Calendar(calendar.SUNDAY)
cal_data = cal.yeardays2calendar(2017, 3)
print('len(cal_data)      :', len(cal_data))

top_months = cal_data[0]
print('len(top_months)    :', len(top_months))

first_month = top_months[0]
print('len(first_month)   :', len(first_month))

print('first_month:')
pprint.pprint(first_month, width=65)

# 输出
# len(cal_data)      : 4
# len(top_months)    : 3
# len(first_month)   : 5
# first_month:
# [[(1, 6), (2, 0), (3, 1), (4, 2), (5, 3), (6, 4), (7, 5)],
#  [(8, 6), (9, 0), (10, 1), (11, 2), (12, 3), (13, 4), (14, 5)],
#  [(15, 6), (16, 0), (17, 1), (18, 2), (19, 3), (20, 4), (21, 5)],
#  [(22, 6), (23, 0), (24, 1), (25, 2), (26, 3), (27, 4), (28, 5)],
#  [(29, 6), (30, 0), (31, 1), (0, 2), (0, 3), (0, 4), (0, 5)]]
```

相当于使用formatyear()。

```python
import calendar

cal = calendar.TextCalendar(calendar.SUNDAY)
print(cal.formatyear(2017, 2, 1, 1, 3))

# 输出
#                               2017
#
#       January               February               March
# Su Mo Tu We Th Fr Sa  Su Mo Tu We Th Fr Sa  Su Mo Tu We Th Fr Sa
#  1  2  3  4  5  6  7            1  2  3  4            1  2  3  4
#  8  9 10 11 12 13 14   5  6  7  8  9 10 11   5  6  7  8  9 10 11
# 15 16 17 18 19 20 21  12 13 14 15 16 17 18  12 13 14 15 16 17 18
# 22 23 24 25 26 27 28  19 20 21 22 23 24 25  19 20 21 22 23 24 25
# 29 30 31              26 27 28              26 27 28 29 30 31
#
#        April                  May                   June
# Su Mo Tu We Th Fr Sa  Su Mo Tu We Th Fr Sa  Su Mo Tu We Th Fr Sa
#                    1      1  2  3  4  5  6               1  2  3
#  2  3  4  5  6  7  8   7  8  9 10 11 12 13   4  5  6  7  8  9 10
#  9 10 11 12 13 14 15  14 15 16 17 18 19 20  11 12 13 14 15 16 17
# 16 17 18 19 20 21 22  21 22 23 24 25 26 27  18 19 20 21 22 23 24
# 23 24 25 26 27 28 29  28 29 30 31           25 26 27 28 29 30
# 30
#
#         July                 August              September
# Su Mo Tu We Th Fr Sa  Su Mo Tu We Th Fr Sa  Su Mo Tu We Th Fr Sa
#                    1         1  2  3  4  5                  1  2
#  2  3  4  5  6  7  8   6  7  8  9 10 11 12   3  4  5  6  7  8  9
#  9 10 11 12 13 14 15  13 14 15 16 17 18 19  10 11 12 13 14 15 16
# 16 17 18 19 20 21 22  20 21 22 23 24 25 26  17 18 19 20 21 22 23
# 23 24 25 26 27 28 29  27 28 29 30 31        24 25 26 27 28 29 30
# 30 31
#
#       October               November              December
# Su Mo Tu We Th Fr Sa  Su Mo Tu We Th Fr Sa  Su Mo Tu We Th Fr Sa
#  1  2  3  4  5  6  7            1  2  3  4                  1  2
#  8  9 10 11 12 13 14   5  6  7  8  9 10 11   3  4  5  6  7  8  9
# 15 16 17 18 19 20 21  12 13 14 15 16 17 18  10 11 12 13 14 15 16
# 22 23 24 25 26 27 28  19 20 21 22 23 24 25  17 18 19 20 21 22 23
# 29 30 31              26 27 28 29 30        24 25 26 27 28 29 30
#                                             31
```

day_name,day_abbr,month_name和month_abbr模块主要用于生产定制格式化输出(即包括在HTML输出链接)。它们会针对当前区域自动化配置。

* **区域设置**

如果想生成非默认区域的格式化日历,可以使用LocaleTextCalendar或LocaleHTMLCalendar。

```python
import calendar

c = calendar.LocaleTextCalendar(locale='en_US')
c.prmonth(2017, 7)
print()
c = calendar.LocaleTextCalendar(locale='fr_FR')
c.prmonth(2017, 7)

# 输出
#      July 2017
# Mo Tu We Th Fr Sa Su
#                 1  2
#  3  4  5  6  7  8  9
# 10 11 12 13 14 15 16
# 17 18 19 20 21 22 23
# 24 25 26 27 28 29 30
# 31
#
#     juillet 2017
# Lu Ma Me Je Ve Sa Di
#                 1  2
#  3  4  5  6  7  8  9
# 10 11 12 13 14 15 16
# 17 18 19 20 21 22 23
# 24 25 26 27 28 29 30
# 31
```

一周的第一天不是语言环境设置的一部分,而且这个值就是该类的一个参数,就像TextCalendar一样。

* **计算日期**

虽然日历模块主要侧重于以各种格式打印完整日历,但它还提供了以其他方式处理日期的有用功能,例如计算重复事件的日期。例如,Python亚特兰大用户组在每个月的第二个星期四开会。要计算一年的会议日期,请使用monthcalendar()。

```python
import calendar
import pprint

pprint.pprint(calendar.monthcalendar(2017, 7))

# 输出
# [[0, 0, 0, 0, 0, 1, 2],
#  [3, 4, 5, 6, 7, 8, 9],
#  [10, 11, 12, 13, 14, 15, 16],
#  [17, 18, 19, 20, 21, 22, 23],
#  [24, 25, 26, 27, 28, 29, 30],
#  [31, 0, 0, 0, 0, 0, 0]]
```

0值是与给定月份重叠的一周中的时间,是另一个月的一部分。一周的第一天默认为星期一,可以通过调用setfirstweekday()来更改,但由于日历模块包含用于索引返回的日期范围的常量monthcalendar(),因此在这种情况下跳过该步骤更方便。要计算一年的小组会议日期,假设它们总是在每个月的第二个星期四,查看monthcalendar()输出来查找星期四。本月的第一周和最后一周填充0值作为前一个月或后一个月天数的占位符。例如,如果一个月在星期五开始,则星期四位置第一周的值将为0。

```python
import calendar
import sys

year = int(sys.argv[1])
# Show every month
for month in range(1, 13):
    # Compute the dates for each week that overlaps the month
    c = calendar.monthcalendar(year, month)
    first_week = c[0]
    second_week = c[1]
    third_week = c[2]

    # If there is a Thursday in the first week, the second Thursday is # in the second week.
    # Otherwise, the second Thursday must be in the third week.
    if first_week[calendar.THURSDAY]:
        meeting_date = second_week[calendar.THURSDAY]
    else:
        meeting_date = third_week[calendar.THURSDAY]
    print('{:>3}: {:>2}'.format(calendar.month_abbr[month], meeting_date))

# 输出
# Jan: 12
# Feb:  9
# Mar:  9
# Apr: 13
# May: 11
# Jun:  8
# Jul: 13
# Aug: 10
# Sep: 14
# Oct: 12
# Nov:  9
# Dec: 14
```

* **其他可能有用的函数列表**

| 序号 | 函数 | 描述 |
| :--- | ---  | ---  |
| 1 | calendar.calendar(year,w=2,l=1,c=6) | 返回一个多行字符串格式的year年年历,3个月一行,间隔距离为c。每日宽度间隔为w字符,每行长度为21*W+18+2*C,l是每星期行数 |
| 2 | calendar.firstweekday() | 返回当前每周起始日期的设置。默认情况下,首次载入calendar模块时返回0,即星期一 |
| 3 | calendar.isleap(year) | 是闰年返回True,否则为false |
| 4 | calendar.leapdays(y1,y2) | 返回在Y1,Y2两年之间的闰年总数 |
| 5 | calendar.month(year,month,w=2,l=1) | 返回一个多行字符串格式的year年month月日历,两行标题,一周一行。每日宽度间隔为w字符,每行的长度为7*w+6,l是每星期的行数 |
| 6 | calendar.monthcalendar(year,month) | 返回一个整数的单层嵌套列表。每个子列表装载代表一个星期的整数,Year年month月外的日期都设为0;范围内的日子都由该月第几日表示,从1开始 |
| 7 | calendar.monthrange(year,month) | 返回两个整数,第一个是该月的星期几的日期码,第二个是该月的日期码。日从0(星期一)到6(星期日),月从1到12 |
| 8 | calendar.prcal(year,w=2,l=1,c=6) | 相当于print calendar.calendar(year,w,l,c) |
| 9 | calendar.prmonth(year,month,w=2,l=1) | 相当于print calendar.calendar(year,w,l,c) |
| 10 | calendar.setfirstweekday(weekday) | 设置每周的起始日期码,0(星期一)到6(星期日) |
| 11 | calendar.timegm(tupletime),time.gmtime相反 | 接受一个时间元组形式,返回该时刻的时间辍(1970纪元后经过的浮点秒数) |
| 12 | calendar.weekday(year,month,day) | 返回给定日期的日期码,0(星期一)到6(星期日),月份为1(一月)到12(12月) |
