# 计算机概论
## 一、计算机设备

### 1.1 CPU

CPU的全称是Central Processing Unit,它是你的电脑中最硬核的组件。CPU是能够让你的计算机叫计算机的核心组件,但是它却不能代表你的电脑,CPU与计算机的关系就相当于大脑和人的关系。它是一种小型的计算机芯片,它嵌入在台式机、笔记本电脑或者平板电脑的主板上。通过在单个计算机芯片上放置数十亿个微型晶体管来构建CPU。这些晶体管使它能够执行运行存储在系统内存中的程序所需的计算,也就是说CPU决定了你电脑的计算能力。

![](http://pic3.zhimg.com/80/v2-770bccc2c2c7b9bec2687e0bf0112f32_hd.jpg)

CPU的核心是从程序或应用程序获取指令并执行计算。此过程可以分为三个关键阶段:提取、解码和执行。CPU从系统的RAM中提取指令,然后解码该指令的实际内容,然后再由CPU的相关部分执行该指令。

RAM,随机存取存储器(英语:Random Access Memory,缩写RAM),也叫主存,是与CPU直接交换数据的内部存储器。它可以随时读写(刷新时除外),而且速度很快,通常作为操作系统或其他正在运行中的程序的临时数据存储介质。

下图展示了一般程序的运行流程(以C语言为例),可以说了解程序的运行流程是掌握程序运行机制的基础和前提。

![](http://pic2.zhimg.com/v2-159c3df2e62421c6a153c0106f82e821_r.jpg)

在这个流程中,CPU负责的就是解释和运行最终转换成机器语言的内容。CPU主要由两部分构成:控制单元和算术逻辑单元(ALU)。

> 控制单元:从内存中提取指令并解码执行
> 
> 算数逻辑单元(ALU):处理算数和逻辑运算

CPU是计算机的心脏和大脑,它和内存都是由许多晶体管组成的电子部件。它接收数据输入,执行指令并处理信息。它与输入/输出(I/O)设备进行通信,这些设备向CPU发送数据和从CPU接收数据。

从功能来看,CPU的内部由寄存器、控制器、运算器和时钟四部分组成,各部分之间通过电信号连通。

![](http://pic2.zhimg.com/v2-7b2a3ed45a401226a002b00444924331_r.jpg)

> **寄存器** 是中央处理器内的组成部分,它们可以用来暂存指令、数据和地址。可以将其看作是内存的一种。根据种类的不同,一个CPU内部会有20-100个寄存器
> 
> **控制器** 负责把内存上的指令、数据读入寄存器,并根据指令的结果控制计算机
> 
> **运算器** 负责运算从内存中读入寄存器的数据
> 
> **时钟** 负责发出CPU开始计时的时钟信号

接下来简单解释一下内存,为什么说CPU需要讲一下内存呢,因为内存是与CPU进行沟通的桥梁。计算机所有程序的运行都是在内存中运行的,内存又被称为主存,其作用是存放CPU中的运算数据,以及与硬盘等外部存储设备交换的数据。只要计算机在运行中,CPU就会把需要运算的数据调到主存中进行运算,当运算完成后CPU再将结果传送出来,主存的运行也决定了计算机的稳定运行。

主存通过控制芯片与CPU进行相连,由可读写的元素构成,每个字节(1 byte=8 bits)都带有一个地址编号,注意是一个字节,而不是一个位。CPU通过地址从主存中读取数据和指令,也可以根据地址写入数据。注意一点:当计算机关机时,内存中的指令和数据也会被清除。

* **CPU是寄存器的集合体**

在CPU的四个结构中,我们程序员只需要了解寄存器就可以了,其余三个不用过多关注,为什么这么说?因为程序是把寄存器作为对象来描述的。

说到寄存器,就不得不说到汇编语言,说到汇编语言,就不得不说到高级语言,说到高级语言就不得不牵扯出语言这个概念。

> * **计算机语言**

我们生而为人最明显的一个特征是我们能通过讲话来实现彼此的交流,但是计算机听不懂你说的话,你要想和他交流必须按照计算机指令来交换,这就涉及到语言的问题,计算机是由二进制构成的,它只能听的懂二进制也就是机器语言,但是普通人是无法看懂机器语言的,这个时候就需要一种电脑既能识别,人又能理解的语言,最先出现的就是汇编语言。但是汇编语言晦涩难懂,所以又出现了像是C,C++,Java的这种高级语言。

所以计算机语言一般分为两种:低级语言(机器语言,汇编语言)和高级语言。使用高级语言编写的程序,经过编译转换成机器语言后才能运行,而汇编语言经过汇编器才能转换为机器语言。

> * **汇编语言**

首先来看一段用汇编语言表示的代码清单

```c
mov eax, dword ptr [ebp-8]      /* 把数值从内存复制到eax */
add eax, dword ptr [ebp-0Ch]    /* 把eax的数值和内存的数值相加 */
mov dword ptr [ebp-4], eax      /* 把eax的数值(上一步的结果)存储在内存中 */
```

这是采用汇编语言(assembly)编写程序的一部分。汇编语言采用助记符(memonic)来编写程序,每一个原本是电信号的机器语言指令会有一个与其对应的助记符,例如mov,add分别是数据的存储(move)和相加(addition)的简写。汇编语言和机器语言是一一对应的,这一点和高级语言有很大的不同,通常我们将汇编语言编写的程序转换为机器语言的过程称为汇编;反之,机器语言转化为汇编语言的过程称为反汇编。

汇编语言能够帮助你理解计算机做了什么工作,机器语言级别的程序是通过寄存器来处理的,上面代码中的eax,ebp都是表示的寄存器,是CPU内部寄存器的名称,所以可以说CPU是一系列寄存器的集合体。在内存中的存储通过地址编号来表示,而寄存器的种类则通过名字来区分。

不同类型的CPU,其内部寄存器的种类,数量以及寄存器存储的数值范围都是不同的。不过,根据功能的不同,可以将寄存器划分为下面这几类:

![](http://pic2.zhimg.com/v2-240354c077a97ee549df0de631b40df9_r.jpg)

其中程序计数器、累加寄存器、标志寄存器、指令寄存器和栈寄存器都只有一个,其他寄存器一般有多个。

![](https://pic1.zhimg.com/v2-dd9c7504648bce2583bc764b0855ddd4_r.jpg)

> * **程序计数器**

程序计数器(Program Counter)是用来存储下一条指令所在单元的地址。程序执行时,PC的初值为程序第一条指令的地址,在顺序执行程序时,控制器首先按程序计数器所指出的指令地址从内存中取出一条指令,然后分析和执行该指令,同时将PC的值加1指向下一条要执行的指令。

我们还是以一个事例为准来详细的看一下程序计数器的执行过程

![](https://pic2.zhimg.com/v2-0f4f4a071c3be93a9effc14544d0cf4d_r.jpg)

这是一段进行相加的操作,程序启动,在经过编译解析后会由操作系统把硬盘中的程序复制到内存中,示例中的程序是将123和456执行相加操作,并将结果输出到显示器上。由于使用机器语言难以描述,所以这是经过翻译后的结果,实际上每个指令和数据都可能分布在不同的地址上,但为了方便说明,把组成一条指令的内存和数据放在了一个内存地址上。

地址0100是程序运行的起始位置。Windows等操作系统把程序从硬盘复制到内存后,会将程序计数器作为设定为起始位置0100,然后执行程序,每执行一条指令后,程序计数器的数值会增加1(或者直接指向下一条指令的地址),然后CPU就会根据程序计数器的数值,从内存中读取命令并执行,也就是说,程序计数器控制着程序的流程。

> * **条件分支和循环机制**

我们都学过高级语言,高级语言中的条件控制流程主要分为三种:顺序执行、条件分支、循环判断三种,顺序执行是按照地址的内容顺序的执行指令。条件分支是根据条件执行任意地址的指令,循环是重复执行同一地址的指令。

顺序执行的情况比较简单,每执行一条指令程序计数器的值就是+1,条件和循环分支会使程序计数器的值指向任意的地址,这样一来,程序便可以返回到上一个地址来重复执行同一个指令,或者跳转到任意指令。

下面以条件分支为例来说明程序的执行过程(循环也很相似)

![](http://pic3.zhimg.com/v2-c3c291167d68e17d4a6e07c81b533f36_r.jpg)

程序的开始过程和顺序流程是一样的,CPU从0100处开始执行命令,在0100和0101都是顺序执行,PC的值顺序+1,执行到0102地址的指令时,判断0106寄存器的数值大于0,跳转(jump)到0104地址的指令,将数值输出到显示器中,然后结束程序,0103的指令被跳过了,这就和我们程序中的if()判断是一样的,在不满足条件的情况下,指令会直接跳过。所以PC的执行过程也就没有直接+1,而是下一条指令的地址。

> * **标志寄存器**

条件和循环分支会使用到jump(跳转指令),会根据当前的指令来判断是否跳转,上面我们提到了标志寄存器,无论当前累加寄存器的运算结果是正数、负数还是零,标志寄存器都会将其保存(也负责溢出和奇偶校验)。

> 溢出(overflow):是指运算的结果超过了寄存器的长度范围
> 
> 奇偶校验(parity check):是指检查运算结果的值是偶数还是奇数

`CPU`在进行运算时,标志寄存器的数值会根据当前运算的结果自动设定,运算结果的正、负和零三种状态由标志寄存器的三个位表示。标志寄存器的第一个字节位、第二个字节位、第三个字节位各自的结果都为1时,分别代表着正数、零和负数。

![](http://pic3.zhimg.com/v2-979d0ce2cb7ea338e9bcd168465ee0fa_r.jpg)

`CPU`的执行机制比较有意思,假设累加寄存器中存储的`XXX`和通用寄存器中存储的`YYY`做比较,执行比较的背后,`CPU`的运算机制就会做减法运算。而无论减法运算的结果是正数、零还是负数,都会保存到标志寄存器中。结果为正表示`XXX`比`YYY`大,结果为零表示`XXX`和`YYY`相等,结果为负表示`XXX`比`YYY`小。程序比较的指令,实际上是在`CPU`内部做减法运算。

> * **函数调用机制**

接下来,我们继续介绍函数调用机制,哪怕是高级语言编写的程序,函数调用处理也是通过把程序计数器的值设定成函数的存储地址来实现的。函数执行跳转指令后,必须进行返回处理,单纯的指令跳转没有意义,下面是一个实现函数跳转的例子

![](http://pic3.zhimg.com/v2-e6e79c501c3f477516207c537426f4a6_r.jpg)

图中将变量`a`和`b`分别赋值为`123`和`456`,调用`MyFun(a,b)`方法,进行指令跳转。图中的地址是将`C`语言编译成机器语言后运行时的地址,由于1行`C`程序在编译后通常会变为多行机器语言,所以图中的地址是分散的。在执行完`MyFun(a,b)`指令后,程序会返回到`MyFun(a,b)`的下一条指令,`CPU`继续执行下面的指令。

函数的调用和返回很重要的两个指令是`call`和`return`指令,再将函数的入口地址设定到程序计数器之前,`call`指令会把调用函数后要执行的指令地址存储在名为栈的主存内。函数处理完毕后,再通过函数的出口来执行`return`指令。`return`指令的功能是把保存在栈中的地址设定到程序计数器。`MyFun`函数在被调用之前,`0154`地址保存在栈中,`MyFun`函数处理完成后,会把`0154`的地址保存在程序计数器中。这个调用过程如下

![](http://pic4.zhimg.com/v2-4265e6cbeefc1b80ac7584f77c509bf3_r.jpg)

在一些高级语言的条件或者循环语句中,函数调用的处理会转换成`call`指令,函数结束后的处理则会转换成`return`指令。

> * **通过地址和索引实现数组**

接下来我们看一下基址寄存器和变址寄存器,通过这两个寄存器,我们可以对主存上的特定区域进行划分,来实现类似数组的操作,首先,我们用十六进制数将计算机内存上的`00000000-FFFFFFFF`的地址划分出来。那么,凡是该范围的内存地址,只要有一个`32`位的寄存器,便可查看全部地址。但如果想要想数组那样分割特定的内存区域以达到连续查看的目的的话,使用两个寄存器会更加方便。

例如我们用两个寄存器(基址寄存器和变址寄存器)来表示内存的值

![](http://pic1.zhimg.com/v2-41538e08f444feb83cfe015dc687f11c_r.jpg)

这种表示方式很类似数组的构造,数组是指同样长度的数据在内存中进行连续排列的数据构造。用数组名表示数组全部的值,通过索引来区分数组的各个数据元素,例如:`a[0]-a[4]`,`[]`内的`0-4`就是数组的下标。

> * **`CPU`指令执行过程**

那么`CPU`是如何执行一条条的指令的呢?几乎所有的冯·诺伊曼型计算机的`CPU`,其工作都可以分为5个阶段:取指令、指令译码、执行指令、访存取数、结果写回。

> `取指令阶段`是将内存中的指令读取到`CPU`中寄存器的过程,程序寄存器用于存储下一条指令所在的地址
> <br> `指令译码阶段`,在取指令完成后,立马进入指令译码阶段,在指令译码阶段,指令译码器按照预定的指令格式,对取回的指令进行拆分和解释,识别区分出不同的指令类别以及各种获取操作数的方法。
> <br> `执行指令阶段`,译码完成后,就需要执行这一条指令了,此阶段的任务是完成指令所规定的各种操作,具体实现指令的功能
> <br> `访问取数阶段`,根据指令的需要,有可能需要从内存中提取数据,此阶段的任务是:根据指令地址码,得到操作数在主存中的地址,并从主存中读取该操作数用于运算
> <br> `结果写回阶段`,作为最后一个阶段,结果写回(Write Back,WB)阶段把执行指令阶段的运行结果数据"写回"到某种存储形式:结果数据经常被写到`CPU`的内部寄存器中,以便被后续的指令快速地存取;


## 二、互联网知识

### 2.1 统一资源标识符

在计算机术语中,统一资源标识符(`Uniform Resource Identifier`,缩写`URI`)是一个用于标识某一互联网资源名称的字符串。该种标识允许用户对网络中(一般指万维网)的资源通过特定的协议进行交互操作。`URI`的最常见的形式是统一资源定位符(`Uniform Resource Locator`,缩写为`URL`),经常指定为非正式的网址。更罕见的用法是统一资源名称(`URN`),其目的是通过提供一种途径,用于在特定的名字空间资源的标识,以补充网址。

**与URL和URN的关系:**

![](https://upload.wikimedia.org/wikipedia/commons/thumb/c/c3/URI_Euler_Diagram_no_lone_URIs.svg/360px-URI_Euler_Diagram_no_lone_URIs.svg.png)

`URI`可被视为定位符(`URL`),名称(`URN`)或两者兼备。统一资源名(`URN`)如同一个人的名称,而统一资源定位符(`URL`)代表一个人的住址。换言之,`URN`定义某事物的身份,而`URL`提供查找该事物的方法。

用于标识唯一书目的`ISBN`系统是一个典型的URN使用范例。例如,`ISBN 0-486-27557-4`无二义性地标识出莎士比亚的戏剧《罗密欧与朱丽叶》的某一特定版本。为获得该资源并阅读该书,人们需要它的位置,也就是一个`URL`地址。在类`Unix`操作系统中,一个典型的`URL`地址可能是一个文件目录,例如`file:///home/username/RomeoAndJuliet.pdf`。该`URL`标识出存储于本地硬盘中的电子书文件。因此,`URL`和`URN`有着互补的作用。

**技术观点:**`URL`是一种`URI`,它标识一个互联网资源,并指定对其进行操作或获取该资源的方法。可能通过对主要访问手段的描述,也可能通过网络“位置”进行标识。例如,`http://www.wikipedia.org/`这个`URL`,标识一个特定资源(首页)并表示该资源的某种形式(例如以编码字符表示的,首页的`HTML`代码)是可以通过`HTTP`协议从`www.wikipedia.org`这个网络主机获得的。`URN`是基于某名字空间通过名称指定资源的`URI`。人们可以通过`URN`来指出某个资源,而无需指出其位置和获得方式。资源无需是基于互联网的。例如,`URN urn:ISBN 0-395-36341-1`指定标识系统(即国际标准书号`ISBN`)和某资源在该系统中的唯一表示的`URI`。它可以允许人们在不指出其位置和获得方式的情况下谈论这本书。


**文法:**`URI`文法由`URI`协议名(例如"`http`","`ftp`","`mailto`"或"`file`"),一个冒号,和协议对应的内容所构成。特定的协议定义了协议内容的语法和语义,而所有的协议都必须遵循一定的`URI`文法通用规则,亦即为某些专门目的保留部分特殊字符。`URI`文法同时也就各种原因对协议内容加以其他的限制,例如,保证各种分层协议之间的协同性。百分号编码也为`URI`提供附加信息。

通用`URI`的格式如下:

```js
scheme:[//[user[:password]@]host[:port]][/path][?query][#fragment]
```

[`URL`](https://www.ietf.org/rfc/rfc1738.txt)被冒号分成了两部分,前面是`scheme`(方案),后面是`scheme`的描述部分。

`scheme`只能由以下元素组成:`a-z`(不区分大小写),数字,字符(加号`+`,句号`.`,连字符`-`)。`shceme`目前有这些类型:

| 类型 | 说明 |
| --- | --- |
| `ftp` | `File Transfer protocol`(文件传输协议) |
| `http` | `Hypertext Transfer Protocol`(超文本传输协议) |
| `gopher` | `The Gopher protocol`(`Gopher`协议) |
| `mailto` | `Electronic mail address`(电子邮件地址) |
| `news` | `USENET news`(`USENET`新闻) |
| `nntp` | `USENET news using NNTP access`(使用`NNTP`访问的USENET新闻) |
| `telnet` | `Reference to interactive sessions`(交互式会话访问) |
| `wais` | `Wide Area Information Servers`(广域信息服务系统) |
| `file` | `Host-specific file names`(特殊主机文件名) |
| `prospero` | `Prospero Directory Service`(`prospero`目录服务) |

当然,上述的`scheme`大部分是应用非常广泛的,我们可以自定义`scheme`,只要解析器支持即可,比如我们公司就根据`URL`设计了一条`App`跳转专用的`URL`,方便服务器分发跳转路径。

`scheme`的描述部分也可以拆解成以下的结构:

```js
<user>:<password>@<host>:<port>/<url-path>
```

根据方案的不同,这些部分是可以部分省略的,比如`http`通常不需要`user`和`password`。我们来依次看这些组成部分:

| 字段 | 说明 |
| --- | --- |
| `user` | 这个比较好理解,就是用户名,没有则省略 |
| `password` | 用户密码 |
| `host` | `host`(主机)是一个IP地址,由四组十进制数字以.分割组合而成。现在很多对客的地址都是用了域名,然后再通过`DNS`解析.`DNS`可以理解为将难以记住的`ip`地址和单词等组成的域名做映射,从而方便用户的使用。记住`https://www.baidu.com`可比记住`192.292.22.22`容易多了。很多的公司在使用的时候也会做`DNS`优化,即客户端等发出请求的时候,直接向对应的`ip`发送,从而节省`DNS`解析的时间,加快用户访问速度,有兴趣的可以网络搜索下 |
| `port` | `port`(端口)是用来区分不同的网络服务的,从而实现在一个`IP`的基础上,提供多个网络服务 |
| `url-path` | `url`路径提供了如何对特定资源访问的详细信息,一般都是文件夹的路径 |

例子:下图展示了两个`URI`例子及它们的组成部分。

![](http://wx2.sinaimg.cn/nmw690/006HJ6Ndly1g00hu1iyaej31ag0diwg5.jpg)


**`URI`引用:**

另一种类型的字符串——"`URI`引用"——代表一个`URI`并(相应地)代表被该`URI`所标识的资源。非正式使用中,`URI`和`URI`引用的区别少有被提及,但协议文档自然不应允许歧义的存在。

`URI`引用可取用的格式包括完整`URI`,`URI`中协议特定的部分,或其后附部分——甚至是空字符串。一个可选的片段标识符以`#`开头,可出现在`URI`引用的结尾。引用中,`#`之前的部分间接标识一个资源,而片段标识符则标识资源的某个部分。

为从`URI`引用获得`URI`,软件将`URI`引用与一个绝对"基址"基于一个固定算法合并,并转换为"绝对"形式。系统将`URI`引用视作相对于基址`URI`,虽然在绝对引用的情况下基址并无意义。基址`URI`一般标识包含`URI`引用的文档,但仍可被文档内包含的声明,或外部数据传输协议所包括的声明改写。若基址`URI`包括一个片段标识符,则该标识符在合并过程中被
忽略。如果在`URI`引用中出现片段标识符,则在合并过程中被保留。

网络文档标记语言时常使用`URI`引用指向其它资源,如外部文档或同一逻辑文档的其他部分等。在`HTML`中,`img`元素的`src`属性值是`URI引用`,`a或link`元素的`href`属性值亦如是。在`XML`中,在一个`DTD`中的`SYSTEM`关键字之后出现的系统描述符是一个无片段的`URI`引用。在`XSLT`中,`xsl:import`元素/指令的`href`属性值是一个`URI`引用,`document()`函数的第一个参数与之相仿。

```js
# 绝对URI
http://example.org/absolute/URI/with/absolute/path/to/resource.txt
ftp://example.org/resource.txt
urn:issn:1535-3613
# URI引用
http://en.wikipedia.org/wiki/URI#Examples_of_URI_references ("http" 指定协议名, "en.wikipedia.org"是“典据”, "/wiki/URI"是指向英文维基页面的“路径”,而"#Examples_of_URI_references"是指向英文维基页面相应片段的“片段”。)
http://example.org/absolute/URI/with/absolute/path/to/resource.txt
//example.org/scheme-relative/URI/with/absolute/path/to/resource.txt
/relative/URI/with/absolute/path/to/resource.txt
relative/path/to/resource.txt
../../../resource.txt
./resource.txt#frag01
resource.txt
#frag01
(空字符串)
```

**`URI`解析:** "解析"一个`URI`意味着将一个相对`URI`引用转换为绝对形式,或者通过尝试获取一个可解引`URI`或一个`URI`引用所代表的资源来解引用这个URI。文档处理软件的"解析"部分通常同时提供这两种功能。

一个`URI`引用可以是一个同文档引用:一个指向包含`URI`引用自身的文档的引用。文档处理软件可有效地使用其当前的文档资源来完成对于同文档引用的解析而不需要重新获取一份资源。这只是一个建议——文档处理软件自然可以选用另外的方法来决定是否获取新资源。

### 2.2 `TCP/IP`模型

`TCP/IP`协议模型(`Transmission Control Protocol/Internet Protocol`),包含了一系列构成互联网基础的网络协议,是`Internet`的核心协议。

基于`TCP/IP`的参考模型将协议分成四个层次,它们分别是链路层、网络层、传输层和应用层。下图表示`TCP/IP`模型与`OSI`模型各层的对照关系。

![](https://pic4.zhimg.com/80/v2-d6a75e961a9d13228f57691662a5d3ab_1440w.jpg)

`TCP/IP`协议族按照层次由上到下,层层包装。最上面的是应用层,这里面有`http`,`ftp`等等我们熟悉的协议。而第二层则是传输层,著名的`TCP`和`UDP`协议就在这个层次。第三层是网络层,`IP`协议就在这里,它负责对数据加上`IP`地址和其他的数据以确定传输的目标。第四层是数据链路层,这个层次为待传送的数据加入一个以太网协议头,并进行`CRC`编码,为最后的数据传输做准备。

![](https://pic1.zhimg.com/v2-d31f27ac9bb86500477158bb4d7eba84_r.jpg)

上图清楚地表示了`TCP/IP`协议中每个层的作用,而`TCP/IP`协议通信的过程其实就对应着数据入栈与出栈的过程。入栈的过程,数据发送方每层不断地封装首部与尾部,添加一些传输的信息,确保能传输到目的地。出栈的过程,数据接收方每层不断地拆除首部与尾部,得到最终传输的数据。

![](https://pic4.zhimg.com/v2-6cacedff60b984ce8063f76c4f876da3_r.jpg)

上图以`HTTP`协议为例,具体说明。


* **数据链路层**

物理层负责`0`、`1`比特流与物理设备电压高低、光的闪灭之间的互换。数据链路层负责将`0`、`1`序列划分为数据帧从一个节点传输到临近的另一个节点,这些节点是通过`MAC`来唯一标识的(`MAC`,物理地址,一个主机会有一个`MAC`地址)。

![](https://pic3.zhimg.com/80/v2-14f2606cb192eb5fcfde945d334f7e92_1440w.jpg)

> 封装成帧:把网络层数据报加头和尾,封装成帧,帧头中包括源`MAC`地址和目的`MAC`地址。
>
> 透明传输:零比特填充、转义字符。
>
> 可靠传输: 在出错率很低的链路上很少用,但是无线链路`WLAN`会保证可靠传输。
>
> 差错检测(`CRC`):接收者检测错误,如果发现差错,丢弃该帧。

* **网络层**

**`IP`协议**

在数据链路层中我们一般通过`MAC`地址来识别不同的节点,而在`IP`层我们也要有一个类似的地址标识,这就是`IP`地址。`32`位`IP`地址分为网络位和地址位,这样做可以减少路由器中路由表记录的数目,有了网络地址,就可以限定拥有相同网络地址的终端都在同一个范围内,那么路由表只需要维护一条这个网络地址的方向,就可以找到相应的这些终端了。

> `A`类`IP`地址:`0.0.0.0~127.0.0.0`
>
> `B`类`IP`地址:`128.0.0.1~191.255.0.0`
>
> `C`类`IP`地址:`192.168.0.0~239.255.255.0`

![](https://pic2.zhimg.com/v2-9bd7f326cf85b36bdb1165109fb535c1_r.jpg)

八位的`TTL`字段,这个字段规定该数据包在穿过多少个路由之后才会被抛弃。某个`IP`数据包每穿过一个路由器,该数据包的`TTL`数值就会减少1,当该数据包的TTL成为零,它就会被自动抛弃。

这个字段的最大值也就是`255`,也就是说一个协议包也就在路由器里面穿行`255`次就会被抛弃了,根据系统的不同,这个数字也不一样,一般是`32`或者是`64`。

**`ARP`及`RARP`协议**

`ARP`是根据`IP`地址获取`MAC`地址的一种协议。`ARP`(地址解析)协议是一种解析协议,本来主机是完全不知道这个IP对应的是哪个主机的哪个接口,当主机要发送一个`IP`包的时候,会首先查一下自己的ARP高速缓存(就是一个`IP-MAC`地址对应表缓存)。

如果查询的`IP－MAC`值对不存在,那么主机就向网络发送一个`ARP`协议广播包,这个广播包里面就有待查询的`IP`地址,而直接收到这份广播的包的所有主机都会查询自己的`IP`地址,如果收到广播包的某一个主机发现自己符合条件,那么就准备好一个包含自己的`MAC`地址的`ARP`包传送给发送`ARP`广播的主机。

而广播主机拿到`ARP`包后会更新自己的`ARP`缓存(就是存放`IP-MAC`对应表的地方)。发送广播的主机就会用新的`ARP`缓存数据准备好数据链路层的的数据包发送工作。

`RARP`协议的工作与此相反,不做赘述。

**`ICMP`协议**

`IP`协议并不是一个可靠的协议,它不保证数据被送达,那么,自然的,保证数据送达的工作应该由其他的模块来完成。其中一个重要的模块就是`ICMP`(网络控制报文)协议。`ICMP`不是高层协议,而是`IP`层的协议。

当传送`IP`数据包发生错误。比如主机不可达,路由不可达等等,`ICMP`协议将会把错误信息封包,然后传送回给主机。给主机一个处理错误的机会,这 也就是为什么说建立在`IP`层以上的协议是可能做到安全的原因。

**检测工具**

`ping`可以说是ICMP的最著名的应用,是`TCP/IP`协议的一部分。利用"`ping`"命令可以检查网络是否连通,可以很好地帮助我们分析和判定网络故障。

例如:当我们某一个网站上不去的时候。通常会`ping`一下这个网站。`ping`会回显出一些有用的信息。一般的信息如下:

![](https://pic3.zhimg.com/80/v2-4d873acce057bdb9996dad9750b2f27e_1440w.jpg)

`ping`这个单词源自声纳定位,而这个程序的作用也确实如此,它利用`ICMP`协议包来侦测另一个主机是否可达。原理是用类型码为`0`的`ICMP`发请 求,受到请求的主机则用类型码为`8`的`ICMP`回应。`ping`程序来计算间隔时间,并计算有多少个包被送达。用户就可以判断网络大致的情况。我们可以看到, `ping`给出来了传送的时间和`TTL`的数据。

`Traceroute`是用来侦测主机到目的主机之间所经路由情况的重要工具,也是最便利的工具。

`Traceroute`的原理是非常非常的有意思,它收到到目的主机的`IP`后,首先给目的主机发送一个`TTL=1`的`UDP`数据包,而经过的第一个路由器收到这个数据包以后,就自动把`TTL`减`1`,而`TTL`变为`0`以后,路由器就把这个包给抛弃了,并同时产生一个主机不可达的`ICMP`数据报给主机。主机收到这个数据报以后再发一个`TTL=2`的`UDP`数据报给目的主机,然后刺激第二个路由器给主机发`ICMP`数据报。如此往复直到到达目的主机。这样,`traceroute`就拿到了所有的路由器`IP`。


**`TCP/UDP`**

`TCP/UDP`都是是传输层协议,但是两者具有不同的特性,同时也具有不同的应用场景,下面以图表的形式对比分析。

![](https://pic3.zhimg.com/v2-3cdbcf0100f88b32af1d2e0a52285c3a_r.jpg)

面向报文:面向报文的传输方式是应用层交给`UDP`多长的报文,`UDP`就照样发送,即一次发送一个报文。因此,应用程序必须选择合适大小的报文。若报文太长,则`IP`层需要分片,降低效率。若太短,会是`IP`太小。

面向字节流:面向字节流的话,虽然应用程序和`TCP`的交互是一次一个数据块(大小不等),但`TCP`把应用程序看成是一连串的无结构的字节流。`TCP`有一个缓冲,当应用程序传送的数据块太长,`TCP`就可以把它划分短一些再传送。

TCP和UDP协议的一些应用

![](https://pic4.zhimg.com/v2-6cb1b65c9d1ae4c96914cd78e47da1ab_r.jpg)

什么时候应该使用`TCP`:当对网络通讯质量有要求的时候,比如:整个数据要准确无误的传递给对方,这往往用于一些要求可靠的应用,比如`HTTP`、`HTTPS`、`FTP`等传输文件的协议,`POP`、`SMTP`等邮件传输的协议。

什么时候应该使用`UDP`:当对网络通讯质量要求不高的时候,要求网络通讯速度能尽量的快,这时就可以使用`UDP`。


* **TCP连接的建立与终止**

**三次握手**

`TCP`是面向连接的,无论哪一方向另一方发送数据之前,都必须先在双方之间建立一条连接。在`TCP/IP`协议中,`TCP`协议提供可靠的连接服务,连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换 TCP窗口大小信息。

![](https://pic1.zhimg.com/80/v2-460c0ce6abfd79f18e35266ad5dbb6d4_1440w.jpg)

> 第一次握手: 建立连接。客户端发送连接请求报文段,将`SYN`位置为`1`,`Sequence Number`为`x`;然后,客户端进入`SYN_SEND`状态,等待服务器的确认;
>
> 第二次握手:服务器收到`SYN`报文段。服务器收到客户端的`SYN`报文段,需要对这个`SYN`报文段进行确认,设置`Acknowledgment Number`为`x+1`(`Sequence Number+1`);同时,自己自己还要发送`SYN`请求信息,将`SYN`位置为`1`,`Sequence Number`为`y`;服务器端将上述所有信息放到一个报文段(即`SYN+ACK`报文段)中,一并发送给客户端,此时服务器进入`SYN_RECV`状态;
>
> 第三次握手: 客户端收到服务器的`SYN+ACK`报文段。然后将`Acknowledgment Number`设置为`y+1`,向服务器发送`ACK`报文段,这个报文段发送完毕以后,客户端和服务器端都进入`ESTABLISHED`状态,完成`TCP`三次握手。

为什么要三次握手:为了防止已失效的连接请求报文段突然又传送到了服务端,因而产生错误。

具体例子:"已失效的连接请求报文段"的产生在这样一种情况下:client发出的第一个连接请求报文段并没有丢失,而是在某个网络结点长时间的滞留了,以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后,就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段,同意建立连接。假设不采用“三次握手”,那么只要server发出确认,新的连接就建立了。由于现在client并没有发出建立连接的请求,因此不会理睬server的确认,也不会向server发送数据。但server却以为新的运输连接已经建立,并一直等待client发来数据。这样,server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况,client不会向server的确认发出确认。server由于收不到确认,就知道client并没有要求建立连接。”

**四次挥手**

当客户端和服务器通过三次握手建立了TCP连接以后,当数据传送完毕,肯定是要断开TCP连接的啊。那对于TCP的断开连接,这里就有了神秘的“四次分手”。

![](https://pic1.zhimg.com/80/v2-460c0ce6abfd79f18e35266ad5dbb6d4_1440w.jpg)

> 第一次分手: 主机1(可以使客户端,也可以是服务器端),设置Sequence Number,向主机2发送一个FIN报文段；此时,主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；
>
> 第二次分手: 主机2收到了主机1发送的FIN报文段,向主机1回一个ACK报文段,Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1,我“同意”你的关闭请求；
>
> 第三次分手: 主机2向主机1发送FIN报文段,请求关闭连接,同时主机2进入LAST_ACK状态；
>
> 第四次分手: 主机1收到主机2发送的FIN报文段,向主机2发送ACK报文段,然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后,就关闭连接；此时,主机1等待2MSL后依然没有收到回复,则证明Server端已正常关闭,那好,主机1也可以关闭连接了。

为什么要四次分手?TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式,这就意味着,当主机1发出FIN报文段时,只是表示主机1已经没有数据要发送了,主机1告诉主机2,它的数据已经全部发送完毕了；但是,这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时,表示它已经知道主机1没有数据发送了,但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时,这个时候就表示主机2也没有数据要发送了,就会告诉主机1,我也没有数据要发送了,之后彼此就会愉快的中断这次TCP连接。


* **TCP流量控制**

如果发送方把数据发送得过快,接收方可能会来不及接收,这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快,要让接收方来得及接收。

利用滑动窗口机制可以很方便地在TCP连接上实现对发送方的流量控制。

设A向B发送数据。在连接建立时,B告诉了A:“我的接收窗口是 rwnd = 400 ”(这里的 rwnd 表示 receiver window) 。因此,发送方的发送窗口不能超过接收方给出的接收窗口的数值。请注意,TCP的窗口单位是字节,不是报文段。假设每一个报文段为100字节长,而数据报文段序号的初始值设为1。大写ACK表示首部中的确认位ACK,小写ack表示确认字段的值ack。

![](https://pic3.zhimg.com/80/v2-3f201a9c8ec8ac605846af624e87ec0e_1440w.jpg)

从图中可以看出,B进行了三次流量控制。第一次把窗口减少到 rwnd = 300 ,第二次又减到了 rwnd = 100 ,最后减到 rwnd = 0 ,即不允许发送方再发送数据了。这种使发送方暂停发送的状态将持续到主机B重新发出一个新的窗口值为止。B向A发送的三个报文段都设置了 ACK = 1 ,只有在ACK=1时确认号字段才有意义。

TCP为每一个连接设有一个持续计时器(persistence timer)。只要TCP连接的一方收到对方的零窗口通知,就启动持续计时器。若持续计时器设置的时间到期,就发送一个零窗口控测报文段(携1字节的数据),那么收到这个报文段的一方就重新设置持续计时器。

* **TCP拥塞控制**

**慢开始和拥塞避免**

发送方维持一个拥塞窗口 cwnd ( congestion window )的状态变量。拥塞窗口的大小取决于网络的拥塞程度,并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口。

发送方控制拥塞窗口的原则是:只要网络没有出现拥塞,拥塞窗口就再增大一些,以便把更多的分组发送出去。但只要网络出现拥塞,拥塞窗口就减小一些,以减少注入到网络中的分组数。

**慢开始算法**

当主机开始发送数据时,如果立即所大量数据字节注入到网络,那么就有可能引起网络拥塞,因为现在并不清楚网络的负荷情况。

因此,较好的方法是 先探测一下,即由小到大逐渐增大发送窗口,也就是说,由小到大逐渐增大拥塞窗口数值。

通常在刚刚开始发送报文段时,先把拥塞窗口 cwnd 设置为一个最大报文段MSS的数值。而在每收到一个对新的报文段的确认后,把拥塞窗口增加至多一个MSS的数值。用这样的方法逐步增大发送方的拥塞窗口 cwnd ,可以使分组注入到网络的速率更加合理。

![](https://pic1.zhimg.com/80/v2-3c66153a90845746b35e79218bdcd430_1440w.jpg)

每经过一个传输轮次,拥塞窗口 cwnd 就加倍。一个传输轮次所经历的时间其实就是往返时间RTT。不过“传输轮次”更加强调:把拥塞窗口cwnd所允许发送的报文段都连续发送出去,并收到了对已发送的最后一个字节的确认。

另,慢开始的“慢”并不是指cwnd的增长速率慢,而是指在TCP开始发送报文段时先设置cwnd=1,使得发送方在开始时只发送一个报文段(目的是试探一下网络的拥塞情况),然后再逐渐增大cwnd。

为了防止拥塞窗口cwnd增长过大引起网络拥塞,还需要设置一个慢开始门限ssthresh状态变量。慢开始门限ssthresh的用法如下:

> 当 cwnd < ssthresh 时,使用上述的慢开始算法。
>
> 当 cwnd > ssthresh 时,停止使用慢开始算法而改用拥塞避免算法。
>
> 当 cwnd = ssthresh 时,既可使用慢开始算法,也可使用拥塞控制避免算法。

**拥塞避免**

让拥塞窗口cwnd缓慢地增大,即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1,而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长,比慢开始算法的拥塞窗口增长速率缓慢得多。


无论在慢开始阶段还是在拥塞避免阶段,只要发送方判断网络出现拥塞(其根据就是没有收到确认),就要把慢开始门限ssthresh设置为出现拥塞时的发送 方窗口值的一半(但不能小于2)。然后把拥塞窗口cwnd重新设置为1,执行慢开始算法。

这样做的目的就是要迅速减少主机发送到网络中的分组数,使得发生 拥塞的路由器有足够时间把队列中积压的分组处理完毕。

如下图,用具体数值说明了上述拥塞控制的过程。现在发送窗口的大小和拥塞窗口一样大。

![](https://pic3.zhimg.com/80/v2-deb5779a8a9cbe34f7359742f56e1fca_1440w.jpg)

* **快重传和快恢复**

**快重传**

快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认(为的是使发送方及早知道有报文段没有到达对方)而不要等到自己发送数据时才进行捎带确认。

![](https://pic1.zhimg.com/80/v2-19a79f44076165f29a45a364906096b4_1440w.jpg)

接收方收到了M1和M2后都分别发出了确认。现在假定接收方没有收到M3但接着收到了M4。

显然,接收方不能确认M4,因为M4是收到的失序报文段。根据 可靠传输原理,接收方可以什么都不做,也可以在适当时机发送一次对M2的确认。

但按照快重传算法的规定,接收方应及时发送对M2的重复确认,这样做可以让 发送方及早知道报文段M3没有到达接收方。发送方接着发送了M5和M6。接收方收到这两个报文后,也还要再次发出对M2的重复确认。这样,发送方共收到了 接收方的四个对M2的确认,其中后三个都是重复确认。

快重传算法还规定,发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段M3,而不必 继续等待M3设置的重传计时器到期。

由于发送方尽早重传未被确认的报文段,因此采用快重传后可以使整个网络吞吐量提高约20%。

**快恢复**

与快重传配合使用的还有快恢复算法,其过程有以下两个要点:

![](https://pic1.zhimg.com/80/v2-cf3af75418ba1eb90d3ade5ebd205fd4_1440w.jpg)

> 当发送方连续收到三个重复确认,就执行“乘法减小”算法,把慢开始门限ssthresh减半。
>
> 与慢开始不同之处是现在不执行慢开始算法(即拥塞窗口cwnd现在不设置为1),而是把cwnd值设置为 慢开始门限ssthresh减半后的数值,然后开始执行拥塞避免算法(“加法增大”),使拥塞窗口缓慢地线性增大。
