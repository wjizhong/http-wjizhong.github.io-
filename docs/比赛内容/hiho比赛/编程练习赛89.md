# 编程练习赛89

## 一、都8102年了

* **描述**

"都8102年了"是2018年网络流行语,8102是将今年年份2018的各位数字倒排的结果,常用来表达“都这个年头了,怎么还有某某事情发生"之意。  

这个梗的关键在于将年份各位数字倒排之后,得到一个非常遥远的未来年份。小Hi想知道,哪些年份适合使用这个梗。具体来说,一个年份Y,倒排之后得到年份X,如果X-Y>=1000,我们就认为Y适合这个梗。  

给定起止年份,请你判断这段时间内有几个年份适合这个梗。

* **输入输出**

> * **输入**

两个正整数代表年份,A和B。  

1000 <= A <= B <= 9999

> * **输出**

一个整数代表答案

样例输入

```
2018 2020
```

样例输出

```
2
```

* **解题代码**

```c++
#include <bits/stdc++.h>
using namespace std;

int main() {
    int A, B, ans = 0;
    scanf("%d %d", &A, &B);
    for(int i = A; i <= B; ++i) {
        int j = i, k = 0;
        for(int t = 0; t < 4; ++t) k = k * 10 + j % 10, j /= 10;
        if(k - i >= 1000) ans++;
    }
    printf("%d\n", ans);
    return 0;
}
```

## 二、地形高度

* **描述**

给定一个NxN的01矩阵,代表一张地图。其中0代表海洋,1代表陆地。  

其中海洋的高度都是0,并且相邻(上下左右)的两个格子的地形高度相差不超过1。  

请你判断地图上最高的格子的高度可能到达多少?

* **输入输出**

> * **输入**

第一行包含一个整数N。  

以下N行包含一个NxN的01矩阵。  

矩阵中至少包含1个0。  

1 <= N <= 1000

> * **输出**

一个整数代表答案

样例输入

```
3
011
001
111
```

样例输出

```
2
```

* **解题代码**

```c++
#include <bits/stdc++.h>
using namespace std;
int vis[1111][1111], M[1111][1111];
typedef pair<int, int> pii;
queue<pii> q;
int N;

int dx[] = {-1, 0, 1, 0};
int dy[] = {0, 1, 0, -1};
inline bool in(int x, int y) {
    return x >= 1 && x <= N && y >= 1 && y <= N;
}

int main() {
    scanf("%d", &N);
    for(int i = 1; i <= N; ++i)
        for(int j = 1; j <= N; ++j)
            M[i][j] = N * N;
    for(int i = 1; i <= N; ++i) {
        char s[1111];
        scanf("%s", s + 1);
        for(int j = 1; j <= N; ++j) {
            if(s[j] == '0') {
                q.push(pii(i, j)), M[i][j] = 0, vis[i][j] = 1;
            }
        }
    }
    while(!q.empty()) {
        pii tmp = q.front(); q.pop();
        int x = tmp.first, y = tmp.second;
        for(int d = 0; d < 4; ++d) {
            int nx = x + dx[d], ny = y + dy[d];
            if(in(nx, ny) && !vis[nx][ny]) {
                q.push(pii(nx, ny));
                vis[nx][ny] = 1;
                M[nx][ny] = M[x][y] + 1;
            }
        }
    }
    int ans = 0;
    for(int i = 1; i <= N; ++i)
        for(int j = 1; j <= N; ++j)
            ans = max(ans, M[i][j]);
    printf("%d\n", ans);
    return 0;
}
```

## 三、区间求并

* **描述**

给定数轴上的N个区间,这些区间可能是开区间、闭区间或者半开半闭区间。请你求出这些区间的并集,并且用最少数量的区间的并表示这个并集。  

例如[0, 10), [10, 15], [16, 30), [30, 30] 的并可以表示成[0, 15], [16, 30]的并。

* **输入输出**

> * **输入**

第一行包含一个整数N。  

以下N行每行一个区间:(A, B)或(A, B]或[A, B)或[A, B]  

1 <= N <= 100000  

0 <= A <= B <= 1000000

> * **输出**

第一行包含一个整数M,代表最少的区间数量。  

以下N行按区间从左到右的顺序每行输出一个区间。

样例输入

```
4  
[10, 15]
[0, 10)  
[16, 30)
[30, 30]
```

样例输出

```
2  
[0, 15]
[16, 30]
```

* **解题代码**

```c++
#include <bits/stdc++.h>
using namespace std;

struct I {
    int l, r, cl, cr;
    I(int _l = 0, int _r = 0, int _cl = 0, int _cr = 0) {
        l = _l, r = _r, cl = _cl, cr = _cr;
    }
    friend bool operator < (I A, I B) {
        if(A.l != B.l) return A.l < B.l;
        return A.cl > B.cl;
    }
};
vector<I> v, ans;

int main() {
    int N;
    scanf("%d", &N); getchar();
    for(int i = 1; i <= N; ++i) {
        int l, r, cl = 0, cr = 0;
        char s[1111];
        gets(s);
        int len = strlen(s);
        for(int j = 0; j < len; ++j) if(s[j] == ',') s[j] = ' ';
        if(s[0] == '[') cl = 1;
        if(s[len - 1] == ']') cr = 1;
        sscanf(s + 1, "%d%d", &l, &r);
        v.emplace_back(I(l, r, cl, cr));
    }
    sort(v.begin(), v.end());
    int l = v[0].l, r = v[0].r, cl = v[0].cl, cr = v[0].cr;
    for(int i = 1; i < v.size(); ++i) {
        if(v[i].l > r || v[i].l == r && !cr && !v[i].cl) {
            ans.emplace_back(I(l, r, cl, cr));
            l = v[i].l, r = v[i].r, cl = v[i].cl, cr = v[i].cr;
        }
        else if(v[i].r > r) r = v[i].r, cr = v[i].cr;
        else if(v[i].r == r) cr |= v[i].cr;
    }
    ans.emplace_back(I(l, r, cl, cr));
    printf("%u\n", ans.size());
    for(int i = 0; i < ans.size(); ++i) {
        putchar(ans[i].cl ? '[' : '(');
        printf("%d, %d", ans[i].l, ans[i].r);
        puts(ans[i].cr ? "]" : ")");
    }
    return 0;
}
```

## 四、奇偶交错排列2

* **描述**

如果一个1~N的排列P=[A1, A2, ... AN]满足任意两个相邻整数都是一个奇数另一个偶数,我们就称P是奇偶交错排列。  

给定两个整数N和K,请你输出所有1~N的奇偶交错排列中按字典序第K小的排列。

* **输入输出**

> * **输入**

两个整数N和K。  

1 <= N <= 100  

1 <= K <= 1000000000

> * **输出**

输出一个排列。

样例输入

```
4 3
```

样例输出

```
2 1 4 3
```


* **解题代码**

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
ll fac[111];

inline ll cal(int odd, int even) {
    return min(fac[odd] * fac[even], 2000000000ll);
}

set<int> O, E;
set<int> :: iterator it;

int main() {
    fac[0] = 1;
    for(int i = 1; i < 111; ++i) fac[i] = min(2000000000ll, fac[i - 1] * i);
    int N, K;
    scanf("%d %d", &N, &K);
    for(int i = 1; i <= N; ++i)
        if(i & 1) O.insert(i);
        else E.insert(i);
    if(N % 2 == 0) {
        ll t = cal(N / 2, N / 2 - 1);
        for(int i = 1; i <= N; ++i) {
            if(i & 1) {
                if(i * t >= K) {
                    O.erase(i); K -= (i - 1) * t;
                    swap(O, E);
                    printf("%d%c", i, 1 == N ? '\n' : ' ');
                    break;
                }
            }
            else {
                if(i * t >= K) {
                    E.erase(i); K -= (i - 1) * t;
                    printf("%d%c", i, 1 == N ? '\n' : ' ');
                    break;
                }
            }
        }
        N--;
    }
    for(int i = 1; i <= N; ++i) {
        int ans = 0;
        if(i & 1) {
            it = O.begin();
            for(int j = 1; j <= O.size(); ++j) {
                if(j * cal(O.size() - 1, E.size()) >= K) {
                    ans = *it; O.erase(ans); K -= (j - 1) * cal(O.size(), E.size());
                    break;
                }
                ++it;
            }
        }
        else {
            it = E.begin();
            for(int j = 1; j <= E.size(); ++j) {
                if(j * cal(O.size(), E.size() - 1) >= K) {
                    ans = *it; E.erase(ans); K -= (j - 1) * cal(O.size(), E.size());
                    break;
                }
                ++it;
            }
        }
        printf("%d%c", ans, i == N ? '\n' : ' ');
    }
    return 0;
}
```
