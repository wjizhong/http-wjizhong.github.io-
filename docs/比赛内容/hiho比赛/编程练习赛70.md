# 编程练习赛70
## P01:数位翻转
* **题目描述**

给定一个数 n，你可以进行若干次操作，每次操作可以翻转 n 的二进制表示下的某一位，即将 0 变成 1，1 变成 0

现在小 Hi 想知道，至少需要多少次操作，才能将 n 变成 n-1

* **输入输出**
* 输入
一个正整数 n

1 ≤ n ≤ 109

* 输出

输出最少的操作次数

样例输入

```
10
```

样例输出

```
2
```

* **解题代码**

```
#include <iostream>
#include <string.h>
#include <stdio.h>
#include <map>
#include <string>
using namespace std;
#define  LL long long
const LL maxn  = 222+55;

int main()
{
	int n;scanf("%d",&n);
	int aim=n^(n-1);
	int ans=0;
	while(aim){
		if(aim&1) ans++;
		aim>>=1;
	}
	cout<<ans<<endl;

}
```
## P02:最短公共子序列
* **题目描述**

给定一个 01 串 A，你需要找一个和它等长的01串 B，使得 A 和 B 的最长公共子序列最短

为了方便，你不需要输出 B，你只需要输出 A 和 B 的最长公共子序列的长度

* **输入输出**

* 输入

第一行一个 01 串 A

1 ≤ |A| ≤ 105

* 输出

输出最短的长度

样例输入

```
000111
```
样例输出

```
3
```

* **解题代码**

```
#include <iostream>
#include <string.h>
#include <stdio.h>
#include <map>
#include <string>
using namespace std;
#define  LL long long
const LL maxn  = 222+55;

int main()
{
	string s;
	cin>>s;
	int zero=0,one=0;
	for(int i=0;i<s.length();i++){
		if(s[i]=='0') zero++;
		else one++;
	}
	cout<<min(zero,one)<<endl;
}
```

## P03: 拼三角形

* **题目描述**

给定 n 根木棍，第 i 根长度为 ai

现在你想用他们拼成尽量多的面积大于 0 的三角形，要求每根木棍只能被用一次，且不能折断

请你求出最多能拼出几个

* **输入输出**

* 输入

第一行一个正整数 n

第二行 n 个正整数 a1 … an

1 ≤ n ≤ 15

1 ≤ ai ≤ 109

* 输出

输出最多能拼出几个三角形

样例输入

```
6
2 2 3 4 5 6
```
样例输出

```
2
```

* **解题代码**

```
#include <iostream>
#include <string.h>
#include <stdio.h>
#include <algorithm>
#include <string>
using namespace std;
#define  LL long long
const LL maxn  = 500+55;

int a[20];
int num[maxn];


bool check(int x,int y,int z)
{
	int b[4];
	b[1]=a[x];b[2]=a[y];b[3]=a[z];
	sort(b+1,b+4);
	if(b[1]+b[2]<=b[3])
		return false;
	return true;
}
int dp[70000];
int main()
{
	int n;
	scanf("%d",&n);
	for(int i=0;i<n;i++){
		scanf("%d",&a[i]);
	}
	int cnt=0;
	for(int i=0;i<n;i++){
		for(int j=i+1;j<n;j++){
			for(int k=j+1;k<n;k++){
				if(check(i,j,k)){
					num[++cnt]=(1<<i)|(1<<j)|(1<<k);
				}
			}
		}
	}
	dp[0]=1;
	int ans=0;
	for(int i=1;i<=cnt;i++){
		for(int j=(1<<n)-1;j>=0;j--){
			if(dp[j]!=0&&(j&num[i])==0){
				dp[j|num[i]]=dp[j]+1;
				ans=max(ans,dp[j]);
			}
		}
	}
	printf("%d\n",ans);


}
```

## P04:神奇的序列

* **题目描述**
小 A 有一个神奇的序列a1, a2 …，这个序列有几个神奇的地方：

1. a1 .. an 是小 A 已知的

2. 对于 x>n，有ax=ax-k1 + ax-k2 + ... ax-kc

现在给定a1 .. an和k1 .. kc，小 A 想请你计算出 am 的值

由于结果可能过大，你只需要输出对 109+9 取模后的值

* **输入输出**

* 输入

第一行三个整数 n, m, c

第二行 n 个整数 a1 .. an

第三行 c 个整数 k1 .. kc

1 ≤ c ≤ n ≤ 20

1 ≤ m ≤ 1018

0 ≤ ai ≤ 10

1 ≤ ki ≤ n

* 输出

输出一个数，表示 am 对 109+9 取模后的值

样例输入

```
2 4 1
1 1
1
```
样例输出

```
1
```

* **解题代码**
```
#include <iostream>
#include <string.h>
#include <stdio.h>
#include <algorithm>
#include <string>
using namespace std;
#define  LL long long
const LL maxn  = 22;
const LL mod = 1e9+9;
LL a[22];
LL n;
struct node
{
	LL a[maxn][maxn];
	void init(){
		memset(a,0,sizeof a);
	}
	node friend operator * (node a,node b)
	{
		node c;
		c.init();
		for(LL i=1;i<=n;i++){
			for(LL j=1;j<=n;j++){
				for(LL k=1;k<=n;k++){
					c.a[i][j]+=a.a[i][k]*b.a[k][j]%mod;
					c.a[i][j]%=mod;
				}
			}
		}
		return c;
	}
};

int main()
{
	LL m,c;
	scanf("%lld%lld%lld",&n,&m,&c);
	for(LL i=1;i<=n;i++){
		scanf("%lld",&a[i]);
	}
	node b;
	b.init();
	for(LL i=1;i<n;i++){
		b.a[i+1][i]=1;
	}
	for(LL i=1;i<=c;i++){
		LL x;scanf("%lld",&x);
		b.a[n+1-x][n]++;
	}
	if(m<=n){
		printf("%lld\n",a[m]);
	}else{
		node ans;
		ans.init();
		for(LL i=1;i<=n;i++) ans.a[i][i]=1;
		m-=n;
		while(m){
			if(m&1) ans=ans*b;
			b=b*b;
			m>>=1;
		}
		LL z=0;
		for(LL i=1;i<=n;i++){
			z+=a[i]*ans.a[i][n]%mod;
			z%=mod;
		}
		printf("%lld\n",z);
	}





}
```