# Hiho第016周:RMQ-ST算法

## 题目描述

小Hi和小Ho在美国旅行了相当长的一段时间之后,终于准备要回国啦!而在回国之前,他们准备去超市采购一些当地特产——比如汉堡(大雾)之类的回国。

但等到了超市之后,小Hi和小Ho发现者超市拥有的商品种类实在太多了——他们实在看不过来了!于是小Hi决定向小Ho委派一个任务:假设整个货架上从左到右拜访了N种商品,并且依次标号为1到N,每次小Hi都给出一段区间[L,R],小Ho要做的是选出标号在这个区间内的所有商品重量最轻的一种,并且告诉小Hi这个商品的重量,于是他们就可以毫不费劲的买上一大堆东西了——多么可悲的选择困难症患者。

(虽然说每次给出的区间仍然要小Hi来进行决定——但是小Hi最终机智的选择了使用随机数生成这些区间!但是为什么小Hi不直接使用随机数生成购物清单呢?——问那么多做什么!)

### 提示一:二分法是宇宙至强之法!(真的么?)

虽说小Ho身经百战,但是面对这样一个他从来没有接触过的问题也一时挠头——数据范围的N和Q都在10^6这个级别,这就意味着至少需要一个时间复杂度为O(Nlog(N))才能解决这个问题。

“如果我对于每个询问都扫描对应的区间,找到最小的值,那么最坏情况和平均情况下都是O(NQ)的时间复杂度,无论数据是不是随即生成的,都不是一个很好的选择。”小Ho如是想道:“这就意味着我需要事先进行一些预处理,使得一些重复计算的东西不再重复计算,才能够将复杂度降低下来。”

小Ho暗自点头,随即想道:“那么如果我对于这整个区间维护一个线段树,维护每棵子树中的最小值,是不是就可以完美解决这个问题了呢?”,于是对小Hi说道:“我觉得线段树可以很好的解决这个问题!。”

“没有错呢~但是相比于线段树来说,我有一个更为容易事先的算法,你想不想听?”小Hi点了点头道。

“更容易实现?就是代码量更小咯?”小Ho作为一个懒病患者自然是很乐意:“快教我!”

“其实你利用线段树也就是这样来减少复杂度的——先预先计算一些区间的最小值,然后把每个询问都拆成若干个计算了最小值的区间,并且统计这些区间的最小值的最小值,从而得出答案的。”小Hi先总结道:“那么其实我可以将统计的区间这样规定——统计所有长度为2的非负整数次幂的区间。”

“整数次幂?也就是长度为1、2、4、8之类的区间咯?”小Ho答道:“我想想……如果我统计的是这些长度的区间的话,用pre\_calc[L, Len]表示左边界为L,长度为Len的区间中的最小值——那么对于一个询问[Li, Ri],我只要找到小于这个区间长度的最大的2的非负整数次幂——T,那么这个区间中的最小值就是min{pre\_calc[Li, T], pre\_calc[Ri-T+1, T]}咯?”

“反应的很快嘛,你看这样对于每一个询问,是不是就可以只用O(1)的时间复杂度就可以作出回答了,而且就只用一条很简单的语句而已。”小Hi笑道。

“但是我还不知道怎么求这些`pre_calc`啊?”小Ho不禁问道。

“我先问你,对于所有的i满足1<=i<=N, `pre_calc[i, 1]`是不是很好求?”小Hi反问道。

“唔……是的,`pre_calc[i, 1]`就是标号为i的物品的重量`weight_i`。”小Ho答道。

“那么对于,所有的i, j满足1<=i<=N, 1<2^j<=N,`pre_calc[i, 2^j]=min{pre_calc[i, 2^(j-1)]`, `pre_calc[i+2^(j-1), 2^(j-1)]`}是不是成立的?”小Hi继续问道。

“额……将一个区间,分解成两个一半长度的区间,利用已经求出的值进行计算,非常的合理!”小Ho赞叹道:“甚至于只需要一个二维循环就能够计算出来了。”

“怎么样!是不是比线段树简单许多呢?”小Hi笑道。

### 提示二:线段树不也是二分法么?

那这又是为什么呢……我感觉这两种方法都是二分区间啊。”小Ho生出一个疑问。

“这是由于这道题目的性质决定的啦,这个区间上的值都是已经确定的——如果在询问的过程中,这些商品的重量还会发生改变,那么自然就不是我们之前提到的算法——ST算法能够解决的了。”小Hi点出了一个要点。

“原来是这样,等等我还发现这和求的是最值有关,如果求的是和值的话,由于[Li,T]和[Ri-T+1,T]这两段区间可能会有重叠的情况,所以也是无法求解的呢!”小Ho很快也找到了另一个问题。

“是的呢!所以你现在应该知道了把——充分利用题目的特性,就能够很好的减少你编程的复杂度~当然你还要注意到这两种算法的时间复杂度其实是不一样的哦,但是因为这里的N和Q是一个数量级,所以才不会影响到你的解题方法呢。”

“原来是这样!”小Ho点了点头:“那么我去写程序啦!”

Tips:在记录`pre_calc[i, 2^j]`的时候,不要傻乎乎的就这么存了,事实上只要用`pre_calc'[i, j]`的格式进行存储就可以了!

## 输入输出

* **输入**

每个测试点(输入文件)有且仅有一组测试数据。

每组测试数据的第1行为一个整数N,意义如前文所述。

每组测试数据的第2行为N个整数,分别描述每种商品的重量,其中第i个整数表示标号为i的商品的重量weight\_i。

每组测试数据的第3行为一个整数Q,表示小Hi总共询问的次数。

每组测试数据的第N+4~N+Q+3行,每行分别描述一个询问,其中第N+i+3行为两个整数Li, Ri,表示小Hi询问的一个区间[Li, Ri]。

对于100%的数据,满足N\<=10^6,Q\<=10^6, 1\<=Li\<=Ri\<=N,`0<weight\_i<=10^4`。

* **输出**

对于每组测试数据,对于每个小Hi的询问,按照在输入中出现的顺序,各输出一行,表示查询的结果:标号在区间[Li, Ri]中的所有商品中重量最轻的商品的重量。

样例输入

```sh
10
7334
1556
8286
1640
2699
4807
8068
981
4120
2179
5
3 4
2 8
2 4
6 8
7 10
```

样例输出

```sh
1640
981
1556
981
981
```

## 解题代码

```c++
#include <bits/stdc++.h>
using namespace std;
int f[1000010][20],n,a,b,c;
int main(){
    cin>>n;
    for(int i=1;i<=n;++i)scanf("%d",&f[i][0]);
    for(int i=1;(1<<i)<=n;++i)for(int j=1;j+(1<<i)-1<=n;++j)f[j][i]=min(f[j][i-1],f[j+(1<<i-1)][i-1]);
    for(cin>>n;n--;){
        scanf("%d%d",&a,&b);
        c=int(log(b-a+1)/log(2));
        printf("%d\n",min(f[a][c],f[b-(1<<c)+1][c]));
    }
    return 0;
}
```
