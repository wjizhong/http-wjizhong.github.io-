# 题目0155:最小栈

## 题目描述

设计一个支持push,pop,top操作，并能在常数时间内检索到最小元素的栈。

> push(x) —— 将元素 x 推入栈中。
> 
> pop() —— 删除栈顶的元素。
> 
> top() —— 获取栈顶元素。
> 
> getMin() —— 检索栈中的最小元素。
 

示例:

```
输入:
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

输出：
[null,null,null,null,-3,null,0,-2]

解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.
```

## 解题技巧

<video src="../leetcode/images/a68ab94124164ad4a975778ab5aeff03b942cd69de124b799b762072007241f6.mp4" controls></video>

* **方法一:辅助栈**

思路:要做出这道题目,首先要理解栈结构先进后出的性质。

对于栈来说,如果一个元素a在入栈时,栈里有其它的元素b,c,d,那么无论这个栈在之后经历了什么操作,只要a在栈中,b,c,d就一定在栈中,因为在a被弹出之前,b,c,d不会被弹出。

因此,在操作过程中的任意一个时刻,只要栈顶的元素是a,那么我们就可以确定栈里面现在的元素一定是a,b,c,d。

那么,我们可以在每个元素a入栈时把当前栈的最小值m存储起来。在这之后无论何时,如果栈顶元素是a,我们就可以直接返回存储的最小值m。

![](http://assets.leetcode-cn.com/solution-static/155/155_fig1.gif)

算法:按照上面的思路,我们只需要设计一个数据结构,使得每个元素a与其相应的最小值m时刻保持一一对应。因此我们可以使用一个辅助栈,与元素栈同步插入与删除,用于存储与每个元素对应的最小值。

当一个元素要入栈时,我们取当前辅助栈的栈顶存储的最小值,与当前元素比较得出最小值,将这个最小值插入辅助栈中;

当一个元素要出栈时,我们把辅助栈的栈顶元素也一并弹出;

在任意一个时刻,栈内元素的最小值就存储在辅助栈的栈顶元素中。

```python
class MinStack:
    def __init__(self):
        self.stack = []
        self.min_stack = [math.inf]

    def push(self, x: int) -> None:
        self.stack.append(x)
        self.min_stack.append(min(x, self.min_stack[-1]))

    def pop(self) -> None:
        self.stack.pop()
        self.min_stack.pop()

    def top(self) -> int:
        return self.stack[-1]

    def getMin(self) -> int:
        return self.min_stack[-1]
```

复杂度分析

> 时间复杂度:对于题目中的所有操作,时间复杂度均为O(1)。因为栈的插入、删除与读取操作都是O(1),我们定义的每个操作最多调用栈操作两次。
> 
> 空间复杂度:O(n),其中n为总操作数。最坏情况下,我们会连续插入n个元素,此时两个栈占用的空间为O(n)。

