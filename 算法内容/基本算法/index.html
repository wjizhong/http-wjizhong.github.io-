<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <meta name="author" content="wjizhong">
    <link rel="canonical" href="https://wjizhong.github.io/%E7%AE%97%E6%B3%95%E5%86%85%E5%AE%B9/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/">
    <link rel="shortcut icon" href="https://pic.pngsucai.com/00/18/26/4a7884c36067e596.jpg">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>基本算法 - 图像/视频算法</title>
    <link href="../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../css/highlight.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../js/jquery-3.2.1.min.js"></script>
    <script src="../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "\u57fa\u672c\u51fd\u6570\u7684\u8ba1\u7b97\u673a\u5b9e\u73b0", url: "#_top", level:1, children: [
              {title: "\u4e00\u3001\u5e38\u89c1\u7684\u7535\u8def", url: "#_2", level:2, children: [ 
              ]},
              {title: "\u4e8c\u3001\u57fa\u672c\u7684\u6a21\u62df\u7535\u8def", url: "#_3", level:2, children: [ 
              ]},
              {title: "\u4e09\u3001\u57fa\u672c\u51fd\u6570\u5b9e\u73b0\u539f\u7406", url: "#_4", level:2, children: [
                  {title: "3.1 Taylor\u7ea7\u6570/\u5c55\u5f00", url: "#31-taylor", level:3, children: [
                  ]},
                  {title: "3.2 \u5e73\u65b9\u6839\u5012\u6570\u901f\u7b97\u6cd5", url: "#32", level:3, children: [
                  ]}, 
              ]},
              {title: "\u56db\u3001\u57fa\u672c\u51fd\u6570\u5b9e\u73b0\u4ee3\u7801", url: "#_5", level:2, children: [ 
              ]},
          ]},
          {title: "include \"fdlibm.h\"", url: "#include-fdlibmh", level:1, children: [
          ]},
          {title: "define one xxx[13]", url: "#define-one-xxx13", level:1, children: [
          ]},
          {title: "define pio4    xxx[14]", url: "#define-pio4-xxx14", level:1, children: [
          ]},
          {title: "define pio4lo  xxx[15]", url: "#define-pio4lo-xxx15", level:1, children: [
          ]},
          {title: "define T   xxx", url: "#define-t-xxx", level:1, children: [
          ]},
          {title: "include \"fdlibm.h\"", url: "#include-fdlibmh_1", level:1, children: [
          ]},
          {title: "ifdef STDC", url: "#ifdef-stdc", level:1, children: [
          ]},
          {title: "else", url: "#else", level:1, children: [
          ]},
          {title: "endif", url: "#endif", level:1, children: [
          ]},
          {title: "ifdef _IEEE_LIBM", url: "#ifdef-_ieee_libm", level:1, children: [
          ]},
          {title: "else", url: "#else_1", level:1, children: [
          ]},
          {title: "endif", url: "#endif_1", level:1, children: [
          ]},
        ];
    </script>
    <script src="../../js/base.js"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    <style>
blockquote{
    font-size: 99%;
}
</style>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  CommonHTML: {
    scale: 100
  }
});
</script>
<script type="text/javascript" async
src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


    
    
      
    

    

    <h1 id="_1">基本函数的计算机实现</h1>
<h2 id="_2">一、常见的电路</h2>
<ul>
<li><strong>通用的电路符号图库</strong></li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>符号</th>
<th>名称</th>
<th>符号</th>
<th>名称</th>
<th>符号</th>
</tr>
</thead>
<tbody>
<tr>
<td>电池,1个电池,多个电池</td>
<td><img alt="" src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/be/Symbol_baterie_2.svg/240px-Symbol_baterie_2.svg.png" /></td>
<td>电容器</td>
<td><img alt="" src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/89/Capacitor_Symbol.svg/240px-Capacitor_Symbol.svg.png" /></td>
<td>电解电容器(ANSI)</td>
<td><img alt="" src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/7c/Polarized_capacitor_symbol.svg/240px-Polarized_capacitor_symbol.svg.png" /></td>
</tr>
<tr>
<td>可变电容器</td>
<td><img alt="" src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/1b/Variable_capacitor_symbol.svg/240px-Variable_capacitor_symbol.svg.png" /></td>
<td>二极管</td>
<td><img alt="" src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/b4/Diode_symbol.svg/240px-Diode_symbol.svg.png" /></td>
<td>齐纳二极管</td>
<td><img alt="" src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/7f/Zener_diode_symbol.svg/240px-Zener_diode_symbol.svg.png" /></td>
</tr>
<tr>
<td>隧道二极管(Tunnel diode)</td>
<td><img alt="" src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/c4/Tunnel_diode_symbol.svg/240px-Tunnel_diode_symbol.svg.png" /></td>
<td>发光二极管(LED)</td>
<td><img alt="" src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/e5/LED_symbol.svg/240px-LED_symbol.svg.png" /></td>
<td>光电二极管</td>
<td><img alt="" src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/2b/Photodiode_symbol.svg/240px-Photodiode_symbol.svg.png" /></td>
</tr>
<tr>
<td>可控硅整流器(Silicon-controlled rectifier)</td>
<td><img alt="" src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/e0/SCR_symbol.svg/240px-SCR_symbol.svg.png" /></td>
<td>变容二极管(Varicap)</td>
<td><img alt="" src="https://upload.wikimedia.org/wikipedia/commons/thumb/0/0e/Varicap_symbol.svg/240px-Varicap_symbol.svg.png" /></td>
<td>肖特基二极管</td>
<td><img alt="" src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/c9/Schottky_diode_symbol.svg/240px-Schottky_diode_symbol.svg.png" /></td>
</tr>
<tr>
<td>保险丝:IEC(上)与ANSI(中与下)</td>
<td><img alt="" src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/5d/Fuse-basic-symbols.svg/160px-Fuse-basic-symbols.svg.png" /></td>
<td>电感元件</td>
<td><img alt="" src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/4b/Inductor.svg/240px-Inductor.svg.png" /></td>
<td>TRS插口</td>
<td><img alt="" src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/77/Phone_Jack_Symbols.svg/240px-Phone_Jack_Symbols.svg.png" /></td>
</tr>
<tr>
<td>可变电阻(ANSI)</td>
<td><img alt="" src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/b9/Pot_schemA.svg/240px-Pot_schemA.svg.png" /></td>
<td>电阻器:ANSI(上)与IEC(下)</td>
<td><img alt="" src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/25/Resistors.svg/240px-Resistors.svg.png" /></td>
<td>开关,单刀/单掷(SPST)</td>
<td><img alt="" src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/46/SPST-Switch.svg/240px-SPST-Switch.svg.png" /></td>
</tr>
<tr>
<td>开关,单刀/双掷(SPDT:single port double throw)</td>
<td><img alt="" src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/b6/SPDT-Switch.svg/240px-SPDT-Switch.svg.png" /></td>
<td>开关,双刀/双掷(DPDT)</td>
<td><img alt="" src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/ec/DPDT-symbol.svg/188px-DPDT-symbol.svg.png" /></td>
<td>变压器,右线圈中间有抽头</td>
<td><img alt="" src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/28/Transformer_Centre-tap_Iron_Core.svg/240px-Transformer_Centre-tap_Iron_Core.svg.png" /></td>
</tr>
<tr>
<td>NPN晶体管</td>
<td><img alt="" src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/cb/BJT_NPN_symbol_%28case%29.svg/240px-BJT_NPN_symbol_%28case%29.svg.png" /></td>
<td>PNP晶体管</td>
<td><img alt="" src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/ab/BJT_PNP_symbol_%28case%29.svg/240px-BJT_PNP_symbol_%28case%29.svg.png" /></td>
<td>n-沟道JFET</td>
<td><img alt="" src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/6d/JFET_N-dep_symbol.svg/240px-JFET_N-dep_symbol.svg.png" /></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>p-沟道JFET</td>
<td><img alt="" src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/5b/JFET_P-dep_symbol.svg/240px-JFET_P-dep_symbol.svg.png" /></td>
<td>场效晶体管</td>
<td><img alt="" src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/61/IGFET_N-Ch_Enh_Labelled_simplified.svg/240px-IGFET_N-Ch_Enh_Labelled_simplified.svg.png" /></td>
<td>真空管二极管</td>
<td><img alt="" src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/d8/Dioda_symbol.svg/240px-Dioda_symbol.svg.png" /></td>
</tr>
<tr>
<td>真空管三极管</td>
<td><img alt="" src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/66/Trioda_symbol.svg/240px-Trioda_symbol.svg.png" /></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>真空管五极管</td>
<td><img alt="" src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/2f/Pentoda_symbol.svg/174px-Pentoda_symbol.svg.png" /></td>
<td>真空管四极管</td>
<td><img alt="" src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/e5/Vacuum_Tube_Tetrode.svg/240px-Vacuum_Tube_Tetrode.svg.png" /></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li><strong>经典电路</strong></li>
</ul>
<p><strong>桥式整流电路</strong></p>
<p><img alt="" src="http://discourse-production.oss-cn-shanghai.aliyuncs.com/original/3X/1/e/1ed987e6dcd8cb55b7bfb29c2256dd9b8d75fffc.jpg" /></p>
<p><strong>功率放大电路</strong></p>
<p><img alt="" src="http://discourse-production.oss-cn-shanghai.aliyuncs.com/original/3X/a/2/a2d82be67b864ec13557a9c36a89efd4067aedcf.jpg" /></p>
<p><strong>石英晶体振荡电路</strong></p>
<p><img alt="" src="http://discourse-production.oss-cn-shanghai.aliyuncs.com/original/3X/8/5/85e896247b5576e1983373367174d25a8f2927f8.jpg" /></p>
<p><strong>LC振荡电路</strong></p>
<p><img alt="" src="http://discourse-production.oss-cn-shanghai.aliyuncs.com/original/3X/f/6/f6bbd6440ce77651639f8194c4f9baf2c508eb30.jpg" /></p>
<p><strong>RC振荡电路</strong></p>
<p><img alt="" src="http://discourse-production.oss-cn-shanghai.aliyuncs.com/original/3X/0/a/0a56d5296d1f6d162e1886779e890643b0203887.jpg" /></p>
<p><strong>电压比较电路</strong></p>
<p><img alt="" src="http://discourse-production.oss-cn-shanghai.aliyuncs.com/original/3X/c/7/c71bf913c3040944bf1d8fc78da76ab6afbf78d3.jpg" /></p>
<p><strong>差分输入运算放大电路</strong></p>
<p><img alt="" src="http://discourse-production.oss-cn-shanghai.aliyuncs.com/original/3X/9/3/93d7a9ee6700eaf6a9cac7b58a978d0f147f7655.jpg" /></p>
<p><strong>运算放大电路</strong></p>
<p><img alt="" src="http://discourse-production.oss-cn-shanghai.aliyuncs.com/original/3X/b/6/b673a237c0c864ef252efc9d5eb88dac29d56ef4.jpg" /></p>
<p><strong>选频(带通)放大电路</strong></p>
<p><img alt="" src="http://discourse-production.oss-cn-shanghai.aliyuncs.com/original/3X/6/0/600204b63cc782fd7181339a42c78c38db69f2d1.jpg" /></p>
<p><strong>场效应管放大电路</strong></p>
<p><img alt="" src="http://discourse-production.oss-cn-shanghai.aliyuncs.com/original/3X/c/3/c33d84ff20c8476e0ddf3287acb5e21dc4998e7d.jpg" /></p>
<p><strong>差分放大电路</strong></p>
<p><img alt="" src="http://discourse-production.oss-cn-shanghai.aliyuncs.com/original/3X/d/f/dfeb6ddfcc5c5acbf4dd6a2693a0bed64e4e4def.jpg" /></p>
<p><strong>串联稳压电源</strong></p>
<p><img alt="" src="http://discourse-production.oss-cn-shanghai.aliyuncs.com/original/3X/1/5/154132e3d755f65ac1743a5425b51582b53d18db.jpg" /></p>
<p><strong>二极管稳压电路</strong></p>
<p><img alt="" src="http://discourse-production.oss-cn-shanghai.aliyuncs.com/original/3X/1/b/1b2fdb96309fdf9479397093f808627b6f0f6056.jpg" /></p>
<p><strong>电路反馈框图</strong></p>
<p><img alt="" src="http://discourse-production.oss-cn-shanghai.aliyuncs.com/original/3X/8/2/828df7fb63a222ae4df24ce594ae2f3dc366cc90.jpg" /></p>
<p><strong>共集电极放大电路(射极跟随器)</strong></p>
<p><img alt="" src="http://discourse-production.oss-cn-shanghai.aliyuncs.com/original/3X/3/7/3706cc8e5550b17173f162a1ff7e733d7b02a85a.jpg" /></p>
<p><strong>分压偏置式共射极放大电路</strong></p>
<p><img alt="" src="http://discourse-production.oss-cn-shanghai.aliyuncs.com/original/3X/5/4/5405c802b2d8f6ec921ad8be053982e05526097d.jpg" /></p>
<p><strong>共射极放大电路</strong></p>
<p><img alt="" src="http://discourse-production.oss-cn-shanghai.aliyuncs.com/original/3X/6/a/6a6699de719be3f749b2c3eb629a79a4624be0c1.jpg" /></p>
<p><strong>微分和积分电路</strong></p>
<p><img alt="" src="http://discourse-production.oss-cn-shanghai.aliyuncs.com/original/3X/8/2/82f1586b4394c68c4c9a62337395ce35c57ccf4a.jpg" /></p>
<p><strong>信号滤波器</strong></p>
<p><img alt="" src="http://discourse-production.oss-cn-shanghai.aliyuncs.com/original/3X/6/7/67700511ecea33567eebb28759f3b3f03430d8a4.jpg" /></p>
<p><strong>电源滤波器</strong></p>
<p><img alt="" src="http://discourse-production.oss-cn-shanghai.aliyuncs.com/original/3X/8/8/88fa17b7e84e301f4e8010ed04ad3c9ef7784152.jpg" /></p>
<h2 id="_3">二、基本的模拟电路</h2>
<h2 id="_4">三、基本函数实现原理</h2>
<h3 id="31-taylor">3.1 Taylor级数/展开</h3>
<p>在数学中,泰勒级数用无限项连加式——级数来表示一个函数,这些相加的项由函数在某一点的导数求得。泰勒级数是以于1715年发表了泰勒公式的英国数学家布鲁克·泰勒(Sir Brook Taylor)来命名的。通过函数在自变量零点的导数求得的泰勒级数又叫做麦克劳林级数,以苏格兰数学家科林·麦克劳林的名字命名。</p>
<p>拉格朗日在1797年之前,最先提出带有余项的现在形式的泰勒定理。实际应用中,泰勒级数需要截断,只取有限项,可以用泰勒定理估算这种近似的误差。一个函数的有限项的泰勒级数叫做泰勒多项式。一个函数的泰勒级数是其泰勒多项式的极限(如果存在极限)。即使泰勒级数在每点都收敛,函数与其泰勒级数也可能不相等。在开区间(或复平面上的开区间)上,与自身泰勒级数相等的函数称为解析函数。</p>
<p>在数学上,对于一个在实数或复数<span><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span>邻域上,以实数作为变量或以复数作为变量的函数,并且是无穷可微的函数<span><span class="MathJax_Preview">f(x)</span><script type="math/tex">f(x)</script></span>,它的泰勒级数是以下这种形式的幂级数:</p>
<div>
<div class="MathJax_Preview">
\sum _{n=0}^{\infty }{\frac {f^{(n)}(a)}{n!}}(x-a)^{n}
</div>
<script type="math/tex; mode=display">
\sum _{n=0}^{\infty }{\frac {f^{(n)}(a)}{n!}}(x-a)^{n}
</script>
</div>
<p>这里,<span><span class="MathJax_Preview">n!</span><script type="math/tex">n!</script></span>表示<span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>的阶乘,而<span><span class="MathJax_Preview">f^{(n)}(a)\,\!</span><script type="math/tex">f^{(n)}(a)\,\!</script></span>表示函数<span><span class="MathJax_Preview">f</span><script type="math/tex">f</script></span>在点<span><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span>处的<span><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span>阶导数。如果<span><span class="MathJax_Preview">a=0</span><script type="math/tex">a=0</script></span>,也可以把这个级数称为麦克劳林级数。</p>
<ul>
<li><strong>解析函数</strong></li>
</ul>
<p>柯西在1823年指出函数<span><span class="MathJax_Preview">\exp \left(-{\frac {1}{x^{2}}}\right)</span><script type="math/tex">\exp \left(-{\frac {1}{x^{2}}}\right)</script></span>在<span><span class="MathJax_Preview">x=0</span><script type="math/tex">x=0</script></span>无法被解析。
如果泰勒级数对于区间<span><span class="MathJax_Preview">(a-r,a+r)</span><script type="math/tex">(a-r,a+r)</script></span>中的所有<span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span>都收敛并且级数的和等于<span><span class="MathJax_Preview">f(x)</span><script type="math/tex">f(x)</script></span>,那么我们就称函数<span><span class="MathJax_Preview">f(x)</span><script type="math/tex">f(x)</script></span>为解析形的函数(analytic)。一个函数当且仅当(简单地说,“只有在”)能够被表示为幂级数的形式时,才是解析的函数。通常会用泰勒定理来估计级数的余项,这样就能够确定级数是否收敛于<span><span class="MathJax_Preview">f(x)</span><script type="math/tex">f(x)</script></span>。上面给出的幂级数展开式中的系数正好是泰勒级数中的系数。</p>
<p>以下三个事实可以说明为什么泰勒级数是十分重要的:</p>
<blockquote>
<ul>
<li>可以逐项对幂级数的计算微分和积分,因此求和函数相对比较容易。</li>
<li>数学家因此能够在复数平面上研究函数,因为一个解析函数,也可以被定义为在复平面中一个开放的区间内的解析函数(在区间内每一个点上都能被微分的函数)。</li>
<li>可用泰勒级数估计,在某一点上函数会计算出什么值。</li>
</ul>
</blockquote>
<p>对于一些无穷的可以被微分函数<span><span class="MathJax_Preview">f(x)</span><script type="math/tex">f(x)</script></span>,虽然它们的展开式会收敛,但是并不等于<span><span class="MathJax_Preview">f(x)</span><script type="math/tex">f(x)</script></span>。例如,分段函数<span><span class="MathJax_Preview">f(x)=\exp \left(-{\frac {1}{x^{2}}}\right)</span><script type="math/tex">f(x)=\exp \left(-{\frac {1}{x^{2}}}\right)</script></span>,如果<span><span class="MathJax_Preview">x \ne 0</span><script type="math/tex">x \ne 0</script></span>并且<span><span class="MathJax_Preview">f(0)=0</span><script type="math/tex">f(0)=0</script></span>,则<span><span class="MathJax_Preview">x=0</span><script type="math/tex">x=0</script></span>时所有的导数都为零,所以这个<span><span class="MathJax_Preview">f(x)</span><script type="math/tex">f(x)</script></span>的泰勒级数为零,且其收敛半径为无穷大,不过函数<span><span class="MathJax_Preview">f(x)</span><script type="math/tex">f(x)</script></span>仅在<span><span class="MathJax_Preview">x=0</span><script type="math/tex">x=0</script></span>处为零。但是,在以复数作为变量的函数中这个问题并不存在,因为当<span><span class="MathJax_Preview">z</span><script type="math/tex">z</script></span>沿虚轴趋于零,<span><span class="MathJax_Preview">\exp \left(-{\frac {1}{z^{2}}}\right)</span><script type="math/tex">\exp \left(-{\frac {1}{z^{2}}}\right)</script></span>并不趋于零。</p>
<p>如果一个函数在某处引发一个奇点,它就无法被展开为泰勒级数,不过如果变量<span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span>是负指数幂的话,我们仍然可以将其展开为一个级数。例如,虽然在<span><span class="MathJax_Preview">x=0</span><script type="math/tex">x=0</script></span>的时候,<span><span class="MathJax_Preview">f(x)=\exp \left(-{\frac {1}{x^{2}}}\right)</span><script type="math/tex">f(x)=\exp \left(-{\frac {1}{x^{2}}}\right)</script></span>会引发奇点,但仍然能够把这个函数展开为一个洛朗级数。</p>
<p>最近,专家们发现了一个用泰勒级数来求解微分方程的方法——Parker-Sochacki method[1]。用皮卡迭代便可以推导出这个方法。</p>
<ul>
<li><strong>常用的函数的麦克劳林序列</strong></li>
</ul>
<p>下面我们给出了几个重要的泰勒级数。当变量<span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span>是复数时,这些等式依然成立。</p>
<p><strong>几何级数</strong></p>
<div>
<div class="MathJax_Preview">
{\frac {1}{1-x}}=\sum _{n=0}^{\infty }x^{n}=1+x+x^{2}+\cdots +x^{n}+\cdots \quad \forall x:\left|x\right|&lt;1
</div>
<script type="math/tex; mode=display">
{\frac {1}{1-x}}=\sum _{n=0}^{\infty }x^{n}=1+x+x^{2}+\cdots +x^{n}+\cdots \quad \forall x:\left|x\right|<1
</script>
</div>
<p><strong>二项式级数</strong></p>
<div>
<div class="MathJax_Preview">
(1+x)^{\alpha }=\sum _{n=0}^{\infty }{\binom {\alpha }{n}}x^{n}=1+\alpha x+{\frac {\alpha (\alpha -1)}{2!}}x^{2}+\cdots +{\frac {\alpha (\alpha -1)\cdots (\alpha -n+1)}{n!}}x^{n}+\cdots 
\forall x:\left|x\right|&lt;1,\forall \alpha \in \mathbb {C} 
</div>
<script type="math/tex; mode=display">
(1+x)^{\alpha }=\sum _{n=0}^{\infty }{\binom {\alpha }{n}}x^{n}=1+\alpha x+{\frac {\alpha (\alpha -1)}{2!}}x^{2}+\cdots +{\frac {\alpha (\alpha -1)\cdots (\alpha -n+1)}{n!}}x^{n}+\cdots 
\forall x:\left|x\right|<1,\forall \alpha \in \mathbb {C} 
</script>
</div>
<p>其中二项式系数<span><span class="MathJax_Preview">{\binom {\alpha }{n}}=\prod _{k=1}^{n}{\frac {\alpha -k+1}{k}}={\frac {\alpha (\alpha -1)\cdots (\alpha -n+1)}{n!}}</span><script type="math/tex">{\binom {\alpha }{n}}=\prod _{k=1}^{n}{\frac {\alpha -k+1}{k}}={\frac {\alpha (\alpha -1)\cdots (\alpha -n+1)}{n!}}</script></span>。</p>
<p><strong>指数函数和自然对数</strong></p>
<p>以<span><span class="MathJax_Preview">e</span><script type="math/tex">e</script></span>为底数的指数函数的麦克劳林序列是</p>
<div>
<div class="MathJax_Preview">
e^{x}=\sum _{n=0}^{\infty }{\frac {x^{n}}{n!}}=1+x+{\frac {x^{2}}{2!}}+{\frac {x^{3}}{3!}}+\cdots +{\frac {x^{n}}{n!}}+\cdots \quad \forall x \, (\text{对所有}X\text{都成立})
</div>
<script type="math/tex; mode=display">
e^{x}=\sum _{n=0}^{\infty }{\frac {x^{n}}{n!}}=1+x+{\frac {x^{2}}{2!}}+{\frac {x^{3}}{3!}}+\cdots +{\frac {x^{n}}{n!}}+\cdots \quad \forall x \, (\text{对所有}X\text{都成立})
</script>
</div>
<p>以<span><span class="MathJax_Preview">e</span><script type="math/tex">e</script></span>为底数的自然对数的麦克劳林序列是</p>
<div>
<div class="MathJax_Preview">
\begin{aligned}
    &amp; \ln(1-x)=-\sum _{n=1}^{\infty }{\frac {x^{n}}{n}}=-x-{\frac {x^{2}}{2}}-{\frac {x^{3}}{3}}-\cdots -{\frac {x^{n}}{n}}-\cdots \quad \forall x\in [-1,1)\,(\text{对于在区间}[-1,1)\text{内所有的}X\text{都成立}) \\
    &amp; \ln(1+x)=\sum _{n=1}^{\infty }{\frac {(-1)^{n+1}}{n}}x^{n}=x-{\frac {x^{2}}{2}}+{\frac {x^{3}}{3}}-\cdots +{\frac {(-1)^{n+1}}{n}}x^{n}+\cdots \quad \forall x\in (-1,1]\,(\text{对于在区间}(-1,1]\text{内所有的}X\text{都成立})
\end{aligned}
</div>
<script type="math/tex; mode=display">
\begin{aligned}
    & \ln(1-x)=-\sum _{n=1}^{\infty }{\frac {x^{n}}{n}}=-x-{\frac {x^{2}}{2}}-{\frac {x^{3}}{3}}-\cdots -{\frac {x^{n}}{n}}-\cdots \quad \forall x\in [-1,1)\,(\text{对于在区间}[-1,1)\text{内所有的}X\text{都成立}) \\
    & \ln(1+x)=\sum _{n=1}^{\infty }{\frac {(-1)^{n+1}}{n}}x^{n}=x-{\frac {x^{2}}{2}}+{\frac {x^{3}}{3}}-\cdots +{\frac {(-1)^{n+1}}{n}}x^{n}+\cdots \quad \forall x\in (-1,1]\,(\text{对于在区间}(-1,1]\text{内所有的}X\text{都成立})
\end{aligned}
</script>
</div>
<p><strong>三角函数</strong></p>
<p>常用的三角函数可以被展开为以下的麦克劳林序列:</p>
<div>
<div class="MathJax_Preview">
\begin{aligned}
    \sin x&amp;=\sum _{n=0}^{\infty }{\frac {(-1)^{n}}{(2n+1)!}}x^{2n+1}&amp;&amp;=x-{\frac {x^{3}}{3!}}+{\frac {x^{5}}{5!}}-\cdots &amp;&amp;\forall x
    \\[6pt]\cos x&amp;=\sum _{n=0}^{\infty }{\frac {(-1)^{n}}{(2n)!}}x^{2n}&amp;&amp;=1-{\frac {x^{2}}{2!}}+{\frac {x^{4}}{4!}}-\cdots &amp;&amp;\forall x
    \\[6pt]\tan x&amp;=\sum _{n=1}^{\infty }{\frac {B_{2n}(-4)^{n}\left(1-4^{n}\right)}{(2n)!}}x^{2n-1}&amp;&amp;=x+{\frac {x^{3}}{3}}+{\frac {2x^{5}}{15}}+\cdots &amp;&amp;\forall x:|x|&lt;{\frac {\pi }{2}}
    \\[6pt]\sec x&amp;=\sum _{n=0}^{\infty }{\frac {(-1)^{n}E_{2n}}{(2n)!}}x^{2n}&amp;&amp;=1+{\frac {x^{2}}{2}}+{\frac {5x^{4}}{24}}+\cdots &amp;&amp;\forall x:|x|&lt;{\frac {\pi }{2}}
    \\[6pt]\arcsin x&amp;=\sum _{n=0}^{\infty }{\frac {(2n)!}{4^{n}(n!)^{2}(2n+1)}}x^{2n+1}&amp;&amp;=x+{\frac {x^{3}}{6}}+{\frac {3x^{5}}{40}}+\cdots &amp;&amp;\forall x:|x|\leq 1
    \\[6pt]\arccos x&amp;={\frac {\pi }{2}}-\arcsin x\\&amp;={\frac {\pi }{2}}-\sum _{n=0}^{\infty }{\frac {(2n)!}{4^{n}(n!)^{2}(2n+1)}}x^{2n+1}&amp;&amp;={\frac {\pi }{2}}-x-{\frac {x^{3}}{6}}-{\frac {3x^{5}}{40}}+\cdots &amp;&amp;\forall x:|x|\leq 1
    \\[6pt]\arctan x&amp;=\sum _{n=0}^{\infty }{\frac {(-1)^{n}}{2n+1}}x^{2n+1}&amp;&amp;=x-{\frac {x^{3}}{3}}+{\frac {x^{5}}{5}}-\cdots &amp;&amp;\forall x:|x|\leq 1,\ x\neq \pm i
\end{aligned}
</div>
<script type="math/tex; mode=display">
\begin{aligned}
    \sin x&=\sum _{n=0}^{\infty }{\frac {(-1)^{n}}{(2n+1)!}}x^{2n+1}&&=x-{\frac {x^{3}}{3!}}+{\frac {x^{5}}{5!}}-\cdots &&\forall x
    \\[6pt]\cos x&=\sum _{n=0}^{\infty }{\frac {(-1)^{n}}{(2n)!}}x^{2n}&&=1-{\frac {x^{2}}{2!}}+{\frac {x^{4}}{4!}}-\cdots &&\forall x
    \\[6pt]\tan x&=\sum _{n=1}^{\infty }{\frac {B_{2n}(-4)^{n}\left(1-4^{n}\right)}{(2n)!}}x^{2n-1}&&=x+{\frac {x^{3}}{3}}+{\frac {2x^{5}}{15}}+\cdots &&\forall x:|x|<{\frac {\pi }{2}}
    \\[6pt]\sec x&=\sum _{n=0}^{\infty }{\frac {(-1)^{n}E_{2n}}{(2n)!}}x^{2n}&&=1+{\frac {x^{2}}{2}}+{\frac {5x^{4}}{24}}+\cdots &&\forall x:|x|<{\frac {\pi }{2}}
    \\[6pt]\arcsin x&=\sum _{n=0}^{\infty }{\frac {(2n)!}{4^{n}(n!)^{2}(2n+1)}}x^{2n+1}&&=x+{\frac {x^{3}}{6}}+{\frac {3x^{5}}{40}}+\cdots &&\forall x:|x|\leq 1
    \\[6pt]\arccos x&={\frac {\pi }{2}}-\arcsin x\\&={\frac {\pi }{2}}-\sum _{n=0}^{\infty }{\frac {(2n)!}{4^{n}(n!)^{2}(2n+1)}}x^{2n+1}&&={\frac {\pi }{2}}-x-{\frac {x^{3}}{6}}-{\frac {3x^{5}}{40}}+\cdots &&\forall x:|x|\leq 1
    \\[6pt]\arctan x&=\sum _{n=0}^{\infty }{\frac {(-1)^{n}}{2n+1}}x^{2n+1}&&=x-{\frac {x^{3}}{3}}+{\frac {x^{5}}{5}}-\cdots &&\forall x:|x|\leq 1,\ x\neq \pm i
\end{aligned}
</script>
</div>
<p>在<span><span class="MathJax_Preview">\tan(x)</span><script type="math/tex">\tan(x)</script></span>展开式中的Bk是伯努利数。在<span><span class="MathJax_Preview">\sec(x)</span><script type="math/tex">\sec(x)</script></span>展开式中的<span><span class="MathJax_Preview">E_k</span><script type="math/tex">E_k</script></span>是欧拉数。</p>
<p><strong>双曲函数</strong></p>
<div>
<div class="MathJax_Preview">
\begin{aligned}
    \sinh x&amp;=\sum _{n=0}^{\infty }{\frac {1}{(2n+1)!}}x^{2n+1}\quad \forall x \\
    \cosh x&amp;=\sum _{n=0}^{\infty }{\frac {1}{(2n)!}}x^{2n}\quad \forall x \\
    \tanh x&amp;=\sum _{n=1}^{\infty }{\frac {B_{2n}4^{n}(4^{n}-1)}{(2n)!}}x^{2n-1}\quad \forall x:\left|x\right|&lt;{\frac {\pi }{2}} \\
    \sinh ^{-1}x&amp;=\sum _{n=0}^{\infty }{\frac {(-1)^{n}(2n)!}{4^{n}(n!)^{2}(2n+1)}}x^{2n+1}\quad \forall x:\left|x\right|&lt;1 \\
    \tanh ^{-1}x&amp;=\sum _{n=0}^{\infty }{\frac {1}{2n+1}}x^{2n+1}\quad \forall x:\left|x\right|&lt;1 
\end{aligned}
</div>
<script type="math/tex; mode=display">
\begin{aligned}
    \sinh x&=\sum _{n=0}^{\infty }{\frac {1}{(2n+1)!}}x^{2n+1}\quad \forall x \\
    \cosh x&=\sum _{n=0}^{\infty }{\frac {1}{(2n)!}}x^{2n}\quad \forall x \\
    \tanh x&=\sum _{n=1}^{\infty }{\frac {B_{2n}4^{n}(4^{n}-1)}{(2n)!}}x^{2n-1}\quad \forall x:\left|x\right|<{\frac {\pi }{2}} \\
    \sinh ^{-1}x&=\sum _{n=0}^{\infty }{\frac {(-1)^{n}(2n)!}{4^{n}(n!)^{2}(2n+1)}}x^{2n+1}\quad \forall x:\left|x\right|<1 \\
    \tanh ^{-1}x&=\sum _{n=0}^{\infty }{\frac {1}{2n+1}}x^{2n+1}\quad \forall x:\left|x\right|<1 
\end{aligned}
</script>
</div>
<p><span><span class="MathJax_Preview">\tanh(x)</span><script type="math/tex">\tanh(x)</script></span>展开式中的<span><span class="MathJax_Preview">B_k</span><script type="math/tex">B_k</script></span>是伯努利数。</p>
<p><strong>朗伯W函数</strong></p>
<div>
<div class="MathJax_Preview">
W_{0}(x)=\sum _{n=1}^{\infty }{\frac {(-n)^{n-1}}{n!}}x^{n}\quad \forall x:\left|x\right|&lt;{\frac {1}{e}}
</div>
<script type="math/tex; mode=display">
W_{0}(x)=\sum _{n=1}^{\infty }{\frac {(-n)^{n-1}}{n!}}x^{n}\quad \forall x:\left|x\right|<{\frac {1}{e}}
</script>
</div>
<p><strong>多元函数的展开</strong></p>
<p>泰勒级数可以推广到有多个变量的函数: </p>
<div>
<div class="MathJax_Preview">
\sum _{n_{1}=0}^{\infty }\cdots \sum _{n_{d}=0}^{\infty }{\frac {\partial ^{n_{1}+\cdots +n_{d}}}{\partial x_{1}^{n_{1}}\cdots \partial x_{d}^{n_{d}}}}{\frac {f(a_{1},\cdots ,a_{d})}{n_{1}!\cdots n_{d}!}}(x_{1}-a_{1})^{n_{1}}\cdots (x_{d}-a_{d})^{n_{d}}
</div>
<script type="math/tex; mode=display">
\sum _{n_{1}=0}^{\infty }\cdots \sum _{n_{d}=0}^{\infty }{\frac {\partial ^{n_{1}+\cdots +n_{d}}}{\partial x_{1}^{n_{1}}\cdots \partial x_{d}^{n_{d}}}}{\frac {f(a_{1},\cdots ,a_{d})}{n_{1}!\cdots n_{d}!}}(x_{1}-a_{1})^{n_{1}}\cdots (x_{d}-a_{d})^{n_{d}}
</script>
</div>
<h3 id="32">3.2 平方根倒数速算法</h3>
<ul>
<li><strong>算法的切入点</strong></li>
</ul>
<p><img alt="" src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/f6/Surface_normal.png/440px-Surface_normal.png" /></p>
<p>浮点数的平方根倒数常用于计算正规化向量。3D图形程序需要使用正规化向量来实现光照和投影效果,因此每秒都需做上百万次平方根倒数运算,而在处理坐标转换与光源的专用硬件设备出现前,这些计算都由软件完成,计算速度亦相当之慢;在1990年代这段代码开发出来之时,多数浮点数操作的速度更是远远滞后于整数操作,因而针对正规化向量算法的优化就显得尤为重要。下面陈述计算正规化向量的原理:</p>
<p>要将一个向量标准化,就必须计算其欧几里得范数,以求得向量长度,为此便需对向量的各分量的平方和求平方根;而当求取到其长度,并以之除该向量的每个分量后,所得的新向量就是与原向量同向的单位向量,若以公式表示:</p>
<p><span><span class="MathJax_Preview">\|\boldsymbol{v}\| = \sqrt{v_1^2+v_2^2+v_3^2}</span><script type="math/tex">\|\boldsymbol{v}\| = \sqrt{v_1^2+v_2^2+v_3^2}</script></span>可求得向量<span><span class="MathJax_Preview">v</span><script type="math/tex">v</script></span>的欧几里得范数,此算法正类如对欧几里得空间的两点求取其欧几里得距离,
而<span><span class="MathJax_Preview">\boldsymbol{\hat{v}} = \boldsymbol{v} / \|\boldsymbol{v}\|</span><script type="math/tex">\boldsymbol{\hat{v}} = \boldsymbol{v} / \|\boldsymbol{v}\|</script></span>求得的就是标准化的向量,若以<span><span class="MathJax_Preview">\boldsymbol{x}</span><script type="math/tex">\boldsymbol{x}</script></span>代表<span><span class="MathJax_Preview">v_1^2+v_2^2+v_3^2</span><script type="math/tex">v_1^2+v_2^2+v_3^2</script></span>,则有<span><span class="MathJax_Preview">\boldsymbol{\hat{v}} = \boldsymbol{v} / \sqrt{x}</span><script type="math/tex">\boldsymbol{\hat{v}} = \boldsymbol{v} / \sqrt{x}</script></span>,
可见标准化向量时,对向量分量计算平方根倒数实为必需,所以,对平方根倒数计算算法的优化对计算正规化向量也大有裨益。</p>
<p>为了加速图像处理单元计算,《雷神之锤III竞技场》使用了平方根倒数速算法,而后来采用现场可编程逻辑门阵列的顶点着色器也应用了此算法。</p>
<ul>
<li><strong>代码概览</strong></li>
</ul>
<p>下列代码是《雷神之锤III竞技场》源代码中平方根倒数速算法之实例。示例去除了C预处理器的指令,但附上了原有的注释:</p>
<pre><code class="c++">float Q_rsqrt( float number )
{
    long i;
    float x2, y;
    const float threehalfs = 1.5F;

    x2 = number * 0.5F;
    y  = number;
    i  = * ( long * ) &amp;y;                       // evil floating point bit level hacking(对浮点数的邪恶位元hack)
    i  = 0x5f3759df - ( i &gt;&gt; 1 );               // what the fuck?(这他妈的是怎么回事？)
    y  = * ( float * ) &amp;i;
    y  = y * ( threehalfs - ( x2 * y * y ) );   // 1st iteration (第一次迭代)
//      y  = y * ( threehalfs - ( x2 * y * y ) );   // 2nd iteration, this can be removed(第二次迭代,可以删除)

    return y;
}
</code></pre>

<ul>
<li><strong>将浮点数转化为整数</strong></li>
</ul>
<p><img alt="" src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/db/Float_w_significand.svg/1180px-Float_w_significand.svg.png" /></p>
<p>要理解这段代码,首先需了解浮点数的存储格式。一个浮点数以32个二进制位表示一个有理数,而这32位由其意义分为三段:首先首位为符号位,如若是0则为正数,反之为负数;接下来的8位表示经过偏移处理(这是为了使之能表示-127－128)后的指数;最后23位表示的则是有效数字中除最高位以外的其余数字。将上述结构表示成公式即为<span><span class="MathJax_Preview">\textstyle x=(-1)^{\mathrm {Si} }\cdot (1+m)\cdot 2^{(E-B)}</span><script type="math/tex">\textstyle x=(-1)^{\mathrm {Si} }\cdot (1+m)\cdot 2^{(E-B)}</script></span>,其中<span><span class="MathJax_Preview">\textstyle m</span><script type="math/tex">\textstyle m</script></span>表示有效数字的尾数(此处<span><span class="MathJax_Preview">\textstyle 0\leq m&lt;1</span><script type="math/tex">\textstyle 0\leq m<1</script></span>,偏移量<span><span class="MathJax_Preview">\textstyle B=127</span><script type="math/tex">\textstyle B=127</script></span>,而指数的值<span><span class="MathJax_Preview">\textstyle E-B</span><script type="math/tex">\textstyle E-B</script></span>决定了有效数字(在Lomont和McEniry的论文中称为“尾数”(mantissa))代表的是小数还是整数。以上图为例,将描述带入有<span><span class="MathJax_Preview">\textstyle m=1\times 2^{-2}=0.250</span><script type="math/tex">\textstyle m=1\times 2^{-2}=0.250</script></span>),且<span><span class="MathJax_Preview">\textstyle E-B=124-127=-3</span><script type="math/tex">\textstyle E-B=124-127=-3</script></span>,则可得其表示的浮点数为<span><span class="MathJax_Preview">\textstyle x=(1+0.250)\cdot 2^{-3}=0.15625</span><script type="math/tex">\textstyle x=(1+0.250)\cdot 2^{-3}=0.15625</script></span>。</p>
<p><strong>8位二进制补码示例</strong></p>
<table>
<thead>
<tr>
<th>符号位</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>=127</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>=2</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>=1</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>=0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>=−1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>=−2</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>=−127</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>=−128</td>
</tr>
</tbody>
</table>
<p>如上所述,一个有符号正整数在二进制补码系统中的表示中首位为0,而后面的各位则用于表示其数值。将浮点数取别名存储为整数时,该整数的数值即为<span><span class="MathJax_Preview">\textstyle I=E\times 2^{23}+M</span><script type="math/tex">\textstyle I=E\times 2^{23}+M</script></span>,其中E表示指数,M表示有效数字;若以上图为例,图中样例若作为浮点数看待有<span><span class="MathJax_Preview">\textstyle E=124</span><script type="math/tex">\textstyle E=124</script></span>,<span><span class="MathJax_Preview">M=1\cdot 2^{21}</span><script type="math/tex">M=1\cdot 2^{21}</script></span>,则易知其转化而得的整数型号数值为<span><span class="MathJax_Preview">I=124\times 2^{23} + 2^{21}</span><script type="math/tex">I=124\times 2^{23} + 2^{21}</script></span>。由于平方根倒数函数仅能处理正数,因此浮点数的符号位(即如上的Si)必为0,而这就保证了转换所得的有符号整数也必为正数。以上转换就为后面的计算带来了可行性,之后的第一步操作(逻辑右移一位)即是使该数的长整形式被2所除。</p>
<ul>
<li><strong>"魔术数字"</strong></li>
</ul>
<table>
<thead>
<tr>
<th>S(ign,符号)</th>
<th>E(xponent,指数)</th>
<th>M(antissa,尾数)</th>
</tr>
</thead>
<tbody>
<tr>
<td>1位</td>
<td>b位</td>
<td>(n-1-b)位</td>
</tr>
<tr>
<td>n位</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>对猜测平方根倒数速算法的最初构想来说,计算首次近似值所使用的常数 <strong>0x5f3759df</strong> 也是重要的线索。为确定程序员最初选此常数以近似求取平方根倒数的方法,Charles McEniry首先检验了在代码中选择任意常数R所求取出的首次近似值的精度。回想上一节关于整数和浮点数表示的比较:对于同样的32位二进制数字,若为浮点数表示时实际数值为<span><span class="MathJax_Preview">\textstyle x=(1+m_{x})2^{e_{x}}</span><script type="math/tex">\textstyle x=(1+m_{x})2^{e_{x}}</script></span>,而若为整数表示时实际数值则为<span><span class="MathJax_Preview">\textstyle I_x=E_xL+M_x</span><script type="math/tex">\textstyle I_x=E_xL+M_x</script></span>,其中<span><span class="MathJax_Preview">\textstyle L=2^{n-1-b}</span><script type="math/tex">\textstyle L=2^{n-1-b}</script></span>。以下等式引入了一些由指数和有效数字导出的新元素:</p>
<div>
<div class="MathJax_Preview">
\begin{aligned}
&amp; m_x=\frac{M_x}{L} \\
&amp; e_x=E_x-B,\text{其中}B=2^{b-1}-1
\end{aligned}
</div>
<script type="math/tex; mode=display">
\begin{aligned}
& m_x=\frac{M_x}{L} \\
& e_x=E_x-B,\text{其中}B=2^{b-1}-1
\end{aligned}
</script>
</div>
<p>再继续看McEniry 2007里的进一步说明:</p>
<div>
<div class="MathJax_Preview">
y=\frac{1}{\sqrt{x}}
</div>
<script type="math/tex; mode=display">
y=\frac{1}{\sqrt{x}}
</script>
</div>
<p>对等式的两边取二进制对数(<span><span class="MathJax_Preview">\textstyle \log_2</span><script type="math/tex">\textstyle \log_2</script></span>,即函数<span><span class="MathJax_Preview">\textstyle f(n)=2^n</span><script type="math/tex">\textstyle f(n)=2^n</script></span>的反函数),有</p>
<div>
<div class="MathJax_Preview">
\begin{aligned}
&amp; \log_2{(y)}=-\frac{1}{2}\log_2{(x)} \\
&amp; \log_2(1+m_y)+e_y=-\frac{1}{2}\log_2{(1+m_x)}-\frac{1}{2}e_x
\end{aligned}
</div>
<script type="math/tex; mode=display">
\begin{aligned}
& \log_2{(y)}=-\frac{1}{2}\log_2{(x)} \\
& \log_2(1+m_y)+e_y=-\frac{1}{2}\log_2{(1+m_x)}-\frac{1}{2}e_x
\end{aligned}
</script>
</div>
<p>以如上方法,就能将浮点数x和y的相关指数消去,从而将乘方运算化为加法运算。而由于<span><span class="MathJax_Preview">\textstyle \log _{2}{(x)}</span><script type="math/tex">\textstyle \log _{2}{(x)}</script></span>与<span><span class="MathJax_Preview">\textstyle \log _{2}{(x^{-1/2})}</span><script type="math/tex">\textstyle \log _{2}{(x^{-1/2})}</script></span>线性相关,因此在<span><span class="MathJax_Preview">\textstyle x</span><script type="math/tex">\textstyle x</script></span>与<span><span class="MathJax_Preview">\textstyle y_{0}</span><script type="math/tex">\textstyle y_{0}</script></span>(即输入值与首次近似值)间就可以线性组合的方式创建方程。在此McEniry再度引入新数<span><span class="MathJax_Preview">\sigma</span><script type="math/tex">\sigma</script></span>描述<span><span class="MathJax_Preview">\textstyle \log _{2}{(1+x)}</span><script type="math/tex">\textstyle \log _{2}{(1+x)}</script></span>与近似值<span><span class="MathJax_Preview">R</span><script type="math/tex">R</script></span>间的误差:由于<span><span class="MathJax_Preview">\textstyle 0\leq x&lt;1</span><script type="math/tex">\textstyle 0\leq x<1</script></span>,有<span><span class="MathJax_Preview">\textstyle \log _{2}{(1+x)}\approx {x}</span><script type="math/tex">\textstyle \log _{2}{(1+x)}\approx {x}</script></span>,则在此可定义<span><span class="MathJax_Preview">\sigma</span><script type="math/tex">\sigma</script></span>与<span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span>的关系为<span><span class="MathJax_Preview">\textstyle \log _{2}{(1+x)}\cong x+\sigma</span><script type="math/tex">\textstyle \log _{2}{(1+x)}\cong x+\sigma</script></span>,这一定义就能提供二进制对数的首次精度值(此处<span><span class="MathJax_Preview">0\le\sigma\le\tfrac{1}{3}</span><script type="math/tex">0\le\sigma\le\tfrac{1}{3}</script></span>;当<span><span class="MathJax_Preview">R</span><script type="math/tex">R</script></span>为 <strong>0x5f3759df</strong> 时,有<span><span class="MathJax_Preview">\textstyle \sigma =0.0450461875791687011756</span><script type="math/tex">\textstyle \sigma =0.0450461875791687011756</script></span>)。由此将<span><span class="MathJax_Preview">\textstyle \log _{2}{(1+x)}=x+\sigma</span><script type="math/tex">\textstyle \log _{2}{(1+x)}=x+\sigma</script></span>代入上式,有:</p>
<div>
<div class="MathJax_Preview">
m_y+\sigma+e_y=-\frac{1}{2}m_x-\frac{1}{2}\sigma-\frac{1}{2}e_x
</div>
<script type="math/tex; mode=display">
m_y+\sigma+e_y=-\frac{1}{2}m_x-\frac{1}{2}\sigma-\frac{1}{2}e_x
</script>
</div>
<p>参照首段等式代入<span><span class="MathJax_Preview">M_x</span><script type="math/tex">M_x</script></span>,<span><span class="MathJax_Preview">E_x</span><script type="math/tex">E_x</script></span>,<span><span class="MathJax_Preview">B</span><script type="math/tex">B</script></span>与<span><span class="MathJax_Preview">L</span><script type="math/tex">L</script></span>,有:</p>
<div>
<div class="MathJax_Preview">
M_y+(E_y-B)L=-\frac{3}{2}\sigma{L}-\frac{1}{2}M_x-\frac{1}{2}(E_x-B)L
</div>
<script type="math/tex; mode=display">
M_y+(E_y-B)L=-\frac{3}{2}\sigma{L}-\frac{1}{2}M_x-\frac{1}{2}(E_x-B)L
</script>
</div>
<p>移项整理得:</p>
<div>
<div class="MathJax_Preview">
E_yL+M_y=\frac{3}{2}(B-\sigma)L-\frac{1}{2}(E_xL+M_x)
</div>
<script type="math/tex; mode=display">
E_yL+M_y=\frac{3}{2}(B-\sigma)L-\frac{1}{2}(E_xL+M_x)
</script>
</div>
<p>如上所述,对于以浮点规格存储的正浮点数x,若将其作为长整型表示则示值为<span><span class="MathJax_Preview">\textstyle I_x=E_xL+M_x</span><script type="math/tex">\textstyle I_x=E_xL+M_x</script></span>,由此即可根据x的整数表示导出y(在此<span><span class="MathJax_Preview">\textstyle y=\frac{1}{\sqrt{x}}</span><script type="math/tex">\textstyle y=\frac{1}{\sqrt{x}}</script></span>,亦即<span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span>的平方根倒数的首次近似值)的整数表示值,也即:</p>
<div>
<div class="MathJax_Preview">
I_y=E_yL+M_y=R-\frac{1}{2}(E_xL+M_x)=R-\frac{1}{2}I_x,\text{其中}R=\frac{3}{2}(B-\sigma)L.
</div>
<script type="math/tex; mode=display">
I_y=E_yL+M_y=R-\frac{1}{2}(E_xL+M_x)=R-\frac{1}{2}I_x,\text{其中}R=\frac{3}{2}(B-\sigma)L.
</script>
</div>
<p>最后导出的等式<span><span class="MathJax_Preview">\textstyle I_{y}=R-{\frac {1}{2}}I_{x}</span><script type="math/tex">\textstyle I_{y}=R-{\frac {1}{2}}I_{x}</script></span>即与上节代码中<code>i=0x5f3759df - (i&gt;&gt;1)</code>;一行相契合,由此可见,在平方根倒数速算法中,对浮点数进行一次移位操作与整数减法,就可以可靠地输出一个浮点数的对应近似值。到此为止,McEniry只证明了,在常数R的辅助下,可近似求取浮点数的平方根倒数,但仍未能确定代码中的R值的选取方法。</p>
<p>关于作一次移位与减法操作以使浮点数的指数被<span><span class="MathJax_Preview">-2</span><script type="math/tex">-2</script></span>除的原理,Chris Lomont的论文中亦有个相对简单的解释:以<span><span class="MathJax_Preview">\textstyle 10000=10^{4}</span><script type="math/tex">\textstyle 10000=10^{4}</script></span>为例,将其指数除<span><span class="MathJax_Preview">-2</span><script type="math/tex">-2</script></span>可得<span><span class="MathJax_Preview">\textstyle 10000^{-1/2}=10^{-2}=1/100</span><script type="math/tex">\textstyle 10000^{-1/2}=10^{-2}=1/100</script></span>;而由于浮点表示的指数有进行过偏移处理,所以指数的真实值<span><span class="MathJax_Preview">e</span><script type="math/tex">e</script></span>应为<span><span class="MathJax_Preview">\textstyle e=E-127</span><script type="math/tex">\textstyle e=E-127</script></span>,因此可知除法操作的实际结果为<span><span class="MathJax_Preview">\textstyle -e/2+127</span><script type="math/tex">\textstyle -e/2+127</script></span>,这时用<span><span class="MathJax_Preview">R</span><script type="math/tex">R</script></span>(在此即为“魔术数字”<strong>0x5f3759df</strong>)减之即可使指数的最低有效数字转入有效数字域,之后重新转换为浮点数时,就能得到相当精确的平方根倒数近似值。在这里对常数R的选取亦有所讲究,若能选取一个好的<span><span class="MathJax_Preview">R</span><script type="math/tex">R</script></span>值,便可减少对指数进行除法与对有效数字域进行移位时可能产生的错误。基于这一标准,<code>0xbe</code>即是最合适的R值,而0xbe右移一位即可得到<code>0x5f</code>,这恰是魔术数字R的第一个字节。</p>
<ul>
<li><strong>精确度</strong></li>
</ul>
<p><img alt="" src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/50/Invsqrt0-10000.svg/440px-Invsqrt0-10000.svg.png" /></p>
<p>如上所述,平方根倒数速算法所得的近似值惊人的精确,右图亦展示了以上述代码计算(以平方根倒数速算法计算后再进行一次牛顿法迭代)所得近似值的误差:当输入0.01时,以C语言标准库函数计算可得10.0,而InvSqrt()得值为<code>9.9825822</code>,其间误差为<code>0.017479</code>,相对误差则为<code>0.175%</code>,且当输入更大的数值时,绝对误差不断下降,相对误差也一直控制在一定的范围之内。</p>
<ul>
<li><strong>牛顿法提高精度</strong></li>
</ul>
<p>在进行了如上的整数操作之后,示例程序再度将被转为长整型的浮点数回转为浮点数(对应<code>x = *(float*)&amp;i</code>;),并对其进行一次浮点运算操作(对应<code>x = x*(1.5f - xhalf*x*x)</code>;),这里的浮点运算操作就是对其进行一次牛顿法迭代,若以此例说明:</p>
<p><span><span class="MathJax_Preview">y=\frac{1}{\sqrt{x}}</span><script type="math/tex">y=\frac{1}{\sqrt{x}}</script></span>所求的是<span><span class="MathJax_Preview">y</span><script type="math/tex">y</script></span>的平方根倒数,以之构造以<span><span class="MathJax_Preview">y</span><script type="math/tex">y</script></span>为自变量的函数,有<span><span class="MathJax_Preview">f(y)=\frac{1}{y^2}-x=0</span><script type="math/tex">f(y)=\frac{1}{y^2}-x=0</script></span>,
将其代入牛顿法的通用公式<span><span class="MathJax_Preview">y_{n+1} = y_{n} - \frac{f(y_n)}{f'(y_n)}</span><script type="math/tex">y_{n+1} = y_{n} - \frac{f(y_n)}{f'(y_n)}</script></span>(其中<span><span class="MathJax_Preview">y_n</span><script type="math/tex">y_n</script></span>为首次近似值),
有<span><span class="MathJax_Preview">y_{n+1} = \frac{y_{n}(3-xy_n^2)}{2}</span><script type="math/tex">y_{n+1} = \frac{y_{n}(3-xy_n^2)}{2}</script></span>,其中<span><span class="MathJax_Preview">f(y)=\frac{1}{y^2}-x</span><script type="math/tex">f(y)=\frac{1}{y^2}-x</script></span>,<span><span class="MathJax_Preview">f'(y)=\frac{-2}{y^3}</span><script type="math/tex">f'(y)=\frac{-2}{y^3}</script></span>。</p>
<p>整理有<span><span class="MathJax_Preview">y_{n+1} = \frac{y_{n}(3-xy_n^2)}{2} = y_{n}(1.5-\frac{xy_n^2}{2}</span><script type="math/tex">y_{n+1} = \frac{y_{n}(3-xy_n^2)}{2} = y_{n}(1.5-\frac{xy_n^2}{2}</script></span>),对应的代码即为<code>x = x*(1.5f - xhalf*x*x);</code>。</p>
<p>在以上一节的整数操作产生首次近似值后,程序会将首次近似值作为参数送入函数最后两句进行精化处理,代码中的两次迭代(以一次迭代的输出(对应公式中的<span><span class="MathJax_Preview">y_{n+1}</span><script type="math/tex">y_{n+1}</script></span>)作为二次迭代的输入)正是为了进一步提高结果的精度,但由于雷神之锤III引擎的图形计算中并不需要太高的精度,所以代码中只进行了一次迭代,二次迭代的代码则被注释。</p>
<h2 id="_5">四、基本函数实现代码</h2>
<p>参考: <a href="http://www.netlib.org/fdlibm/">fdlibm实现</a></p>
<ul>
<li><strong><code>fdlibm.h</code>文件</strong></li>
</ul>
<pre><code class="c">#if defined(i386) || defined(i486) || defined(intel) || defined(x86) || defined(i86pc) || defined(__alpha) || defined(__osf__)
    #define __LITTLE_ENDIAN
#endif

#ifdef __LITTLE_ENDIAN
    #define __HI(x) *(1+(int*)&amp;x)
    #define __LO(x) *(int*)&amp;x
    #define __HIp(x) *(1+(int*)x)
    #define __LOp(x) *(int*)x
#else
    #define __HI(x) *(int*)&amp;x
    #define __LO(x) *(1+(int*)&amp;x)
    #define __HIp(x) *(int*)x
    #define __LOp(x) *(1+(int*)x)
#endif

#ifdef __STDC__
    #define __P(p)  p
#else
    #define __P(p)  ()
#endif

// ANSI/POSIX
extern int signgam;
#define MAXFLOAT    ((float)3.40282346638528860e+38)
enum fdversion {fdlibm_ieee = -1, fdlibm_svid, fdlibm_xopen, fdlibm_posix};

#define _LIB_VERSION_TYPE enum fdversion
#define _LIB_VERSION _fdlib_version  

/* if global variable _LIB_VERSION is not desirable, one may 
 * change the following to be a constant by: 
 *  #define _LIB_VERSION_TYPE const enum version
 * In that case, after one initializes the value _LIB_VERSION (see
 * s_lib_version.c) during compile time, it cannot be modified
 * in the middle of a program
 */ 
extern  _LIB_VERSION_TYPE  _LIB_VERSION;

#define _IEEE_  fdlibm_ieee
#define _SVID_  fdlibm_svid
#define _XOPEN_ fdlibm_xopen
#define _POSIX_ fdlibm_posix

struct exception {
    int type;
    char *name;
    double arg1;
    double arg2;
    double retval;
};

#define HUGE        MAXFLOAT

/* 
 * set X_TLOSS = pi*2**52, which is possibly defined in &lt;values.h&gt;
 * (one may replace the following line by &quot;#include &lt;values.h&gt;&quot;)
 */

#define X_TLOSS     1.41484755040568800000e+16 

#define DOMAIN      1
#define SING        2
#define OVERFLOW    3
#define UNDERFLOW   4
#define TLOSS       5
#define PLOSS       6

/*
 * ANSI/POSIX
 */
extern double acos __P((double));
extern double asin __P((double));
extern double atan __P((double));
extern double atan2 __P((double, double));
extern double cos __P((double));
extern double sin __P((double));
extern double tan __P((double));

extern double cosh __P((double));
extern double sinh __P((double));
extern double tanh __P((double));

extern double exp __P((double));
extern double frexp __P((double, int *));
extern double ldexp __P((double, int));
extern double log __P((double));
extern double log10 __P((double));
extern double modf __P((double, double *));

extern double pow __P((double, double));
extern double sqrt __P((double));

extern double ceil __P((double));
extern double fabs __P((double));
extern double floor __P((double));
extern double fmod __P((double, double));

extern double erf __P((double));
extern double erfc __P((double));
extern double gamma __P((double));
extern double hypot __P((double, double));
extern int isnan __P((double));
extern int finite __P((double));
extern double j0 __P((double));
extern double j1 __P((double));
extern double jn __P((int, double));
extern double lgamma __P((double));
extern double y0 __P((double));
extern double y1 __P((double));
extern double yn __P((int, double));

extern double acosh __P((double));
extern double asinh __P((double));
extern double atanh __P((double));
extern double cbrt __P((double));
extern double logb __P((double));
extern double nextafter __P((double, double));
extern double remainder __P((double, double));
#ifdef _SCALB_INT
extern double scalb __P((double, int));
#else
extern double scalb __P((double, double));
#endif

extern int matherr __P((struct exception *));

/*
 * IEEE Test Vector
 */
extern double significand __P((double));

/*
 * Functions callable from C, intended to support IEEE arithmetic.
 */
extern double copysign __P((double, double));
extern int ilogb __P((double));
extern double rint __P((double));
extern double scalbn __P((double, int));

/*
 * BSD math library entry points
 */
extern double expm1 __P((double));
extern double log1p __P((double));

/*
 * Reentrant version of gamma &amp; lgamma; passes signgam back by reference
 * as the second argument; user must allocate space for signgam.
 */
#ifdef _REENTRANT
extern double gamma_r __P((double, int *));
extern double lgamma_r __P((double, int *));
#endif  /* _REENTRANT */

/* ieee style elementary functions */
extern double __ieee754_sqrt __P((double));         
extern double __ieee754_acos __P((double));         
extern double __ieee754_acosh __P((double));            
extern double __ieee754_log __P((double));          
extern double __ieee754_atanh __P((double));            
extern double __ieee754_asin __P((double));         
extern double __ieee754_atan2 __P((double,double));         
extern double __ieee754_exp __P((double));
extern double __ieee754_cosh __P((double));
extern double __ieee754_fmod __P((double,double));
extern double __ieee754_pow __P((double,double));
extern double __ieee754_lgamma_r __P((double,int *));
extern double __ieee754_gamma_r __P((double,int *));
extern double __ieee754_lgamma __P((double));
extern double __ieee754_gamma __P((double));
extern double __ieee754_log10 __P((double));
extern double __ieee754_sinh __P((double));
extern double __ieee754_hypot __P((double,double));
extern double __ieee754_j0 __P((double));
extern double __ieee754_j1 __P((double));
extern double __ieee754_y0 __P((double));
extern double __ieee754_y1 __P((double));
extern double __ieee754_jn __P((int,double));
extern double __ieee754_yn __P((int,double));
extern double __ieee754_remainder __P((double,double));
extern int    __ieee754_rem_pio2 __P((double,double*));
#ifdef _SCALB_INT
extern double __ieee754_scalb __P((double,int));
#else
extern double __ieee754_scalb __P((double,double));
#endif

/* fdlibm kernel function */
extern double __kernel_standard __P((double,double,int));   
extern double __kernel_sin __P((double,double,int));
extern double __kernel_cos __P((double,double));
extern double __kernel_tan __P((double,double,int));
extern int    __kernel_rem_pio2 __P((double*,double*,int,int,int,const int*));
</code></pre>

<ul>
<li><strong><code>e_acos.c</code>文件</strong></li>
</ul>
<pre><code class="c">/* __ieee754_acos(x)
    Method :                  
        acos(x)  = pi/2 - asin(x)
        acos(-x) = pi/2 + asin(x)
        For |x|&lt;=0.5
            acos(x) = pi/2 - (x + x*x^2*R(x^2)) (see asin.c)
        For x&gt;0.5
            acos(x) = pi/2 - (pi/2 - 2asin(sqrt((1-x)/2)))
                    = 2asin(sqrt((1-x)/2))  
                    = 2s + 2s*z*R(z)    ...z=(1-x)/2, s=sqrt(z)
                    = 2f + (2c + 2s*z*R(z))
            where f=hi part of s, and c = (z-f*f)/(s+f) is the correction term
            for f so that f+c ~ sqrt(z).
        For x&lt;-0.5
            acos(x) = pi - 2asin(sqrt((1-|x|)/2))
                    = pi - 0.5*(s+s*z*R(z)), where z=(1-|x|)/2,s=sqrt(z)

    Special cases:
        if x is NaN, return x itself;
        if |x|&gt;1, return NaN with invalid signal.
    Function needed: sqrt
 */

#include &quot;fdlibm.h&quot;

#ifdef __STDC__
    static const double 
#else
    static double 
#endif
one=  1.00000000000000000000e+00, /* 0x3FF00000, 0x00000000 */
pi =  3.14159265358979311600e+00, /* 0x400921FB, 0x54442D18 */
pio2_hi =  1.57079632679489655800e+00, /* 0x3FF921FB, 0x54442D18 */
pio2_lo =  6.12323399573676603587e-17, /* 0x3C91A626, 0x33145C07 */
pS0 =  1.66666666666666657415e-01, /* 0x3FC55555, 0x55555555 */
pS1 = -3.25565818622400915405e-01, /* 0xBFD4D612, 0x03EB6F7D */
pS2 =  2.01212532134862925881e-01, /* 0x3FC9C155, 0x0E884455 */
pS3 = -4.00555345006794114027e-02, /* 0xBFA48228, 0xB5688F3B */
pS4 =  7.91534994289814532176e-04, /* 0x3F49EFE0, 0x7501B288 */
pS5 =  3.47933107596021167570e-05, /* 0x3F023DE1, 0x0DFDF709 */
qS1 = -2.40339491173441421878e+00, /* 0xC0033A27, 0x1C8A2D4B */
qS2 =  2.02094576023350569471e+00, /* 0x40002AE5, 0x9C598AC8 */
qS3 = -6.88283971605453293030e-01, /* 0xBFE6066C, 0x1B8D0159 */
qS4 =  7.70381505559019352791e-02; /* 0x3FB3B8C5, 0xB12E9282 */

#ifdef __STDC__
    double __ieee754_acos(double x)
#else
    double __ieee754_acos(x)
    double x;
#endif
{
    double z,p,q,r,w,s,c,df;
    int hx,ix;
    hx = __HI(x);
    ix = hx&amp;0x7fffffff;
    if(ix&gt;=0x3ff00000) {    /* |x| &gt;= 1 */
        if(((ix-0x3ff00000)|__LO(x))==0) {  /* |x|==1 */
        if(hx&gt;0) return 0.0;        /* acos(1) = 0  */
        else return pi+2.0*pio2_lo; /* acos(-1)= pi */
        }
        return (x-x)/(x-x);     /* acos(|x|&gt;1) is NaN */
    }
    if(ix&lt;0x3fe00000) { /* |x| &lt; 0.5 */
        if(ix&lt;=0x3c600000) return pio2_hi+pio2_lo;/*if|x|&lt;2**-57*/
        z = x*x;
        p = z*(pS0+z*(pS1+z*(pS2+z*(pS3+z*(pS4+z*pS5)))));
        q = one+z*(qS1+z*(qS2+z*(qS3+z*qS4)));
        r = p/q;
        return pio2_hi - (x - (pio2_lo-x*r));
    } else  if (hx&lt;0) {     /* x &lt; -0.5 */
        z = (one+x)*0.5;
        p = z*(pS0+z*(pS1+z*(pS2+z*(pS3+z*(pS4+z*pS5)))));
        q = one+z*(qS1+z*(qS2+z*(qS3+z*qS4)));
        s = sqrt(z);
        r = p/q;
        w = r*s-pio2_lo;
        return pi - 2.0*(s+w);
    } else {            /* x &gt; 0.5 */
        z = (one-x)*0.5;
        s = sqrt(z);
        df = s;
        __LO(df) = 0;
        c  = (z-df*df)/(s+df);
        p = z*(pS0+z*(pS1+z*(pS2+z*(pS3+z*(pS4+z*pS5)))));
        q = one+z*(qS1+z*(qS2+z*(qS3+z*qS4)));
        r = p/q;
        w = r*s+c;
        return 2.0*(df+w);
    }
}
</code></pre>

<ul>
<li><strong><code>e_acosh.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/* __ieee754_acosh(x)
    Method :
        Based on 
            acosh(x) = log [ x + sqrt(x*x-1) ]
        we have
            acosh(x) := log(x)+ln2, if x is large; else
            acosh(x) := log(2x-1/(sqrt(x*x-1)+x)) if x&gt;2; else
            acosh(x) := log1p(t+sqrt(2.0*t+t*t)); where t=x-1.
    Special cases:
        acosh(x) is NaN with signal if x&lt;1.
        acosh(NaN) is NaN without signal.
 */

#include &quot;fdlibm.h&quot;

#ifdef __STDC__
    static const double 
#else
    static double 
#endif
one = 1.0,
ln2 = 6.93147180559945286227e-01;  /* 0x3FE62E42, 0xFEFA39EF */

#ifdef __STDC__
    double __ieee754_acosh(double x)
#else
    double __ieee754_acosh(x)
    double x;
#endif
{   
    double t;
    int hx;
    hx = __HI(x);
    if(hx&lt;0x3ff00000) {     /* x &lt; 1 */
        return (x-x)/(x-x);
    } else if(hx &gt;=0x41b00000) {    /* x &gt; 2**28 */
        if(hx &gt;=0x7ff00000) {   /* x is inf of NaN */
            return x+x;
        } else 
        return __ieee754_log(x)+ln2;    /* acosh(huge)=log(2x) */
    } else if(((hx-0x3ff00000)|__LO(x))==0) {
        return 0.0;         /* acosh(1) = 0 */
    } else if (hx &gt; 0x40000000) {   /* 2**28 &gt; x &gt; 2 */
        t=x*x;
        return __ieee754_log(2.0*x-one/(x+sqrt(t-one)));
    } else {            /* 1&lt;x&lt;2 */
        t = x-one;
        return log1p(t+sqrt(2.0*t+t*t));
    }
}
</code></pre>

<ul>
<li><strong><code>e_asin.c</code>文件</strong></li>
</ul>
<pre><code class="c">/* __ieee754_asin(x)
    Method :                  
        Since  asin(x) = x + x^3/6 + x^5*3/40 + x^7*15/336 + ...
        we approximate asin(x) on [0,0.5] by
            asin(x) = x + x*x^2*R(x^2)
        where
            R(x^2) is a rational approximation of (asin(x)-x)/x^3 
        and its remez error is bounded by
            |(asin(x)-x)/x^3 - R(x^2)| &lt; 2^(-58.75)

        For x in [0.5,1]
            asin(x) = pi/2-2*asin(sqrt((1-x)/2))
        Let y = (1-x), z = y/2, s := sqrt(z), and pio2_hi+pio2_lo=pi/2;
        then for x&gt;0.98
            asin(x) = pi/2 - 2*(s+s*z*R(z)) = pio2_hi - (2*(s+s*z*R(z)) - pio2_lo)
        For x&lt;=0.98, let pio4_hi = pio2_hi/2, then f = hi part of s;
            c = sqrt(z) - f = (z-f*f)/(s+f)     ...f+c=sqrt(z)
        and
            asin(x) = pi/2 - 2*(s+s*z*R(z))
                    = pio4_hi+(pio4-2s)-(2s*z*R(z)-pio2_lo)
                    = pio4_hi+(pio4-2f)-(2s*z*R(z)-(pio2_lo+2c))
    Special cases:
        if x is NaN, return x itself;
        if |x|&gt;1, return NaN with invalid signal.
 */


#include &quot;fdlibm.h&quot;

#ifdef __STDC__
    static const double 
#else
    static double 
#endif
one =  1.00000000000000000000e+00, /* 0x3FF00000, 0x00000000 */
huge =  1.000e+300,
pio2_hi =  1.57079632679489655800e+00, /* 0x3FF921FB, 0x54442D18 */
pio2_lo =  6.12323399573676603587e-17, /* 0x3C91A626, 0x33145C07 */
pio4_hi =  7.85398163397448278999e-01, /* 0x3FE921FB, 0x54442D18 */
    /* coefficient for R(x^2) */
pS0 =  1.66666666666666657415e-01, /* 0x3FC55555, 0x55555555 */
pS1 = -3.25565818622400915405e-01, /* 0xBFD4D612, 0x03EB6F7D */
pS2 =  2.01212532134862925881e-01, /* 0x3FC9C155, 0x0E884455 */
pS3 = -4.00555345006794114027e-02, /* 0xBFA48228, 0xB5688F3B */
pS4 =  7.91534994289814532176e-04, /* 0x3F49EFE0, 0x7501B288 */
pS5 =  3.47933107596021167570e-05, /* 0x3F023DE1, 0x0DFDF709 */
qS1 = -2.40339491173441421878e+00, /* 0xC0033A27, 0x1C8A2D4B */
qS2 =  2.02094576023350569471e+00, /* 0x40002AE5, 0x9C598AC8 */
qS3 = -6.88283971605453293030e-01, /* 0xBFE6066C, 0x1B8D0159 */
qS4 =  7.70381505559019352791e-02; /* 0x3FB3B8C5, 0xB12E9282 */

#ifdef __STDC__
    double __ieee754_asin(double x)
#else
    double __ieee754_asin(x)
    double x;
#endif
{
    double t,w,p,q,c,r,s;
    int hx,ix;
    hx = __HI(x);
    ix = hx&amp;0x7fffffff;
    if(ix&gt;= 0x3ff00000) {       /* |x|&gt;= 1 */
        if(((ix-0x3ff00000)|__LO(x))==0)
            /* asin(1)=+-pi/2 with inexact */
        return x*pio2_hi+x*pio2_lo; 
        return (x-x)/(x-x);     /* asin(|x|&gt;1) is NaN */   
    } else if (ix&lt;0x3fe00000) { /* |x|&lt;0.5 */
        if(ix&lt;0x3e400000) {     /* if |x| &lt; 2**-27 */
        if(huge+x&gt;one) return x;/* return x with inexact if x!=0*/
        } else 
        t = x*x;
        p = t*(pS0+t*(pS1+t*(pS2+t*(pS3+t*(pS4+t*pS5)))));
        q = one+t*(qS1+t*(qS2+t*(qS3+t*qS4)));
        w = p/q;
        return x+x*w;
    }
    /* 1&gt; |x|&gt;= 0.5 */
    w = one-fabs(x);
    t = w*0.5;
    p = t*(pS0+t*(pS1+t*(pS2+t*(pS3+t*(pS4+t*pS5)))));
    q = one+t*(qS1+t*(qS2+t*(qS3+t*qS4)));
    s = sqrt(t);
    if(ix&gt;=0x3FEF3333) {    /* if |x| &gt; 0.975 */
        w = p/q;
        t = pio2_hi-(2.0*(s+s*w)-pio2_lo);
    } else {
        w  = s;
        __LO(w) = 0;
        c  = (t-w*w)/(s+w);
        r  = p/q;
        p  = 2.0*s*r-(pio2_lo-2.0*c);
        q  = pio4_hi-2.0*w;
        t  = pio4_hi-(p-q);
    }    
    if(hx&gt;0) return t; else return -t;    
}
</code></pre>

<ul>
<li><strong><code>e_atan2.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/* __ieee754_atan2(y,x)
    Method :
        1. Reduce y to positive by atan2(y,x)=-atan2(-y,x).
        2. Reduce x to positive by (if x and y are unexceptional): 
            ARG (x+iy) = arctan(y/x)       ... if x &gt; 0,
            ARG (x+iy) = pi - arctan[y/(-x)]   ... if x &lt; 0,

    Special cases:
        ATAN2((anything), NaN ) is NaN;
        ATAN2(NAN , (anything) ) is NaN;
        ATAN2(+-0, +(anything but NaN)) is +-0  ;
        ATAN2(+-0, -(anything but NaN)) is +-pi ;
        ATAN2(+-(anything but 0 and NaN), 0) is +-pi/2;
        ATAN2(+-(anything but INF and NaN), +INF) is +-0 ;
        ATAN2(+-(anything but INF and NaN), -INF) is +-pi;
        ATAN2(+-INF,+INF ) is +-pi/4 ;
        ATAN2(+-INF,-INF ) is +-3pi/4;
        ATAN2(+-INF, (anything but,0,NaN, and INF)) is +-pi/2;

    Constants:
        The hexadecimal values are the intended ones for the following 
        constants. The decimal values may be used, provided that the 
        compiler will convert from decimal to binary accurately enough 
        to produce the hexadecimal values shown.
 */

#include &quot;fdlibm.h&quot;

#ifdef __STDC__
    static const double 
#else
    static double 
#endif
tiny  = 1.0e-300,
zero  = 0.0,
pi_o_4  = 7.8539816339744827900E-01, /* 0x3FE921FB, 0x54442D18 */
pi_o_2  = 1.5707963267948965580E+00, /* 0x3FF921FB, 0x54442D18 */
pi      = 3.1415926535897931160E+00, /* 0x400921FB, 0x54442D18 */
pi_lo   = 1.2246467991473531772E-16; /* 0x3CA1A626, 0x33145C07 */

#ifdef __STDC__
    double __ieee754_atan2(double y, double x)
#else
    double __ieee754_atan2(y,x)
    double  y,x;
#endif
{  
    double z;
    int k,m,hx,hy,ix,iy;
    unsigned lx,ly;

    hx = __HI(x); ix = hx&amp;0x7fffffff;
    lx = __LO(x);
    hy = __HI(y); iy = hy&amp;0x7fffffff;
    ly = __LO(y);
    if(((ix|((lx|-lx)&gt;&gt;31))&gt;0x7ff00000)||
       ((iy|((ly|-ly)&gt;&gt;31))&gt;0x7ff00000))    /* x or y is NaN */
       return x+y;
    if((hx-0x3ff00000|lx)==0) return atan(y);   /* x=1.0 */
    m = ((hy&gt;&gt;31)&amp;1)|((hx&gt;&gt;30)&amp;2);  /* 2*sign(x)+sign(y) */

    /* when y = 0 */
    if((iy|ly)==0) {
        switch(m) {
        case 0: 
        case 1: return y;   /* atan(+-0,+anything)=+-0 */
        case 2: return  pi+tiny;/* atan(+0,-anything) = pi */
        case 3: return -pi-tiny;/* atan(-0,-anything) =-pi */
        }
    }
    /* when x = 0 */
    if((ix|lx)==0) return (hy&lt;0)?  -pi_o_2-tiny: pi_o_2+tiny;

    /* when x is INF */
    if(ix==0x7ff00000) {
        if(iy==0x7ff00000) {
        switch(m) {
            case 0: return  pi_o_4+tiny;/* atan(+INF,+INF) */
            case 1: return -pi_o_4-tiny;/* atan(-INF,+INF) */
            case 2: return  3.0*pi_o_4+tiny;/*atan(+INF,-INF)*/
            case 3: return -3.0*pi_o_4-tiny;/*atan(-INF,-INF)*/
        }
        } else {
        switch(m) {
            case 0: return  zero  ; /* atan(+...,+INF) */
            case 1: return -zero  ; /* atan(-...,+INF) */
            case 2: return  pi+tiny  ;  /* atan(+...,-INF) */
            case 3: return -pi-tiny  ;  /* atan(-...,-INF) */
        }
        }
    }
    /* when y is INF */
    if(iy==0x7ff00000) return (hy&lt;0)? -pi_o_2-tiny: pi_o_2+tiny;

    /* compute y/x */
    k = (iy-ix)&gt;&gt;20;
    if(k &gt; 60) z=pi_o_2+0.5*pi_lo;  /* |y/x| &gt;  2**60 */
    else if(hx&lt;0&amp;&amp;k&lt;-60) z=0.0;     /* |y|/x &lt; -2**60 */
    else z=atan(fabs(y/x));     /* safe to do y/x */
    switch (m) {
        case 0: return       z  ;   /* atan(+,+) */
        case 1: __HI(z) ^= 0x80000000;
            return       z  ;   /* atan(-,+) */
        case 2: return  pi-(z-pi_lo);/* atan(+,-) */
        default: /* case 3 */
                return  (z-pi_lo)-pi;/* atan(-,-) */
    }
}
</code></pre>

<ul>
<li><strong><code>e_atanh.c</code>文件</strong></li>
</ul>
<pre><code class="c">/* __ieee754_atanh(x)
    Method :
        1. Reduced x to positive by atanh(-x) = -atanh(x)
        2. For x&gt;=0.5
                              1              2x                          x
              atanh(x) = --- * log(1 + -------) = 0.5 * log1p(2 * --------)
                              2             1 - x                      1 - x
           For x&lt;0.5
                atanh(x) = 0.5*log1p(2x+2x*x/(1-x))
    Special cases:
        atanh(x) is NaN if |x| &gt; 1 with signal;
        atanh(NaN) is that NaN with no signal;
        atanh(+-1) is +-INF with signal.
 */

#include &quot;fdlibm.h&quot;

#ifdef __STDC__
    static const double one = 1.0, huge = 1e300;
#else
    static double one = 1.0, huge = 1e300;
#endif

static double zero = 0.0;

#ifdef __STDC__
    double __ieee754_atanh(double x)
#else
    double __ieee754_atanh(x)
    double x;
#endif
{
    double t;
    int hx,ix;
    unsigned lx;
    hx = __HI(x);       /* high word */
    lx = __LO(x);       /* low word */
    ix = hx&amp;0x7fffffff;
    if ((ix|((lx|(-lx))&gt;&gt;31))&gt;0x3ff00000) /* |x|&gt;1 */
        return (x-x)/(x-x);
    if(ix==0x3ff00000) 
        return x/zero;
    if(ix&lt;0x3e300000&amp;&amp;(huge+x)&gt;zero) return x;  /* x&lt;2**-28 */
    __HI(x) = ix;       /* x &lt;- |x| */
    if(ix&lt;0x3fe00000) {     /* x &lt; 0.5 */
        t = x+x;
        t = 0.5*log1p(t+t*x/(one-x));
    } else 
        t = 0.5*log1p((x+x)/(one-x));
    if(hx&gt;=0) return t; else return -t;
}
</code></pre>

<ul>
<li><strong><code>e_cosh.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/* __ieee754_cosh(x)
    Method : mathematically cosh(x) if defined to be (exp(x)+exp(-x))/2
        1. Replace x by |x| (cosh(x) = cosh(-x)). 
        2. 
                                                  [ exp(x) - 1 ]^2 
          0        &lt;= x &lt;= ln2/2  :  cosh(x) := 1 + -------------------
                                         2*exp(x)

                                            exp(x) +  1/exp(x)
          ln2/2    &lt;= x &lt;= 22     :  cosh(x) := -------------------
                                        2
          22       &lt;= x &lt;= lnovft :  cosh(x) := exp(x)/2 
          lnovft   &lt;= x &lt;= ln2ovft:  cosh(x) := exp(x/2)/2 * exp(x/2)
          ln2ovft  &lt;  x       :  cosh(x) := huge*huge (overflow)

    Special cases:
        cosh(x) is |x| if x is +INF, -INF, or NaN.
        only cosh(0)=1 is exact for finite x.
 */

#include &quot;fdlibm.h&quot;

#ifdef __STDC__
    static const double one = 1.0, half=0.5, huge = 1.0e300;
#else
    static double one = 1.0, half=0.5, huge = 1.0e300;
#endif

#ifdef __STDC__
    double __ieee754_cosh(double x)
#else
    double __ieee754_cosh(x)
    double x;
#endif
{   
    double t,w;
    int ix;
    unsigned lx;

    /* High word of |x|. */
    ix = __HI(x);
    ix &amp;= 0x7fffffff;

    /* x is INF or NaN */
    if(ix&gt;=0x7ff00000) return x*x;  

    /* |x| in [0,0.5*ln2], return 1+expm1(|x|)^2/(2*exp(|x|)) */
    if(ix&lt;0x3fd62e43) {
        t = expm1(fabs(x));
        w = one+t;
        if (ix&lt;0x3c800000) return w;    /* cosh(tiny) = 1 */
        return one+(t*t)/(w+w);
    }

    /* |x| in [0.5*ln2,22], return (exp(|x|)+1/exp(|x|)/2; */
    if (ix &lt; 0x40360000) {
        t = __ieee754_exp(fabs(x));
        return half*t+half/t;
    }

    /* |x| in [22, log(maxdouble)] return half*exp(|x|) */
    if (ix &lt; 0x40862E42)  return half*__ieee754_exp(fabs(x));

    /* |x| in [log(maxdouble), overflowthresold] */
    lx = *( (((*(unsigned*)&amp;one)&gt;&gt;29)) + (unsigned*)&amp;x);
    if (ix&lt;0x408633CE || 
          (ix==0x408633ce)&amp;&amp;(lx&lt;=(unsigned)0x8fb9f87d)) {
        w = __ieee754_exp(half*fabs(x));
        t = half*w;
        return t*w;
    }

    /* |x| &gt; overflowthresold, cosh(x) overflow */
    return huge*huge;
}
</code></pre>

<ul>
<li><strong><code>e_exp.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/* __ieee754_exp(x) Returns the exponential of x.
    Method
        1. Argument reduction:
            Reduce x to an r so that |r| &lt;= 0.5*ln2 ~ 0.34658.
            Given x, find r and integer k such that
                x = k*ln2 + r,  |r| &lt;= 0.5*ln2.  
            Here r will be represented as r = hi-lo for better accuracy.
        2. Approximation of exp(r) by a special rational function on the interval [0,0.34658]:
           Write
                R(r**2) = r*(exp(r)+1)/(exp(r)-1) = 2 + r*r/6 - r**4/360 + ...
           We use a special Remes algorithm on [0,0.34658] to generate 
           a polynomial of degree 5 to approximate R. The maximum error 
           of this polynomial approximation is bounded by 2**-59. In
           other words,
                R(z) ~ 2.0 + P1*z + P2*z**2 + P3*z**3 + P4*z**4 + P5*z**5
           (where z=r*r, and the values of P1 to P5 are listed below)
           and
              |                  5          |     -59
              | 2.0+P1*z+...+P5*z   -  R(z) | &lt;= 2 
              |                             |
            The computation of exp(r) thus becomes
                                     2*r
              exp(r) = 1 + -------
                            R - r
                                         r*R1(r)  
                     = 1 + r + ----------- (for better accuracy)
                                2 - R1(r)
            where
                           2       4             10
              R1(r) = r - (P1*r  + P2*r  + ... + P5*r   ).  
        3. Scale back to obtain exp(x):
            From step 1, we have
                exp(x) = 2^k * exp(r)

    Special cases:
        exp(INF) is INF, exp(NaN) is NaN;
        exp(-INF) is 0, and
        for finite argument, only exp(0)=1 is exact.

    Accuracy:
        according to an error analysis, the error is always less than
        1 ulp (unit in the last place).
*/

#include &quot;fdlibm.h&quot;

#ifdef __STDC__
    static const double
#else
    static double
#endif
one = 1.0,
halF[2] = {0.5,-0.5,},
huge    = 1.0e+300,
twom1000= 9.33263618503218878990e-302,     /* 2**-1000=0x01700000,0*/
o_threshold=  7.09782712893383973096e+02,  /* 0x40862E42, 0xFEFA39EF */
u_threshold= -7.45133219101941108420e+02,  /* 0xc0874910, 0xD52D3051 */
ln2HI[2]   ={ 6.93147180369123816490e-01,  /* 0x3fe62e42, 0xfee00000 */
         -6.93147180369123816490e-01,},/* 0xbfe62e42, 0xfee00000 */
ln2LO[2]   ={ 1.90821492927058770002e-10,  /* 0x3dea39ef, 0x35793c76 */
         -1.90821492927058770002e-10,},/* 0xbdea39ef, 0x35793c76 */
invln2 =  1.44269504088896338700e+00, /* 0x3ff71547, 0x652b82fe */
P1   =  1.66666666666666019037e-01, /* 0x3FC55555, 0x5555553E */
P2   = -2.77777777770155933842e-03, /* 0xBF66C16C, 0x16BEBD93 */
P3   =  6.61375632143793436117e-05, /* 0x3F11566A, 0xAF25DE2C */
P4   = -1.65339022054652515390e-06, /* 0xBEBBBD41, 0xC5D26BF1 */
P5   =  4.13813679705723846039e-08; /* 0x3E663769, 0x72BEA4D0 */


#ifdef __STDC__
    double __ieee754_exp(double x)  /* default IEEE double exp */
#else
    double __ieee754_exp(x) /* default IEEE double exp */
    double x;
#endif
{
    double y,hi,lo,c,t;
    int k,xsb;
    unsigned hx;

    hx  = __HI(x);  /* high word of x */
    xsb = (hx&gt;&gt;31)&amp;1;       /* sign bit of x */
    hx &amp;= 0x7fffffff;       /* high word of |x| */

    /* filter out non-finite argument */
    if(hx &gt;= 0x40862E42) {          /* if |x|&gt;=709.78... */
            if(hx&gt;=0x7ff00000) {
        if(((hx&amp;0xfffff)|__LO(x))!=0) 
             return x+x;        /* NaN */
        else return (xsb==0)? x:0.0;    /* exp(+-inf)={inf,0} */
        }
        if(x &gt; o_threshold) return huge*huge; /* overflow */
        if(x &lt; u_threshold) return twom1000*twom1000; /* underflow */
    }

    /* argument reduction */
    if(hx &gt; 0x3fd62e42) {       /* if  |x| &gt; 0.5 ln2 */ 
        if(hx &lt; 0x3FF0A2B2) {   /* and |x| &lt; 1.5 ln2 */
        hi = x-ln2HI[xsb]; lo=ln2LO[xsb]; k = 1-xsb-xsb;
        } else {
        k  = (int)(invln2*x+halF[xsb]);
        t  = k;
        hi = x - t*ln2HI[0];    /* t*ln2HI is exact here */
        lo = t*ln2LO[0];
        }
        x  = hi - lo;
    } 
    else if(hx &lt; 0x3e300000)  { /* when |x|&lt;2**-28 */
        if(huge+x&gt;one) return one+x;/* trigger inexact */
    }
    else k = 0;

    /* x is now in primary range */
    t  = x*x;
    c  = x - t*(P1+t*(P2+t*(P3+t*(P4+t*P5))));
    if(k==0)    return one-((x*c)/(c-2.0)-x); 
    else        y = one-((lo-(x*c)/(2.0-c))-hi);
    if(k &gt;= -1021) {
        __HI(y) += (k&lt;&lt;20); /* add k to y's exponent */
        return y;
    } else {
        __HI(y) += ((k+1000)&lt;&lt;20);/* add k to y's exponent */
        return y*twom1000;
    }
}
</code></pre>

<ul>
<li><strong><code>e_fmod.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/* __ieee754_fmod(x,y)
    Return x mod y in exact arithmetic
    Method: shift and subtract
*/

#include &quot;fdlibm.h&quot;

#ifdef __STDC__
    static const double one = 1.0, Zero[] = {0.0, -0.0,};
#else
    static double one = 1.0, Zero[] = {0.0, -0.0,};
#endif

#ifdef __STDC__
    double __ieee754_fmod(double x, double y)
#else
    double __ieee754_fmod(x,y)
    double x,y ;
#endif
{
    int n,hx,hy,hz,ix,iy,sx,i;
    unsigned lx,ly,lz;

    hx = __HI(x);       /* high word of x */
    lx = __LO(x);       /* low  word of x */
    hy = __HI(y);       /* high word of y */
    ly = __LO(y);       /* low  word of y */
    sx = hx&amp;0x80000000;     /* sign of x */
    hx ^=sx;        /* |x| */
    hy &amp;= 0x7fffffff;   /* |y| */

    /* purge off exception values */
    if((hy|ly)==0||(hx&gt;=0x7ff00000)||   /* y=0,or x not finite */
      ((hy|((ly|-ly)&gt;&gt;31))&gt;0x7ff00000)) /* or y is NaN */
        return (x*y)/(x*y);
    if(hx&lt;=hy) {
        if((hx&lt;hy)||(lx&lt;ly)) return x;  /* |x|&lt;|y| return x */
        if(lx==ly) 
        return Zero[(unsigned)sx&gt;&gt;31];  /* |x|=|y| return x*0*/
    }

    /* determine ix = ilogb(x) */
    if(hx&lt;0x00100000) { /* subnormal x */
        if(hx==0) {
        for (ix = -1043, i=lx; i&gt;0; i&lt;&lt;=1) ix -=1;
        } else {
        for (ix = -1022,i=(hx&lt;&lt;11); i&gt;0; i&lt;&lt;=1) ix -=1;
        }
    } else ix = (hx&gt;&gt;20)-1023;

    /* determine iy = ilogb(y) */
    if(hy&lt;0x00100000) { /* subnormal y */
        if(hy==0) {
        for (iy = -1043, i=ly; i&gt;0; i&lt;&lt;=1) iy -=1;
        } else {
        for (iy = -1022,i=(hy&lt;&lt;11); i&gt;0; i&lt;&lt;=1) iy -=1;
        }
    } else iy = (hy&gt;&gt;20)-1023;

    /* set up {hx,lx}, {hy,ly} and align y to x */
    if(ix &gt;= -1022) 
        hx = 0x00100000|(0x000fffff&amp;hx);
    else {      /* subnormal x, shift x to normal */
        n = -1022-ix;
        if(n&lt;=31) {
            hx = (hx&lt;&lt;n)|(lx&gt;&gt;(32-n));
            lx &lt;&lt;= n;
        } else {
        hx = lx&lt;&lt;(n-32);
        lx = 0;
        }
    }
    if(iy &gt;= -1022) 
        hy = 0x00100000|(0x000fffff&amp;hy);
    else {      /* subnormal y, shift y to normal */
        n = -1022-iy;
        if(n&lt;=31) {
            hy = (hy&lt;&lt;n)|(ly&gt;&gt;(32-n));
            ly &lt;&lt;= n;
        } else {
        hy = ly&lt;&lt;(n-32);
        ly = 0;
        }
    }

    /* fix point fmod */
    n = ix - iy;
    while(n--) {
        hz=hx-hy;lz=lx-ly; if(lx&lt;ly) hz -= 1;
        if(hz&lt;0){hx = hx+hx+(lx&gt;&gt;31); lx = lx+lx;}
        else {
            if((hz|lz)==0)      /* return sign(x)*0 */
            return Zero[(unsigned)sx&gt;&gt;31];
            hx = hz+hz+(lz&gt;&gt;31); lx = lz+lz;
        }
    }
    hz=hx-hy;lz=lx-ly; if(lx&lt;ly) hz -= 1;
    if(hz&gt;=0) {hx=hz;lx=lz;}

    /* convert back to floating value and restore the sign */
    if((hx|lx)==0)          /* return sign(x)*0 */
        return Zero[(unsigned)sx&gt;&gt;31];  
    while(hx&lt;0x00100000) {      /* normalize x */
        hx = hx+hx+(lx&gt;&gt;31); lx = lx+lx;
        iy -= 1;
    }
    if(iy&gt;= -1022) {    /* normalize output */
        hx = ((hx-0x00100000)|((iy+1023)&lt;&lt;20));
        __HI(x) = hx|sx;
        __LO(x) = lx;
    } else {        /* subnormal output */
        n = -1022 - iy;
        if(n&lt;=20) {
        lx = (lx&gt;&gt;n)|((unsigned)hx&lt;&lt;(32-n));
        hx &gt;&gt;= n;
        } else if (n&lt;=31) {
        lx = (hx&lt;&lt;(32-n))|(lx&gt;&gt;n); hx = sx;
        } else {
        lx = hx&gt;&gt;(n-32); hx = sx;
        }
        __HI(x) = hx|sx;
        __LO(x) = lx;
        x *= one;       /* create necessary signal */
    }
    return x;       /* exact output */
}
</code></pre>

<ul>
<li><strong><code>e_gamma.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/* __ieee754_gamma(x)
    Return the logarithm of the Gamma function of x.
    Method: call __ieee754_gamma_r
*/

#include &quot;fdlibm.h&quot;

extern int signgam;

#ifdef __STDC__
    double __ieee754_gamma(double x)
#else
    double __ieee754_gamma(x)
    double x;
#endif
{
    return __ieee754_gamma_r(x,&amp;signgam);
}
</code></pre>

<ul>
<li><strong><code>e_gamma_r.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/* __ieee754_gamma_r(x, signgamp)
    Reentrant version of the logarithm of the Gamma function 
    with user provide pointer for the sign of Gamma(x). 

    Method: See __ieee754_lgamma_r
*/

#include &quot;fdlibm.h&quot;

#ifdef __STDC__
    double __ieee754_gamma_r(double x, int *signgamp)
#else
    double __ieee754_gamma_r(x,signgamp)
    double x; int *signgamp;
#endif
{
    return __ieee754_lgamma_r(x,signgamp);
}
</code></pre>

<ul>
<li><strong><code>e_hypot.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/* __ieee754_hypot(x,y)
Method :                  
 *  If (assume round-to-nearest) z=x*x+y*y 
 *  has error less than sqrt(2)/2 ulp, than 
 *  sqrt(z) has error less than 1 ulp (exercise).
 *
 *  So, compute sqrt(x*x+y*y) with some care as 
 *  follows to get the error below 1 ulp:
 *
 *  Assume x&gt;y&gt;0;
 *  (if possible, set rounding to round-to-nearest)
 *  1. if x &gt; 2y  use
 *      x1*x1+(y*y+(x2*(x+x1))) for x*x+y*y
 *  where x1 = x with lower 32 bits cleared, x2 = x-x1; else
 *  2. if x &lt;= 2y use
 *      t1*y1+((x-y)*(x-y)+(t1*y2+t2*y))
 *  where t1 = 2x with lower 32 bits cleared, t2 = 2x-t1, 
 *  y1= y with lower 32 bits chopped, y2 = y-y1.
 *      
 *  NOTE: scaling may be necessary if some argument is too 
 *        large or too tiny
 *
 * Special cases:
 *  hypot(x,y) is INF if x or y is +INF or -INF; else
 *  hypot(x,y) is NAN if x or y is NAN.
 *
 * Accuracy:
 *  hypot(x,y) returns sqrt(x^2+y^2) with error less 
 *  than 1 ulps (units in the last place) 
 */

#include &quot;fdlibm.h&quot;

#ifdef __STDC__
    double __ieee754_hypot(double x, double y)
#else
    double __ieee754_hypot(x,y)
    double x, y;
#endif
{
    double a=x,b=y,t1,t2,y1,y2,w;
    int j,k,ha,hb;

    ha = __HI(x)&amp;0x7fffffff;    /* high word of  x */
    hb = __HI(y)&amp;0x7fffffff;    /* high word of  y */
    if(hb &gt; ha) {a=y;b=x;j=ha; ha=hb;hb=j;} else {a=x;b=y;}
    __HI(a) = ha;   /* a &lt;- |a| */
    __HI(b) = hb;   /* b &lt;- |b| */
    if((ha-hb)&gt;0x3c00000) {return a+b;} /* x/y &gt; 2**60 */
    k=0;
    if(ha &gt; 0x5f300000) {   /* a&gt;2**500 */
       if(ha &gt;= 0x7ff00000) {   /* Inf or NaN */
           w = a+b;         /* for sNaN */
           if(((ha&amp;0xfffff)|__LO(a))==0) w = a;
           if(((hb^0x7ff00000)|__LO(b))==0) w = b;
           return w;
       }
       /* scale a and b by 2**-600 */
       ha -= 0x25800000; hb -= 0x25800000;  k += 600;
       __HI(a) = ha;
       __HI(b) = hb;
    }
    if(hb &lt; 0x20b00000) {   /* b &lt; 2**-500 */
        if(hb &lt;= 0x000fffff) {  /* subnormal b or 0 */  
        if((hb|(__LO(b)))==0) return a;
        t1=0;
        __HI(t1) = 0x7fd00000;  /* t1=2^1022 */
        b *= t1;
        a *= t1;
        k -= 1022;
        } else {        /* scale a and b by 2^600 */
            ha += 0x25800000;   /* a *= 2^600 */
        hb += 0x25800000;   /* b *= 2^600 */
        k -= 600;
        __HI(a) = ha;
        __HI(b) = hb;
        }
    }
    /* medium size a and b */
    w = a-b;
    if (w&gt;b) {
        t1 = 0;
        __HI(t1) = ha;
        t2 = a-t1;
        w  = sqrt(t1*t1-(b*(-b)-t2*(a+t1)));
    } else {
        a  = a+a;
        y1 = 0;
        __HI(y1) = hb;
        y2 = b - y1;
        t1 = 0;
        __HI(t1) = ha+0x00100000;
        t2 = a - t1;
        w  = sqrt(t1*y1-(w*(-w)-(t1*y2+t2*b)));
    }
    if(k!=0) {
        t1 = 1.0;
        __HI(t1) += (k&lt;&lt;20);
        return t1*w;
    } else return w;
}
</code></pre>

<ul>
<li><strong><code>e_j0.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/* __ieee754_j0(x), __ieee754_y0(x)
 * Bessel function of the first and second kinds of order zero.
 * Method -- j0(x):
 *  1. For tiny x, we use j0(x) = 1 - x^2/4 + x^4/64 - ...
 *  2. Reduce x to |x| since j0(x)=j0(-x),  and
 *     for x in (0,2)
 *      j0(x) = 1-z/4+ z^2*R0/S0,  where z = x*x;
 *     (precision:  |j0-1+z/4-z^2R0/S0 |&lt;2**-63.67 )
 *     for x in (2,inf)
 *      j0(x) = sqrt(2/(pi*x))*(p0(x)*cos(x0)-q0(x)*sin(x0))
 *     where x0 = x-pi/4. It is better to compute sin(x0),cos(x0)
 *     as follow:
 *      cos(x0) = cos(x)cos(pi/4)+sin(x)sin(pi/4)
 *          = 1/sqrt(2) * (cos(x) + sin(x))
 *      sin(x0) = sin(x)cos(pi/4)-cos(x)sin(pi/4)
 *          = 1/sqrt(2) * (sin(x) - cos(x))
 *     (To avoid cancellation, use
 *      sin(x) +- cos(x) = -cos(2x)/(sin(x) -+ cos(x))
 *      to compute the worse one.)
 *     
 *  3 Special cases
 *      j0(nan)= nan
 *      j0(0) = 1
 *      j0(inf) = 0
 *      
 * Method -- y0(x):
 *  1. For x&lt;2.
 *     Since 
 *      y0(x) = 2/pi*(j0(x)*(ln(x/2)+Euler) + x^2/4 - ...)
 *     therefore y0(x)-2/pi*j0(x)*ln(x) is an even function.
 *     We use the following function to approximate y0,
 *      y0(x) = U(z)/V(z) + (2/pi)*(j0(x)*ln(x)), z= x^2
 *     where 
 *      U(z) = u00 + u01*z + ... + u06*z^6
 *      V(z) = 1  + v01*z + ... + v04*z^4
 *     with absolute approximation error bounded by 2**-72.
 *     Note: For tiny x, U/V = u0 and j0(x)~1, hence
 *      y0(tiny) = u0 + (2/pi)*ln(tiny), (choose tiny&lt;2**-27)
 *  2. For x&gt;=2.
 *      y0(x) = sqrt(2/(pi*x))*(p0(x)*cos(x0)+q0(x)*sin(x0))
 *     where x0 = x-pi/4. It is better to compute sin(x0),cos(x0)
 *     by the method mentioned above.
 *  3. Special cases: y0(0)=-inf, y0(x&lt;0)=NaN, y0(inf)=0.
 */

#include &quot;fdlibm.h&quot;

#ifdef __STDC__
static double pzero(double), qzero(double);
#else
static double pzero(), qzero();
#endif

#ifdef __STDC__
static const double 
#else
static double 
#endif
huge    = 1e300,
one = 1.0,
invsqrtpi=  5.64189583547756279280e-01, /* 0x3FE20DD7, 0x50429B6D */
tpi      =  6.36619772367581382433e-01, /* 0x3FE45F30, 0x6DC9C883 */
        /* R0/S0 on [0, 2.00] */
R02  =  1.56249999999999947958e-02, /* 0x3F8FFFFF, 0xFFFFFFFD */
R03  = -1.89979294238854721751e-04, /* 0xBF28E6A5, 0xB61AC6E9 */
R04  =  1.82954049532700665670e-06, /* 0x3EBEB1D1, 0x0C503919 */
R05  = -4.61832688532103189199e-09, /* 0xBE33D5E7, 0x73D63FCE */
S01  =  1.56191029464890010492e-02, /* 0x3F8FFCE8, 0x82C8C2A4 */
S02  =  1.16926784663337450260e-04, /* 0x3F1EA6D2, 0xDD57DBF4 */
S03  =  5.13546550207318111446e-07, /* 0x3EA13B54, 0xCE84D5A9 */
S04  =  1.16614003333790000205e-09; /* 0x3E1408BC, 0xF4745D8F */

static double zero = 0.0;

#ifdef __STDC__
    double __ieee754_j0(double x) 
#else
    double __ieee754_j0(x) 
    double x;
#endif
{
    double z, s,c,ss,cc,r,u,v;
    int hx,ix;

    hx = __HI(x);
    ix = hx&amp;0x7fffffff;
    if(ix&gt;=0x7ff00000) return one/(x*x);
    x = fabs(x);
    if(ix &gt;= 0x40000000) {  /* |x| &gt;= 2.0 */
        s = sin(x);
        c = cos(x);
        ss = s-c;
        cc = s+c;
        if(ix&lt;0x7fe00000) {  /* make sure x+x not overflow */
            z = -cos(x+x);
            if ((s*c)&lt;zero) cc = z/ss;
            else        ss = z/cc;
        }
    /*
     * j0(x) = 1/sqrt(pi) * (P(0,x)*cc - Q(0,x)*ss) / sqrt(x)
     * y0(x) = 1/sqrt(pi) * (P(0,x)*ss + Q(0,x)*cc) / sqrt(x)
     */
        if(ix&gt;0x48000000) z = (invsqrtpi*cc)/sqrt(x);
        else {
            u = pzero(x); v = qzero(x);
            z = invsqrtpi*(u*cc-v*ss)/sqrt(x);
        }
        return z;
    }
    if(ix&lt;0x3f200000) { /* |x| &lt; 2**-13 */
        if(huge+x&gt;one) {    /* raise inexact if x != 0 */
            if(ix&lt;0x3e400000) return one;   /* |x|&lt;2**-27 */
            else          return one - 0.25*x*x;
        }
    }
    z = x*x;
    r =  z*(R02+z*(R03+z*(R04+z*R05)));
    s =  one+z*(S01+z*(S02+z*(S03+z*S04)));
    if(ix &lt; 0x3FF00000) {   /* |x| &lt; 1.00 */
        return one + z*(-0.25+(r/s));
    } else {
        u = 0.5*x;
        return((one+u)*(one-u)+z*(r/s));
    }
}

#ifdef __STDC__
static const double
#else
static double
#endif
u00  = -7.38042951086872317523e-02, /* 0xBFB2E4D6, 0x99CBD01F */
u01  =  1.76666452509181115538e-01, /* 0x3FC69D01, 0x9DE9E3FC */
u02  = -1.38185671945596898896e-02, /* 0xBF8C4CE8, 0xB16CFA97 */
u03  =  3.47453432093683650238e-04, /* 0x3F36C54D, 0x20B29B6B */
u04  = -3.81407053724364161125e-06, /* 0xBECFFEA7, 0x73D25CAD */
u05  =  1.95590137035022920206e-08, /* 0x3E550057, 0x3B4EABD4 */
u06  = -3.98205194132103398453e-11, /* 0xBDC5E43D, 0x693FB3C8 */
v01  =  1.27304834834123699328e-02, /* 0x3F8A1270, 0x91C9C71A */
v02  =  7.60068627350353253702e-05, /* 0x3F13ECBB, 0xF578C6C1 */
v03  =  2.59150851840457805467e-07, /* 0x3E91642D, 0x7FF202FD */
v04  =  4.41110311332675467403e-10; /* 0x3DFE5018, 0x3BD6D9EF */

#ifdef __STDC__
    double __ieee754_y0(double x) 
#else
    double __ieee754_y0(x) 
    double x;
#endif
{
    double z, s,c,ss,cc,u,v;
    int hx,ix,lx;

        hx = __HI(x);
        ix = 0x7fffffff&amp;hx;
        lx = __LO(x);
    /* Y0(NaN) is NaN, y0(-inf) is Nan, y0(inf) is 0  */
    if(ix&gt;=0x7ff00000) return  one/(x+x*x); 
        if((ix|lx)==0) return -one/zero;
        if(hx&lt;0) return zero/zero;
        if(ix &gt;= 0x40000000) {  /* |x| &gt;= 2.0 */
        /* y0(x) = sqrt(2/(pi*x))*(p0(x)*sin(x0)+q0(x)*cos(x0))
         * where x0 = x-pi/4
         *      Better formula:
         *              cos(x0) = cos(x)cos(pi/4)+sin(x)sin(pi/4)
         *                      =  1/sqrt(2) * (sin(x) + cos(x))
         *              sin(x0) = sin(x)cos(3pi/4)-cos(x)sin(3pi/4)
         *                      =  1/sqrt(2) * (sin(x) - cos(x))
         * To avoid cancellation, use
         *              sin(x) +- cos(x) = -cos(2x)/(sin(x) -+ cos(x))
         * to compute the worse one.
         */
                s = sin(x);
                c = cos(x);
                ss = s-c;
                cc = s+c;
    /*
     * j0(x) = 1/sqrt(pi) * (P(0,x)*cc - Q(0,x)*ss) / sqrt(x)
     * y0(x) = 1/sqrt(pi) * (P(0,x)*ss + Q(0,x)*cc) / sqrt(x)
     */
                if(ix&lt;0x7fe00000) {  /* make sure x+x not overflow */
                    z = -cos(x+x);
                    if ((s*c)&lt;zero) cc = z/ss;
                    else            ss = z/cc;
                }
                if(ix&gt;0x48000000) z = (invsqrtpi*ss)/sqrt(x);
                else {
                    u = pzero(x); v = qzero(x);
                    z = invsqrtpi*(u*ss+v*cc)/sqrt(x);
                }
                return z;
    }
    if(ix&lt;=0x3e400000) {    /* x &lt; 2**-27 */
        return(u00 + tpi*__ieee754_log(x));
    }
    z = x*x;
    u = u00+z*(u01+z*(u02+z*(u03+z*(u04+z*(u05+z*u06)))));
    v = one+z*(v01+z*(v02+z*(v03+z*v04)));
    return(u/v + tpi*(__ieee754_j0(x)*__ieee754_log(x)));
}

/* The asymptotic expansions of pzero is
 *  1 - 9/128 s^2 + 11025/98304 s^4 - ...,  where s = 1/x.
 * For x &gt;= 2, We approximate pzero by
 *  pzero(x) = 1 + (R/S)
 * where  R = pR0 + pR1*s^2 + pR2*s^4 + ... + pR5*s^10
 *    S = 1 + pS0*s^2 + ... + pS4*s^10
 * and
 *  | pzero(x)-1-R/S | &lt;= 2  ** ( -60.26)
 */
#ifdef __STDC__
static const double pR8[6] = { /* for x in [inf, 8]=1/[0,0.125] */
#else
static double pR8[6] = { /* for x in [inf, 8]=1/[0,0.125] */
#endif
  0.00000000000000000000e+00, /* 0x00000000, 0x00000000 */
 -7.03124999999900357484e-02, /* 0xBFB1FFFF, 0xFFFFFD32 */
 -8.08167041275349795626e+00, /* 0xC02029D0, 0xB44FA779 */
 -2.57063105679704847262e+02, /* 0xC0701102, 0x7B19E863 */
 -2.48521641009428822144e+03, /* 0xC0A36A6E, 0xCD4DCAFC */
 -5.25304380490729545272e+03, /* 0xC0B4850B, 0x36CC643D */
};
#ifdef __STDC__
static const double pS8[5] = {
#else
static double pS8[5] = {
#endif
  1.16534364619668181717e+02, /* 0x405D2233, 0x07A96751 */
  3.83374475364121826715e+03, /* 0x40ADF37D, 0x50596938 */
  4.05978572648472545552e+04, /* 0x40E3D2BB, 0x6EB6B05F */
  1.16752972564375915681e+05, /* 0x40FC810F, 0x8F9FA9BD */
  4.76277284146730962675e+04, /* 0x40E74177, 0x4F2C49DC */
};

#ifdef __STDC__
static const double pR5[6] = { /* for x in [8,4.5454]=1/[0.125,0.22001] */
#else
static double pR5[6] = { /* for x in [8,4.5454]=1/[0.125,0.22001] */
#endif
 -1.14125464691894502584e-11, /* 0xBDA918B1, 0x47E495CC */
 -7.03124940873599280078e-02, /* 0xBFB1FFFF, 0xE69AFBC6 */
 -4.15961064470587782438e+00, /* 0xC010A370, 0xF90C6BBF */
 -6.76747652265167261021e+01, /* 0xC050EB2F, 0x5A7D1783 */
 -3.31231299649172967747e+02, /* 0xC074B3B3, 0x6742CC63 */
 -3.46433388365604912451e+02, /* 0xC075A6EF, 0x28A38BD7 */
};
#ifdef __STDC__
static const double pS5[5] = {
#else
static double pS5[5] = {
#endif
  6.07539382692300335975e+01, /* 0x404E6081, 0x0C98C5DE */
  1.05125230595704579173e+03, /* 0x40906D02, 0x5C7E2864 */
  5.97897094333855784498e+03, /* 0x40B75AF8, 0x8FBE1D60 */
  9.62544514357774460223e+03, /* 0x40C2CCB8, 0xFA76FA38 */
  2.40605815922939109441e+03, /* 0x40A2CC1D, 0xC70BE864 */
};

#ifdef __STDC__
static const double pR3[6] = {/* for x in [4.547,2.8571]=1/[0.2199,0.35001] */
#else
static double pR3[6] = {/* for x in [4.547,2.8571]=1/[0.2199,0.35001] */
#endif
 -2.54704601771951915620e-09, /* 0xBE25E103, 0x6FE1AA86 */
 -7.03119616381481654654e-02, /* 0xBFB1FFF6, 0xF7C0E24B */
 -2.40903221549529611423e+00, /* 0xC00345B2, 0xAEA48074 */
 -2.19659774734883086467e+01, /* 0xC035F74A, 0x4CB94E14 */
 -5.80791704701737572236e+01, /* 0xC04D0A22, 0x420A1A45 */
 -3.14479470594888503854e+01, /* 0xC03F72AC, 0xA892D80F */
};
#ifdef __STDC__
static const double pS3[5] = {
#else
static double pS3[5] = {
#endif
  3.58560338055209726349e+01, /* 0x4041ED92, 0x84077DD3 */
  3.61513983050303863820e+02, /* 0x40769839, 0x464A7C0E */
  1.19360783792111533330e+03, /* 0x4092A66E, 0x6D1061D6 */
  1.12799679856907414432e+03, /* 0x40919FFC, 0xB8C39B7E */
  1.73580930813335754692e+02, /* 0x4065B296, 0xFC379081 */
};

#ifdef __STDC__
static const double pR2[6] = {/* for x in [2.8570,2]=1/[0.3499,0.5] */
#else
static double pR2[6] = {/* for x in [2.8570,2]=1/[0.3499,0.5] */
#endif
 -8.87534333032526411254e-08, /* 0xBE77D316, 0xE927026D */
 -7.03030995483624743247e-02, /* 0xBFB1FF62, 0x495E1E42 */
 -1.45073846780952986357e+00, /* 0xBFF73639, 0x8A24A843 */
 -7.63569613823527770791e+00, /* 0xC01E8AF3, 0xEDAFA7F3 */
 -1.11931668860356747786e+01, /* 0xC02662E6, 0xC5246303 */
 -3.23364579351335335033e+00, /* 0xC009DE81, 0xAF8FE70F */
};
#ifdef __STDC__
static const double pS2[5] = {
#else
static double pS2[5] = {
#endif
  2.22202997532088808441e+01, /* 0x40363865, 0x908B5959 */
  1.36206794218215208048e+02, /* 0x4061069E, 0x0EE8878F */
  2.70470278658083486789e+02, /* 0x4070E786, 0x42EA079B */
  1.53875394208320329881e+02, /* 0x40633C03, 0x3AB6FAFF */
  1.46576176948256193810e+01, /* 0x402D50B3, 0x44391809 */
};

#ifdef __STDC__
    static double pzero(double x)
#else
    static double pzero(x)
    double x;
#endif
{
#ifdef __STDC__
    const double *p,*q;
#else
    double *p,*q;
#endif
    double z,r,s;
    int ix;
    ix = 0x7fffffff&amp;__HI(x);
    if(ix&gt;=0x40200000)     {p = pR8; q= pS8;}
    else if(ix&gt;=0x40122E8B){p = pR5; q= pS5;}
    else if(ix&gt;=0x4006DB6D){p = pR3; q= pS3;}
    else if(ix&gt;=0x40000000){p = pR2; q= pS2;}
    z = one/(x*x);
    r = p[0]+z*(p[1]+z*(p[2]+z*(p[3]+z*(p[4]+z*p[5]))));
    s = one+z*(q[0]+z*(q[1]+z*(q[2]+z*(q[3]+z*q[4]))));
    return one+ r/s;
}


/* For x &gt;= 8, the asymptotic expansions of qzero is
 *  -1/8 s + 75/1024 s^3 - ..., where s = 1/x.
 * We approximate pzero by
 *  qzero(x) = s*(-1.25 + (R/S))
 * where  R = qR0 + qR1*s^2 + qR2*s^4 + ... + qR5*s^10
 *    S = 1 + qS0*s^2 + ... + qS5*s^12
 * and
 *  | qzero(x)/s +1.25-R/S | &lt;= 2  ** ( -61.22)
 */
#ifdef __STDC__
static const double qR8[6] = { /* for x in [inf, 8]=1/[0,0.125] */
#else
static double qR8[6] = { /* for x in [inf, 8]=1/[0,0.125] */
#endif
  0.00000000000000000000e+00, /* 0x00000000, 0x00000000 */
  7.32421874999935051953e-02, /* 0x3FB2BFFF, 0xFFFFFE2C */
  1.17682064682252693899e+01, /* 0x40278952, 0x5BB334D6 */
  5.57673380256401856059e+02, /* 0x40816D63, 0x15301825 */
  8.85919720756468632317e+03, /* 0x40C14D99, 0x3E18F46D */
  3.70146267776887834771e+04, /* 0x40E212D4, 0x0E901566 */
};
#ifdef __STDC__
static const double qS8[6] = {
#else
static double qS8[6] = {
#endif
  1.63776026895689824414e+02, /* 0x406478D5, 0x365B39BC */
  8.09834494656449805916e+03, /* 0x40BFA258, 0x4E6B0563 */
  1.42538291419120476348e+05, /* 0x41016652, 0x54D38C3F */
  8.03309257119514397345e+05, /* 0x412883DA, 0x83A52B43 */
  8.40501579819060512818e+05, /* 0x4129A66B, 0x28DE0B3D */
 -3.43899293537866615225e+05, /* 0xC114FD6D, 0x2C9530C5 */
};

#ifdef __STDC__
static const double qR5[6] = { /* for x in [8,4.5454]=1/[0.125,0.22001] */
#else
static double qR5[6] = { /* for x in [8,4.5454]=1/[0.125,0.22001] */
#endif
  1.84085963594515531381e-11, /* 0x3DB43D8F, 0x29CC8CD9 */
  7.32421766612684765896e-02, /* 0x3FB2BFFF, 0xD172B04C */
  5.83563508962056953777e+00, /* 0x401757B0, 0xB9953DD3 */
  1.35111577286449829671e+02, /* 0x4060E392, 0x0A8788E9 */
  1.02724376596164097464e+03, /* 0x40900CF9, 0x9DC8C481 */
  1.98997785864605384631e+03, /* 0x409F17E9, 0x53C6E3A6 */
};
#ifdef __STDC__
static const double qS5[6] = {
#else
static double qS5[6] = {
#endif
  8.27766102236537761883e+01, /* 0x4054B1B3, 0xFB5E1543 */
  2.07781416421392987104e+03, /* 0x40A03BA0, 0xDA21C0CE */
  1.88472887785718085070e+04, /* 0x40D267D2, 0x7B591E6D */
  5.67511122894947329769e+04, /* 0x40EBB5E3, 0x97E02372 */
  3.59767538425114471465e+04, /* 0x40E19118, 0x1F7A54A0 */
 -5.35434275601944773371e+03, /* 0xC0B4EA57, 0xBEDBC609 */
};

#ifdef __STDC__
static const double qR3[6] = {/* for x in [4.547,2.8571]=1/[0.2199,0.35001] */
#else
static double qR3[6] = {/* for x in [4.547,2.8571]=1/[0.2199,0.35001] */
#endif
  4.37741014089738620906e-09, /* 0x3E32CD03, 0x6ADECB82 */
  7.32411180042911447163e-02, /* 0x3FB2BFEE, 0x0E8D0842 */
  3.34423137516170720929e+00, /* 0x400AC0FC, 0x61149CF5 */
  4.26218440745412650017e+01, /* 0x40454F98, 0x962DAEDD */
  1.70808091340565596283e+02, /* 0x406559DB, 0xE25EFD1F */
  1.66733948696651168575e+02, /* 0x4064D77C, 0x81FA21E0 */
};
#ifdef __STDC__
static const double qS3[6] = {
#else
static double qS3[6] = {
#endif
  4.87588729724587182091e+01, /* 0x40486122, 0xBFE343A6 */
  7.09689221056606015736e+02, /* 0x40862D83, 0x86544EB3 */
  3.70414822620111362994e+03, /* 0x40ACF04B, 0xE44DFC63 */
  6.46042516752568917582e+03, /* 0x40B93C6C, 0xD7C76A28 */
  2.51633368920368957333e+03, /* 0x40A3A8AA, 0xD94FB1C0 */
 -1.49247451836156386662e+02, /* 0xC062A7EB, 0x201CF40F */
};

#ifdef __STDC__
static const double qR2[6] = {/* for x in [2.8570,2]=1/[0.3499,0.5] */
#else
static double qR2[6] = {/* for x in [2.8570,2]=1/[0.3499,0.5] */
#endif
  1.50444444886983272379e-07, /* 0x3E84313B, 0x54F76BDB */
  7.32234265963079278272e-02, /* 0x3FB2BEC5, 0x3E883E34 */
  1.99819174093815998816e+00, /* 0x3FFFF897, 0xE727779C */
  1.44956029347885735348e+01, /* 0x402CFDBF, 0xAAF96FE5 */
  3.16662317504781540833e+01, /* 0x403FAA8E, 0x29FBDC4A */
  1.62527075710929267416e+01, /* 0x403040B1, 0x71814BB4 */
};
#ifdef __STDC__
static const double qS2[6] = {
#else
static double qS2[6] = {
#endif
  3.03655848355219184498e+01, /* 0x403E5D96, 0xF7C07AED */
  2.69348118608049844624e+02, /* 0x4070D591, 0xE4D14B40 */
  8.44783757595320139444e+02, /* 0x408A6645, 0x22B3BF22 */
  8.82935845112488550512e+02, /* 0x408B977C, 0x9C5CC214 */
  2.12666388511798828631e+02, /* 0x406A9553, 0x0E001365 */
 -5.31095493882666946917e+00, /* 0xC0153E6A, 0xF8B32931 */
};

#ifdef __STDC__
    static double qzero(double x)
#else
    static double qzero(x)
    double x;
#endif
{
#ifdef __STDC__
    const double *p,*q;
#else
    double *p,*q;
#endif
    double s,r,z;
    int ix;
    ix = 0x7fffffff&amp;__HI(x);
    if(ix&gt;=0x40200000)     {p = qR8; q= qS8;}
    else if(ix&gt;=0x40122E8B){p = qR5; q= qS5;}
    else if(ix&gt;=0x4006DB6D){p = qR3; q= qS3;}
    else if(ix&gt;=0x40000000){p = qR2; q= qS2;}
    z = one/(x*x);
    r = p[0]+z*(p[1]+z*(p[2]+z*(p[3]+z*(p[4]+z*p[5]))));
    s = one+z*(q[0]+z*(q[1]+z*(q[2]+z*(q[3]+z*(q[4]+z*q[5])))));
    return (-.125 + r/s)/x;
}
</code></pre>

<ul>
<li><strong><code>e_j1.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/* __ieee754_j1(x), __ieee754_y1(x)
 * Bessel function of the first and second kinds of order zero.
 * Method -- j1(x):
 *  1. For tiny x, we use j1(x) = x/2 - x^3/16 + x^5/384 - ...
 *  2. Reduce x to |x| since j1(x)=-j1(-x),  and
 *     for x in (0,2)
 *      j1(x) = x/2 + x*z*R0/S0,  where z = x*x;
 *     (precision:  |j1/x - 1/2 - R0/S0 |&lt;2**-61.51 )
 *     for x in (2,inf)
 *      j1(x) = sqrt(2/(pi*x))*(p1(x)*cos(x1)-q1(x)*sin(x1))
 *      y1(x) = sqrt(2/(pi*x))*(p1(x)*sin(x1)+q1(x)*cos(x1))
 *     where x1 = x-3*pi/4. It is better to compute sin(x1),cos(x1)
 *     as follow:
 *      cos(x1) =  cos(x)cos(3pi/4)+sin(x)sin(3pi/4)
 *          =  1/sqrt(2) * (sin(x) - cos(x))
 *      sin(x1) =  sin(x)cos(3pi/4)-cos(x)sin(3pi/4)
 *          = -1/sqrt(2) * (sin(x) + cos(x))
 *     (To avoid cancellation, use
 *      sin(x) +- cos(x) = -cos(2x)/(sin(x) -+ cos(x))
 *      to compute the worse one.)
 *     
 *  3 Special cases
 *      j1(nan)= nan
 *      j1(0) = 0
 *      j1(inf) = 0
 *      
 * Method -- y1(x):
 *  1. screen out x&lt;=0 cases: y1(0)=-inf, y1(x&lt;0)=NaN 
 *  2. For x&lt;2.
 *     Since 
 *      y1(x) = 2/pi*(j1(x)*(ln(x/2)+Euler)-1/x-x/2+5/64*x^3-...)
 *     therefore y1(x)-2/pi*j1(x)*ln(x)-1/x is an odd function.
 *     We use the following function to approximate y1,
 *      y1(x) = x*U(z)/V(z) + (2/pi)*(j1(x)*ln(x)-1/x), z= x^2
 *     where for x in [0,2] (abs err less than 2**-65.89)
 *      U(z) = U0[0] + U0[1]*z + ... + U0[4]*z^4
 *      V(z) = 1  + v0[0]*z + ... + v0[4]*z^5
 *     Note: For tiny x, 1/x dominate y1 and hence
 *      y1(tiny) = -2/pi/tiny, (choose tiny&lt;2**-54)
 *  3. For x&gt;=2.
 *      y1(x) = sqrt(2/(pi*x))*(p1(x)*sin(x1)+q1(x)*cos(x1))
 *     where x1 = x-3*pi/4. It is better to compute sin(x1),cos(x1)
 *     by method mentioned above.
 */

#include &quot;fdlibm.h&quot;

#ifdef __STDC__
static double pone(double), qone(double);
#else
static double pone(), qone();
#endif

#ifdef __STDC__
static const double 
#else
static double 
#endif
huge    = 1e300,
one = 1.0,
invsqrtpi=  5.64189583547756279280e-01, /* 0x3FE20DD7, 0x50429B6D */
tpi      =  6.36619772367581382433e-01, /* 0x3FE45F30, 0x6DC9C883 */
    /* R0/S0 on [0,2] */
r00  = -6.25000000000000000000e-02, /* 0xBFB00000, 0x00000000 */
r01  =  1.40705666955189706048e-03, /* 0x3F570D9F, 0x98472C61 */
r02  = -1.59955631084035597520e-05, /* 0xBEF0C5C6, 0xBA169668 */
r03  =  4.96727999609584448412e-08, /* 0x3E6AAAFA, 0x46CA0BD9 */
s01  =  1.91537599538363460805e-02, /* 0x3F939D0B, 0x12637E53 */
s02  =  1.85946785588630915560e-04, /* 0x3F285F56, 0xB9CDF664 */
s03  =  1.17718464042623683263e-06, /* 0x3EB3BFF8, 0x333F8498 */
s04  =  5.04636257076217042715e-09, /* 0x3E35AC88, 0xC97DFF2C */
s05  =  1.23542274426137913908e-11; /* 0x3DAB2ACF, 0xCFB97ED8 */

static double zero    = 0.0;

#ifdef __STDC__
    double __ieee754_j1(double x) 
#else
    double __ieee754_j1(x) 
    double x;
#endif
{
    double z, s,c,ss,cc,r,u,v,y;
    int hx,ix;

    hx = __HI(x);
    ix = hx&amp;0x7fffffff;
    if(ix&gt;=0x7ff00000) return one/x;
    y = fabs(x);
    if(ix &gt;= 0x40000000) {  /* |x| &gt;= 2.0 */
        s = sin(y);
        c = cos(y);
        ss = -s-c;
        cc = s-c;
        if(ix&lt;0x7fe00000) {  /* make sure y+y not overflow */
            z = cos(y+y);
            if ((s*c)&gt;zero) cc = z/ss;
            else        ss = z/cc;
        }
    /*
     * j1(x) = 1/sqrt(pi) * (P(1,x)*cc - Q(1,x)*ss) / sqrt(x)
     * y1(x) = 1/sqrt(pi) * (P(1,x)*ss + Q(1,x)*cc) / sqrt(x)
     */
        if(ix&gt;0x48000000) z = (invsqrtpi*cc)/sqrt(y);
        else {
            u = pone(y); v = qone(y);
            z = invsqrtpi*(u*cc-v*ss)/sqrt(y);
        }
        if(hx&lt;0) return -z;
        else     return  z;
    }
    if(ix&lt;0x3e400000) { /* |x|&lt;2**-27 */
        if(huge+x&gt;one) return 0.5*x;/* inexact if x!=0 necessary */
    }
    z = x*x;
    r =  z*(r00+z*(r01+z*(r02+z*r03)));
    s =  one+z*(s01+z*(s02+z*(s03+z*(s04+z*s05))));
    r *= x;
    return(x*0.5+r/s);
}

#ifdef __STDC__
static const double U0[5] = {
#else
static double U0[5] = {
#endif
 -1.96057090646238940668e-01, /* 0xBFC91866, 0x143CBC8A */
  5.04438716639811282616e-02, /* 0x3FA9D3C7, 0x76292CD1 */
 -1.91256895875763547298e-03, /* 0xBF5F55E5, 0x4844F50F */
  2.35252600561610495928e-05, /* 0x3EF8AB03, 0x8FA6B88E */
 -9.19099158039878874504e-08, /* 0xBE78AC00, 0x569105B8 */
};
#ifdef __STDC__
static const double V0[5] = {
#else
static double V0[5] = {
#endif
  1.99167318236649903973e-02, /* 0x3F94650D, 0x3F4DA9F0 */
  2.02552581025135171496e-04, /* 0x3F2A8C89, 0x6C257764 */
  1.35608801097516229404e-06, /* 0x3EB6C05A, 0x894E8CA6 */
  6.22741452364621501295e-09, /* 0x3E3ABF1D, 0x5BA69A86 */
  1.66559246207992079114e-11, /* 0x3DB25039, 0xDACA772A */
};

#ifdef __STDC__
    double __ieee754_y1(double x) 
#else
    double __ieee754_y1(x) 
    double x;
#endif
{
    double z, s,c,ss,cc,u,v;
    int hx,ix,lx;

        hx = __HI(x);
        ix = 0x7fffffff&amp;hx;
        lx = __LO(x);
    /* if Y1(NaN) is NaN, Y1(-inf) is NaN, Y1(inf) is 0 */
    if(ix&gt;=0x7ff00000) return  one/(x+x*x); 
        if((ix|lx)==0) return -one/zero;
        if(hx&lt;0) return zero/zero;
        if(ix &gt;= 0x40000000) {  /* |x| &gt;= 2.0 */
                s = sin(x);
                c = cos(x);
                ss = -s-c;
                cc = s-c;
                if(ix&lt;0x7fe00000) {  /* make sure x+x not overflow */
                    z = cos(x+x);
                    if ((s*c)&gt;zero) cc = z/ss;
                    else            ss = z/cc;
                }
        /* y1(x) = sqrt(2/(pi*x))*(p1(x)*sin(x0)+q1(x)*cos(x0))
         * where x0 = x-3pi/4
         *      Better formula:
         *              cos(x0) = cos(x)cos(3pi/4)+sin(x)sin(3pi/4)
         *                      =  1/sqrt(2) * (sin(x) - cos(x))
         *              sin(x0) = sin(x)cos(3pi/4)-cos(x)sin(3pi/4)
         *                      = -1/sqrt(2) * (cos(x) + sin(x))
         * To avoid cancellation, use
         *              sin(x) +- cos(x) = -cos(2x)/(sin(x) -+ cos(x))
         * to compute the worse one.
         */
                if(ix&gt;0x48000000) z = (invsqrtpi*ss)/sqrt(x);
                else {
                    u = pone(x); v = qone(x);
                    z = invsqrtpi*(u*ss+v*cc)/sqrt(x);
                }
                return z;
        } 
        if(ix&lt;=0x3c900000) {    /* x &lt; 2**-54 */
            return(-tpi/x);
        } 
        z = x*x;
        u = U0[0]+z*(U0[1]+z*(U0[2]+z*(U0[3]+z*U0[4])));
        v = one+z*(V0[0]+z*(V0[1]+z*(V0[2]+z*(V0[3]+z*V0[4]))));
        return(x*(u/v) + tpi*(__ieee754_j1(x)*__ieee754_log(x)-one/x));
}

/* For x &gt;= 8, the asymptotic expansions of pone is
 *  1 + 15/128 s^2 - 4725/2^15 s^4 - ...,   where s = 1/x.
 * We approximate pone by
 *  pone(x) = 1 + (R/S)
 * where  R = pr0 + pr1*s^2 + pr2*s^4 + ... + pr5*s^10
 *    S = 1 + ps0*s^2 + ... + ps4*s^10
 * and
 *  | pone(x)-1-R/S | &lt;= 2  ** ( -60.06)
 */

#ifdef __STDC__
static const double pr8[6] = { /* for x in [inf, 8]=1/[0,0.125] */
#else
static double pr8[6] = { /* for x in [inf, 8]=1/[0,0.125] */
#endif
  0.00000000000000000000e+00, /* 0x00000000, 0x00000000 */
  1.17187499999988647970e-01, /* 0x3FBDFFFF, 0xFFFFFCCE */
  1.32394806593073575129e+01, /* 0x402A7A9D, 0x357F7FCE */
  4.12051854307378562225e+02, /* 0x4079C0D4, 0x652EA590 */
  3.87474538913960532227e+03, /* 0x40AE457D, 0xA3A532CC */
  7.91447954031891731574e+03, /* 0x40BEEA7A, 0xC32782DD */
};
#ifdef __STDC__
static const double ps8[5] = {
#else
static double ps8[5] = {
#endif
  1.14207370375678408436e+02, /* 0x405C8D45, 0x8E656CAC */
  3.65093083420853463394e+03, /* 0x40AC85DC, 0x964D274F */
  3.69562060269033463555e+04, /* 0x40E20B86, 0x97C5BB7F */
  9.76027935934950801311e+04, /* 0x40F7D42C, 0xB28F17BB */
  3.08042720627888811578e+04, /* 0x40DE1511, 0x697A0B2D */
};

#ifdef __STDC__
static const double pr5[6] = { /* for x in [8,4.5454]=1/[0.125,0.22001] */
#else
static double pr5[6] = { /* for x in [8,4.5454]=1/[0.125,0.22001] */
#endif
  1.31990519556243522749e-11, /* 0x3DAD0667, 0xDAE1CA7D */
  1.17187493190614097638e-01, /* 0x3FBDFFFF, 0xE2C10043 */
  6.80275127868432871736e+00, /* 0x401B3604, 0x6E6315E3 */
  1.08308182990189109773e+02, /* 0x405B13B9, 0x452602ED */
  5.17636139533199752805e+02, /* 0x40802D16, 0xD052D649 */
  5.28715201363337541807e+02, /* 0x408085B8, 0xBB7E0CB7 */
};
#ifdef __STDC__
static const double ps5[5] = {
#else
static double ps5[5] = {
#endif
  5.92805987221131331921e+01, /* 0x404DA3EA, 0xA8AF633D */
  9.91401418733614377743e+02, /* 0x408EFB36, 0x1B066701 */
  5.35326695291487976647e+03, /* 0x40B4E944, 0x5706B6FB */
  7.84469031749551231769e+03, /* 0x40BEA4B0, 0xB8A5BB15 */
  1.50404688810361062679e+03, /* 0x40978030, 0x036F5E51 */
};

#ifdef __STDC__
static const double pr3[6] = {
#else
static double pr3[6] = {/* for x in [4.547,2.8571]=1/[0.2199,0.35001] */
#endif
  3.02503916137373618024e-09, /* 0x3E29FC21, 0xA7AD9EDD */
  1.17186865567253592491e-01, /* 0x3FBDFFF5, 0x5B21D17B */
  3.93297750033315640650e+00, /* 0x400F76BC, 0xE85EAD8A */
  3.51194035591636932736e+01, /* 0x40418F48, 0x9DA6D129 */
  9.10550110750781271918e+01, /* 0x4056C385, 0x4D2C1837 */
  4.85590685197364919645e+01, /* 0x4048478F, 0x8EA83EE5 */
};
#ifdef __STDC__
static const double ps3[5] = {
#else
static double ps3[5] = {
#endif
  3.47913095001251519989e+01, /* 0x40416549, 0xA134069C */
  3.36762458747825746741e+02, /* 0x40750C33, 0x07F1A75F */
  1.04687139975775130551e+03, /* 0x40905B7C, 0x5037D523 */
  8.90811346398256432622e+02, /* 0x408BD67D, 0xA32E31E9 */
  1.03787932439639277504e+02, /* 0x4059F26D, 0x7C2EED53 */
};

#ifdef __STDC__
static const double pr2[6] = {/* for x in [2.8570,2]=1/[0.3499,0.5] */
#else
static double pr2[6] = {/* for x in [2.8570,2]=1/[0.3499,0.5] */
#endif
  1.07710830106873743082e-07, /* 0x3E7CE9D4, 0xF65544F4 */
  1.17176219462683348094e-01, /* 0x3FBDFF42, 0xBE760D83 */
  2.36851496667608785174e+00, /* 0x4002F2B7, 0xF98FAEC0 */
  1.22426109148261232917e+01, /* 0x40287C37, 0x7F71A964 */
  1.76939711271687727390e+01, /* 0x4031B1A8, 0x177F8EE2 */
  5.07352312588818499250e+00, /* 0x40144B49, 0xA574C1FE */
};
#ifdef __STDC__
static const double ps2[5] = {
#else
static double ps2[5] = {
#endif
  2.14364859363821409488e+01, /* 0x40356FBD, 0x8AD5ECDC */
  1.25290227168402751090e+02, /* 0x405F5293, 0x14F92CD5 */
  2.32276469057162813669e+02, /* 0x406D08D8, 0xD5A2DBD9 */
  1.17679373287147100768e+02, /* 0x405D6B7A, 0xDA1884A9 */
  8.36463893371618283368e+00, /* 0x4020BAB1, 0xF44E5192 */
};

#ifdef __STDC__
    static double pone(double x)
#else
    static double pone(x)
    double x;
#endif
{
#ifdef __STDC__
    const double *p,*q;
#else
    double *p,*q;
#endif
    double z,r,s;
        int ix;
        ix = 0x7fffffff&amp;__HI(x);
        if(ix&gt;=0x40200000)     {p = pr8; q= ps8;}
        else if(ix&gt;=0x40122E8B){p = pr5; q= ps5;}
        else if(ix&gt;=0x4006DB6D){p = pr3; q= ps3;}
        else if(ix&gt;=0x40000000){p = pr2; q= ps2;}
        z = one/(x*x);
        r = p[0]+z*(p[1]+z*(p[2]+z*(p[3]+z*(p[4]+z*p[5]))));
        s = one+z*(q[0]+z*(q[1]+z*(q[2]+z*(q[3]+z*q[4]))));
        return one+ r/s;
}


/* For x &gt;= 8, the asymptotic expansions of qone is
 *  3/8 s - 105/1024 s^3 - ..., where s = 1/x.
 * We approximate pone by
 *  qone(x) = s*(0.375 + (R/S))
 * where  R = qr1*s^2 + qr2*s^4 + ... + qr5*s^10
 *    S = 1 + qs1*s^2 + ... + qs6*s^12
 * and
 *  | qone(x)/s -0.375-R/S | &lt;= 2  ** ( -61.13)
 */

#ifdef __STDC__
static const double qr8[6] = { /* for x in [inf, 8]=1/[0,0.125] */
#else
static double qr8[6] = { /* for x in [inf, 8]=1/[0,0.125] */
#endif
  0.00000000000000000000e+00, /* 0x00000000, 0x00000000 */
 -1.02539062499992714161e-01, /* 0xBFBA3FFF, 0xFFFFFDF3 */
 -1.62717534544589987888e+01, /* 0xC0304591, 0xA26779F7 */
 -7.59601722513950107896e+02, /* 0xC087BCD0, 0x53E4B576 */
 -1.18498066702429587167e+04, /* 0xC0C724E7, 0x40F87415 */
 -4.84385124285750353010e+04, /* 0xC0E7A6D0, 0x65D09C6A */
};
#ifdef __STDC__
static const double qs8[6] = {
#else
static double qs8[6] = {
#endif
  1.61395369700722909556e+02, /* 0x40642CA6, 0xDE5BCDE5 */
  7.82538599923348465381e+03, /* 0x40BE9162, 0xD0D88419 */
  1.33875336287249578163e+05, /* 0x4100579A, 0xB0B75E98 */
  7.19657723683240939863e+05, /* 0x4125F653, 0x72869C19 */
  6.66601232617776375264e+05, /* 0x412457D2, 0x7719AD5C */
 -2.94490264303834643215e+05, /* 0xC111F969, 0x0EA5AA18 */
};

#ifdef __STDC__
static const double qr5[6] = { /* for x in [8,4.5454]=1/[0.125,0.22001] */
#else
static double qr5[6] = { /* for x in [8,4.5454]=1/[0.125,0.22001] */
#endif
 -2.08979931141764104297e-11, /* 0xBDB6FA43, 0x1AA1A098 */
 -1.02539050241375426231e-01, /* 0xBFBA3FFF, 0xCB597FEF */
 -8.05644828123936029840e+00, /* 0xC0201CE6, 0xCA03AD4B */
 -1.83669607474888380239e+02, /* 0xC066F56D, 0x6CA7B9B0 */
 -1.37319376065508163265e+03, /* 0xC09574C6, 0x6931734F */
 -2.61244440453215656817e+03, /* 0xC0A468E3, 0x88FDA79D */
};
#ifdef __STDC__
static const double qs5[6] = {
#else
static double qs5[6] = {
#endif
  8.12765501384335777857e+01, /* 0x405451B2, 0xFF5A11B2 */
  1.99179873460485964642e+03, /* 0x409F1F31, 0xE77BF839 */
  1.74684851924908907677e+04, /* 0x40D10F1F, 0x0D64CE29 */
  4.98514270910352279316e+04, /* 0x40E8576D, 0xAABAD197 */
  2.79480751638918118260e+04, /* 0x40DB4B04, 0xCF7C364B */
 -4.71918354795128470869e+03, /* 0xC0B26F2E, 0xFCFFA004 */
};

#ifdef __STDC__
static const double qr3[6] = {
#else
static double qr3[6] = {/* for x in [4.547,2.8571]=1/[0.2199,0.35001] */
#endif
 -5.07831226461766561369e-09, /* 0xBE35CFA9, 0xD38FC84F */
 -1.02537829820837089745e-01, /* 0xBFBA3FEB, 0x51AEED54 */
 -4.61011581139473403113e+00, /* 0xC01270C2, 0x3302D9FF */
 -5.78472216562783643212e+01, /* 0xC04CEC71, 0xC25D16DA */
 -2.28244540737631695038e+02, /* 0xC06C87D3, 0x4718D55F */
 -2.19210128478909325622e+02, /* 0xC06B66B9, 0x5F5C1BF6 */
};
#ifdef __STDC__
static const double qs3[6] = {
#else
static double qs3[6] = {
#endif
  4.76651550323729509273e+01, /* 0x4047D523, 0xCCD367E4 */
  6.73865112676699709482e+02, /* 0x40850EEB, 0xC031EE3E */
  3.38015286679526343505e+03, /* 0x40AA684E, 0x448E7C9A */
  5.54772909720722782367e+03, /* 0x40B5ABBA, 0xA61D54A6 */
  1.90311919338810798763e+03, /* 0x409DBC7A, 0x0DD4DF4B */
 -1.35201191444307340817e+02, /* 0xC060E670, 0x290A311F */
};

#ifdef __STDC__
static const double qr2[6] = {/* for x in [2.8570,2]=1/[0.3499,0.5] */
#else
static double qr2[6] = {/* for x in [2.8570,2]=1/[0.3499,0.5] */
#endif
 -1.78381727510958865572e-07, /* 0xBE87F126, 0x44C626D2 */
 -1.02517042607985553460e-01, /* 0xBFBA3E8E, 0x9148B010 */
 -2.75220568278187460720e+00, /* 0xC0060484, 0x69BB4EDA */
 -1.96636162643703720221e+01, /* 0xC033A9E2, 0xC168907F */
 -4.23253133372830490089e+01, /* 0xC04529A3, 0xDE104AAA */
 -2.13719211703704061733e+01, /* 0xC0355F36, 0x39CF6E52 */
};
#ifdef __STDC__
static const double qs2[6] = {
#else
static double qs2[6] = {
#endif
  2.95333629060523854548e+01, /* 0x403D888A, 0x78AE64FF */
  2.52981549982190529136e+02, /* 0x406F9F68, 0xDB821CBA */
  7.57502834868645436472e+02, /* 0x4087AC05, 0xCE49A0F7 */
  7.39393205320467245656e+02, /* 0x40871B25, 0x48D4C029 */
  1.55949003336666123687e+02, /* 0x40637E5E, 0x3C3ED8D4 */
 -4.95949898822628210127e+00, /* 0xC013D686, 0xE71BE86B */
};

#ifdef __STDC__
    static double qone(double x)
#else
    static double qone(x)
    double x;
#endif
{
#ifdef __STDC__
    const double *p,*q;
#else
    double *p,*q;
#endif
    double  s,r,z;
    int ix;
    ix = 0x7fffffff&amp;__HI(x);
    if(ix&gt;=0x40200000)     {p = qr8; q= qs8;}
    else if(ix&gt;=0x40122E8B){p = qr5; q= qs5;}
    else if(ix&gt;=0x4006DB6D){p = qr3; q= qs3;}
    else if(ix&gt;=0x40000000){p = qr2; q= qs2;}
    z = one/(x*x);
    r = p[0]+z*(p[1]+z*(p[2]+z*(p[3]+z*(p[4]+z*p[5]))));
    s = one+z*(q[0]+z*(q[1]+z*(q[2]+z*(q[3]+z*(q[4]+z*q[5])))));
    return (.375 + r/s)/x;
}
</code></pre>

<ul>
<li><strong><code>e_jn.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/*
 * __ieee754_jn(n, x), __ieee754_yn(n, x)
 * floating point Bessel's function of the 1st and 2nd kind
 * of order n
 *          
 * Special cases:
 *  y0(0)=y1(0)=yn(n,0) = -inf with division by zero signal;
 *  y0(-ve)=y1(-ve)=yn(n,-ve) are NaN with invalid signal.
 * Note 2. About jn(n,x), yn(n,x)
 *  For n=0, j0(x) is called,
 *  for n=1, j1(x) is called,
 *  for n&lt;x, forward recursion us used starting
 *  from values of j0(x) and j1(x).
 *  for n&gt;x, a continued fraction approximation to
 *  j(n,x)/j(n-1,x) is evaluated and then backward
 *  recursion is used starting from a supposed value
 *  for j(n,x). The resulting value of j(0,x) is
 *  compared with the actual value to correct the
 *  supposed value of j(n,x).
 *
 *  yn(n,x) is similar in all respects, except
 *  that forward recursion is used for all
 *  values of n&gt;1.
 *  
 */

#include &quot;fdlibm.h&quot;

#ifdef __STDC__
static const double
#else
static double
#endif
invsqrtpi=  5.64189583547756279280e-01, /* 0x3FE20DD7, 0x50429B6D */
two   =  2.00000000000000000000e+00, /* 0x40000000, 0x00000000 */
one   =  1.00000000000000000000e+00; /* 0x3FF00000, 0x00000000 */

static double zero  =  0.00000000000000000000e+00;

#ifdef __STDC__
    double __ieee754_jn(int n, double x)
#else
    double __ieee754_jn(n,x)
    int n; double x;
#endif
{
    int i,hx,ix,lx, sgn;
    double a, b, temp, di;
    double z, w;

    /* J(-n,x) = (-1)^n * J(n, x), J(n, -x) = (-1)^n * J(n, x)
     * Thus, J(-n,x) = J(n,-x)
     */
    hx = __HI(x);
    ix = 0x7fffffff&amp;hx;
    lx = __LO(x);
    /* if J(n,NaN) is NaN */
    if((ix|((unsigned)(lx|-lx))&gt;&gt;31)&gt;0x7ff00000) return x+x;
    if(n&lt;0){        
        n = -n;
        x = -x;
        hx ^= 0x80000000;
    }
    if(n==0) return(__ieee754_j0(x));
    if(n==1) return(__ieee754_j1(x));
    sgn = (n&amp;1)&amp;(hx&gt;&gt;31);   /* even n -- 0, odd n -- sign(x) */
    x = fabs(x);
    if((ix|lx)==0||ix&gt;=0x7ff00000)  /* if x is 0 or inf */
        b = zero;
    else if((double)n&lt;=x) {   
        /* Safe to use J(n+1,x)=2n/x *J(n,x)-J(n-1,x) */
        if(ix&gt;=0x52D00000) { /* x &gt; 2**302 */
    /* (x &gt;&gt; n**2) 
     *      Jn(x) = cos(x-(2n+1)*pi/4)*sqrt(2/x*pi)
     *      Yn(x) = sin(x-(2n+1)*pi/4)*sqrt(2/x*pi)
     *      Let s=sin(x), c=cos(x), 
     *      xn=x-(2n+1)*pi/4, sqt2 = sqrt(2),then
     *
     *         n    sin(xn)*sqt2    cos(xn)*sqt2
     *      ----------------------------------
     *         0     s-c         c+s
     *         1    -s-c        -c+s
     *         2    -s+c        -c-s
     *         3     s+c         c-s
     */
        switch(n&amp;3) {
            case 0: temp =  cos(x)+sin(x); break;
            case 1: temp = -cos(x)+sin(x); break;
            case 2: temp = -cos(x)-sin(x); break;
            case 3: temp =  cos(x)-sin(x); break;
        }
        b = invsqrtpi*temp/sqrt(x);
        } else {    
            a = __ieee754_j0(x);
            b = __ieee754_j1(x);
            for(i=1;i&lt;n;i++){
            temp = b;
            b = b*((double)(i+i)/x) - a; /* avoid underflow */
            a = temp;
            }
        }
    } else {
        if(ix&lt;0x3e100000) { /* x &lt; 2**-29 */
    /* x is tiny, return the first Taylor expansion of J(n,x) 
     * J(n,x) = 1/n!*(x/2)^n  - ...
     */
        if(n&gt;33)    /* underflow */
            b = zero;
        else {
            temp = x*0.5; b = temp;
            for (a=one,i=2;i&lt;=n;i++) {
            a *= (double)i;     /* a = n! */
            b *= temp;      /* b = (x/2)^n */
            }
            b = b/a;
        }
        } else {
        /* use backward recurrence */
        /*          x      x^2      x^2       
         *  J(n,x)/J(n-1,x) =  ----   ------   ------   .....
         *          2n  - 2(n+1) - 2(n+2)
         *
         *          1      1        1       
         *  (for large x)   =  ----  ------   ------   .....
         *          2n   2(n+1)   2(n+2)
         *          -- - ------ - ------ - 
         *           x     x         x
         *
         * Let w = 2n/x and h=2/x, then the above quotient
         * is equal to the continued fraction:
         *          1
         *  = -----------------------
         *             1
         *     w - -----------------
         *            1
         *          w+h - ---------
         *             w+2h - ...
         *
         * To determine how many terms needed, let
         * Q(0) = w, Q(1) = w(w+h) - 1,
         * Q(k) = (w+k*h)*Q(k-1) - Q(k-2),
         * When Q(k) &gt; 1e4  good for single 
         * When Q(k) &gt; 1e9  good for double 
         * When Q(k) &gt; 1e17 good for quadruple 
         */
        /* determine k */
        double t,v;
        double q0,q1,h,tmp; int k,m;
        w  = (n+n)/(double)x; h = 2.0/(double)x;
        q0 = w;  z = w+h; q1 = w*z - 1.0; k=1;
        while(q1&lt;1.0e9) {
            k += 1; z += h;
            tmp = z*q1 - q0;
            q0 = q1;
            q1 = tmp;
        }
        m = n+n;
        for(t=zero, i = 2*(n+k); i&gt;=m; i -= 2) t = one/(i/x-t);
        a = t;
        b = one;
        /*  estimate log((2/x)^n*n!) = n*log(2/x)+n*ln(n)
         *  Hence, if n*(log(2n/x)) &gt; ...
         *  single 8.8722839355e+01
         *  double 7.09782712893383973096e+02
         *  long double 1.1356523406294143949491931077970765006170e+04
         *  then recurrent value may overflow and the result is 
         *  likely underflow to zero
         */
        tmp = n;
        v = two/x;
        tmp = tmp*__ieee754_log(fabs(v*tmp));
        if(tmp&lt;7.09782712893383973096e+02) {
                for(i=n-1,di=(double)(i+i);i&gt;0;i--){
                temp = b;
            b *= di;
            b  = b/x - a;
                a = temp;
            di -= two;
                }
        } else {
                for(i=n-1,di=(double)(i+i);i&gt;0;i--){
                temp = b;
            b *= di;
            b  = b/x - a;
                a = temp;
            di -= two;
            /* scale b to avoid spurious overflow */
            if(b&gt;1e100) {
                a /= b;
                t /= b;
                b  = one;
            }
                }
        }
            b = (t*__ieee754_j0(x)/b);
        }
    }
    if(sgn==1) return -b; else return b;
}

#ifdef __STDC__
    double __ieee754_yn(int n, double x) 
#else
    double __ieee754_yn(n,x) 
    int n; double x;
#endif
{
    int i,hx,ix,lx;
    int sign;
    double a, b, temp;

    hx = __HI(x);
    ix = 0x7fffffff&amp;hx;
    lx = __LO(x);
    /* if Y(n,NaN) is NaN */
    if((ix|((unsigned)(lx|-lx))&gt;&gt;31)&gt;0x7ff00000) return x+x;
    if((ix|lx)==0) return -one/zero;
    if(hx&lt;0) return zero/zero;
    sign = 1;
    if(n&lt;0){
        n = -n;
        sign = 1 - ((n&amp;1)&lt;&lt;1);
    }
    if(n==0) return(__ieee754_y0(x));
    if(n==1) return(sign*__ieee754_y1(x));
    if(ix==0x7ff00000) return zero;
    if(ix&gt;=0x52D00000) { /* x &gt; 2**302 */
    /* (x &gt;&gt; n**2) 
     *      Jn(x) = cos(x-(2n+1)*pi/4)*sqrt(2/x*pi)
     *      Yn(x) = sin(x-(2n+1)*pi/4)*sqrt(2/x*pi)
     *      Let s=sin(x), c=cos(x), 
     *      xn=x-(2n+1)*pi/4, sqt2 = sqrt(2),then
     *
     *         n    sin(xn)*sqt2    cos(xn)*sqt2
     *      ----------------------------------
     *         0     s-c         c+s
     *         1    -s-c        -c+s
     *         2    -s+c        -c-s
     *         3     s+c         c-s
     */
        switch(n&amp;3) {
            case 0: temp =  sin(x)-cos(x); break;
            case 1: temp = -sin(x)-cos(x); break;
            case 2: temp = -sin(x)+cos(x); break;
            case 3: temp =  sin(x)+cos(x); break;
        }
        b = invsqrtpi*temp/sqrt(x);
    } else {
        a = __ieee754_y0(x);
        b = __ieee754_y1(x);
    /* quit if b is -inf */
        for(i=1;i&lt;n&amp;&amp;(__HI(b) != 0xfff00000);i++){ 
        temp = b;
        b = ((double)(i+i)/x)*b - a;
        a = temp;
        }
    }
    if(sign&gt;0) return b; else return -b;
}
</code></pre>

<ul>
<li><strong><code>e_lgamma.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/* __ieee754_lgamma(x)
 * Return the logarithm of the Gamma function of x.
 *
 * Method: call __ieee754_lgamma_r
 */

#include &quot;fdlibm.h&quot;

extern int signgam;

#ifdef __STDC__
    double __ieee754_lgamma(double x)
#else
    double __ieee754_lgamma(x)
    double x;
#endif
{
    return __ieee754_lgamma_r(x,&amp;signgam);
}
</code></pre>

<ul>
<li><strong><code>e_lgamma_r.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/* __ieee754_lgamma_r(x, signgamp)
 * Reentrant version of the logarithm of the Gamma function 
 * with user provide pointer for the sign of Gamma(x). 
 *
 * Method:
 *   1. Argument Reduction for 0 &lt; x &lt;= 8
 *  Since gamma(1+s)=s*gamma(s), for x in [0,8], we may 
 *  reduce x to a number in [1.5,2.5] by
 *      lgamma(1+s) = log(s) + lgamma(s)
 *  for example,
 *      lgamma(7.3) = log(6.3) + lgamma(6.3)
 *              = log(6.3*5.3) + lgamma(5.3)
 *              = log(6.3*5.3*4.3*3.3*2.3) + lgamma(2.3)
 *   2. Polynomial approximation of lgamma around its
 *  minimun ymin=1.461632144968362245 to maintain monotonicity.
 *  On [ymin-0.23, ymin+0.27] (i.e., [1.23164,1.73163]), use
 *      Let z = x-ymin;
 *      lgamma(x) = -1.214862905358496078218 + z^2*poly(z)
 *  where
 *      poly(z) is a 14 degree polynomial.
 *   2. Rational approximation in the primary interval [2,3]
 *  We use the following approximation:
 *      s = x-2.0;
 *      lgamma(x) = 0.5*s + s*P(s)/Q(s)
 *  with accuracy
 *      |P/Q - (lgamma(x)-0.5s)| &lt; 2**-61.71
 *  Our algorithms are based on the following observation
 *
 *                             zeta(2)-1    2    zeta(3)-1    3
 * lgamma(2+s) = s*(1-Euler) + --------- * s  -  --------- * s  + ...
 *                                 2                 3
 *
 *  where Euler = 0.5771... is the Euler constant, which is very
 *  close to 0.5.
 *
 *   3. For x&gt;=8, we have
 *  lgamma(x)~(x-0.5)log(x)-x+0.5*log(2pi)+1/(12x)-1/(360x**3)+....
 *  (better formula:
 *     lgamma(x)~(x-0.5)*(log(x)-1)-.5*(log(2pi)-1) + ...)
 *  Let z = 1/x, then we approximation
 *      f(z) = lgamma(x) - (x-0.5)(log(x)-1)
 *  by
 *                  3       5             11
 *      w = w0 + w1*z + w2*z  + w3*z  + ... + w6*z
 *  where 
 *      |w - f(z)| &lt; 2**-58.74
 *      
 *   4. For negative x, since (G is gamma function)
 *      -x*G(-x)*G(x) = pi/sin(pi*x),
 *  we have
 *      G(x) = pi/(sin(pi*x)*(-x)*G(-x))
 *  since G(-x) is positive, sign(G(x)) = sign(sin(pi*x)) for x&lt;0
 *  Hence, for x&lt;0, signgam = sign(sin(pi*x)) and 
 *      lgamma(x) = log(|Gamma(x)|)
 *            = log(pi/(|x*sin(pi*x)|)) - lgamma(-x);
 *  Note: one should avoid compute pi*(-x) directly in the 
 *        computation of sin(pi*(-x)).
 *      
 *   5. Special Cases
 *      lgamma(2+s) ~ s*(1-Euler) for tiny s
 *      lgamma(1)=lgamma(2)=0
 *      lgamma(x) ~ -log(x) for tiny x
 *      lgamma(0) = lgamma(inf) = inf
 *      lgamma(-integer) = +-inf
 *  
 */

#include &quot;fdlibm.h&quot;

#ifdef __STDC__
static const double 
#else
static double 
#endif
two52=  4.50359962737049600000e+15, /* 0x43300000, 0x00000000 */
half=  5.00000000000000000000e-01, /* 0x3FE00000, 0x00000000 */
one =  1.00000000000000000000e+00, /* 0x3FF00000, 0x00000000 */
pi  =  3.14159265358979311600e+00, /* 0x400921FB, 0x54442D18 */
a0  =  7.72156649015328655494e-02, /* 0x3FB3C467, 0xE37DB0C8 */
a1  =  3.22467033424113591611e-01, /* 0x3FD4A34C, 0xC4A60FAD */
a2  =  6.73523010531292681824e-02, /* 0x3FB13E00, 0x1A5562A7 */
a3  =  2.05808084325167332806e-02, /* 0x3F951322, 0xAC92547B */
a4  =  7.38555086081402883957e-03, /* 0x3F7E404F, 0xB68FEFE8 */
a5  =  2.89051383673415629091e-03, /* 0x3F67ADD8, 0xCCB7926B */
a6  =  1.19270763183362067845e-03, /* 0x3F538A94, 0x116F3F5D */
a7  =  5.10069792153511336608e-04, /* 0x3F40B6C6, 0x89B99C00 */
a8  =  2.20862790713908385557e-04, /* 0x3F2CF2EC, 0xED10E54D */
a9  =  1.08011567247583939954e-04, /* 0x3F1C5088, 0x987DFB07 */
a10 =  2.52144565451257326939e-05, /* 0x3EFA7074, 0x428CFA52 */
a11 =  4.48640949618915160150e-05, /* 0x3F07858E, 0x90A45837 */
tc  =  1.46163214496836224576e+00, /* 0x3FF762D8, 0x6356BE3F */
tf  = -1.21486290535849611461e-01, /* 0xBFBF19B9, 0xBCC38A42 */
/* tt = -(tail of tf) */
tt  = -3.63867699703950536541e-18, /* 0xBC50C7CA, 0xA48A971F */
t0  =  4.83836122723810047042e-01, /* 0x3FDEF72B, 0xC8EE38A2 */
t1  = -1.47587722994593911752e-01, /* 0xBFC2E427, 0x8DC6C509 */
t2  =  6.46249402391333854778e-02, /* 0x3FB08B42, 0x94D5419B */
t3  = -3.27885410759859649565e-02, /* 0xBFA0C9A8, 0xDF35B713 */
t4  =  1.79706750811820387126e-02, /* 0x3F9266E7, 0x970AF9EC */
t5  = -1.03142241298341437450e-02, /* 0xBF851F9F, 0xBA91EC6A */
t6  =  6.10053870246291332635e-03, /* 0x3F78FCE0, 0xE370E344 */
t7  = -3.68452016781138256760e-03, /* 0xBF6E2EFF, 0xB3E914D7 */
t8  =  2.25964780900612472250e-03, /* 0x3F6282D3, 0x2E15C915 */
t9  = -1.40346469989232843813e-03, /* 0xBF56FE8E, 0xBF2D1AF1 */
t10 =  8.81081882437654011382e-04, /* 0x3F4CDF0C, 0xEF61A8E9 */
t11 = -5.38595305356740546715e-04, /* 0xBF41A610, 0x9C73E0EC */
t12 =  3.15632070903625950361e-04, /* 0x3F34AF6D, 0x6C0EBBF7 */
t13 = -3.12754168375120860518e-04, /* 0xBF347F24, 0xECC38C38 */
t14 =  3.35529192635519073543e-04, /* 0x3F35FD3E, 0xE8C2D3F4 */
u0  = -7.72156649015328655494e-02, /* 0xBFB3C467, 0xE37DB0C8 */
u1  =  6.32827064025093366517e-01, /* 0x3FE4401E, 0x8B005DFF */
u2  =  1.45492250137234768737e+00, /* 0x3FF7475C, 0xD119BD6F */
u3  =  9.77717527963372745603e-01, /* 0x3FEF4976, 0x44EA8450 */
u4  =  2.28963728064692451092e-01, /* 0x3FCD4EAE, 0xF6010924 */
u5  =  1.33810918536787660377e-02, /* 0x3F8B678B, 0xBF2BAB09 */
v1  =  2.45597793713041134822e+00, /* 0x4003A5D7, 0xC2BD619C */
v2  =  2.12848976379893395361e+00, /* 0x40010725, 0xA42B18F5 */
v3  =  7.69285150456672783825e-01, /* 0x3FE89DFB, 0xE45050AF */
v4  =  1.04222645593369134254e-01, /* 0x3FBAAE55, 0xD6537C88 */
v5  =  3.21709242282423911810e-03, /* 0x3F6A5ABB, 0x57D0CF61 */
s0  = -7.72156649015328655494e-02, /* 0xBFB3C467, 0xE37DB0C8 */
s1  =  2.14982415960608852501e-01, /* 0x3FCB848B, 0x36E20878 */
s2  =  3.25778796408930981787e-01, /* 0x3FD4D98F, 0x4F139F59 */
s3  =  1.46350472652464452805e-01, /* 0x3FC2BB9C, 0xBEE5F2F7 */
s4  =  2.66422703033638609560e-02, /* 0x3F9B481C, 0x7E939961 */
s5  =  1.84028451407337715652e-03, /* 0x3F5E26B6, 0x7368F239 */
s6  =  3.19475326584100867617e-05, /* 0x3F00BFEC, 0xDD17E945 */
r1  =  1.39200533467621045958e+00, /* 0x3FF645A7, 0x62C4AB74 */
r2  =  7.21935547567138069525e-01, /* 0x3FE71A18, 0x93D3DCDC */
r3  =  1.71933865632803078993e-01, /* 0x3FC601ED, 0xCCFBDF27 */
r4  =  1.86459191715652901344e-02, /* 0x3F9317EA, 0x742ED475 */
r5  =  7.77942496381893596434e-04, /* 0x3F497DDA, 0xCA41A95B */
r6  =  7.32668430744625636189e-06, /* 0x3EDEBAF7, 0xA5B38140 */
w0  =  4.18938533204672725052e-01, /* 0x3FDACFE3, 0x90C97D69 */
w1  =  8.33333333333329678849e-02, /* 0x3FB55555, 0x5555553B */
w2  = -2.77777777728775536470e-03, /* 0xBF66C16C, 0x16B02E5C */
w3  =  7.93650558643019558500e-04, /* 0x3F4A019F, 0x98CF38B6 */
w4  = -5.95187557450339963135e-04, /* 0xBF4380CB, 0x8C0FE741 */
w5  =  8.36339918996282139126e-04, /* 0x3F4B67BA, 0x4CDAD5D1 */
w6  = -1.63092934096575273989e-03; /* 0xBF5AB89D, 0x0B9E43E4 */

static double zero=  0.00000000000000000000e+00;

#ifdef __STDC__
    static double sin_pi(double x)
#else
    static double sin_pi(x)
    double x;
#endif
{
    double y,z;
    int n,ix;

    ix = 0x7fffffff&amp;__HI(x);

    if(ix&lt;0x3fd00000) return __kernel_sin(pi*x,zero,0);
    y = -x;     /* x is assume negative */

    /*
     * argument reduction, make sure inexact flag not raised if input
     * is an integer
     */
    z = floor(y);
    if(z!=y) {              /* inexact anyway */
        y  *= 0.5;
        y   = 2.0*(y - floor(y));       /* y = |x| mod 2.0 */
        n   = (int) (y*4.0);
    } else {
            if(ix&gt;=0x43400000) {
                y = zero; n = 0;                 /* y must be even */
            } else {
                if(ix&lt;0x43300000) z = y+two52;  /* exact */
                n   = __LO(z)&amp;1;        /* lower word of z */
                y  = n;
                n&lt;&lt;= 2;
            }
        }
    switch (n) {
        case 0:   y =  __kernel_sin(pi*y,zero,0); break;
        case 1:   
        case 2:   y =  __kernel_cos(pi*(0.5-y),zero); break;
        case 3:  
        case 4:   y =  __kernel_sin(pi*(one-y),zero,0); break;
        case 5:
        case 6:   y = -__kernel_cos(pi*(y-1.5),zero); break;
        default:  y =  __kernel_sin(pi*(y-2.0),zero,0); break;
        }
    return -y;
}


#ifdef __STDC__
    double __ieee754_lgamma_r(double x, int *signgamp)
#else
    double __ieee754_lgamma_r(x,signgamp)
    double x; int *signgamp;
#endif
{
    double t,y,z,nadj,p,p1,p2,p3,q,r,w;
    int i,hx,lx,ix;

    hx = __HI(x);
    lx = __LO(x);

    /* purge off +-inf, NaN, +-0, and negative arguments */
    *signgamp = 1;
    ix = hx&amp;0x7fffffff;
    if(ix&gt;=0x7ff00000) return x*x;
    if((ix|lx)==0) return one/zero;
    if(ix&lt;0x3b900000) { /* |x|&lt;2**-70, return -log(|x|) */
        if(hx&lt;0) {
            *signgamp = -1;
            return -__ieee754_log(-x);
        } else return -__ieee754_log(x);
    }
    if(hx&lt;0) {
        if(ix&gt;=0x43300000)  /* |x|&gt;=2**52, must be -integer */
        return one/zero;
        t = sin_pi(x);
        if(t==zero) return one/zero; /* -integer */
        nadj = __ieee754_log(pi/fabs(t*x));
        if(t&lt;zero) *signgamp = -1;
        x = -x;
    }

    /* purge off 1 and 2 */
    if((((ix-0x3ff00000)|lx)==0)||(((ix-0x40000000)|lx)==0)) r = 0;
    /* for x &lt; 2.0 */
    else if(ix&lt;0x40000000) {
        if(ix&lt;=0x3feccccc) {    /* lgamma(x) = lgamma(x+1)-log(x) */
        r = -__ieee754_log(x);
        if(ix&gt;=0x3FE76944) {y = one-x; i= 0;}
        else if(ix&gt;=0x3FCDA661) {y= x-(tc-one); i=1;}
        else {y = x; i=2;}
        } else {
        r = zero;
            if(ix&gt;=0x3FFBB4C3) {y=2.0-x;i=0;} /* [1.7316,2] */
            else if(ix&gt;=0x3FF3B4C4) {y=x-tc;i=1;} /* [1.23,1.73] */
        else {y=x-one;i=2;}
        }
        switch(i) {
          case 0:
        z = y*y;
        p1 = a0+z*(a2+z*(a4+z*(a6+z*(a8+z*a10))));
        p2 = z*(a1+z*(a3+z*(a5+z*(a7+z*(a9+z*a11)))));
        p  = y*p1+p2;
        r  += (p-0.5*y); break;
          case 1:
        z = y*y;
        w = z*y;
        p1 = t0+w*(t3+w*(t6+w*(t9 +w*t12)));    /* parallel comp */
        p2 = t1+w*(t4+w*(t7+w*(t10+w*t13)));
        p3 = t2+w*(t5+w*(t8+w*(t11+w*t14)));
        p  = z*p1-(tt-w*(p2+y*p3));
        r += (tf + p); break;
          case 2:   
        p1 = y*(u0+y*(u1+y*(u2+y*(u3+y*(u4+y*u5)))));
        p2 = one+y*(v1+y*(v2+y*(v3+y*(v4+y*v5))));
        r += (-0.5*y + p1/p2);
        }
    }
    else if(ix&lt;0x40200000) {            /* x &lt; 8.0 */
        i = (int)x;
        t = zero;
        y = x-(double)i;
        p = y*(s0+y*(s1+y*(s2+y*(s3+y*(s4+y*(s5+y*s6))))));
        q = one+y*(r1+y*(r2+y*(r3+y*(r4+y*(r5+y*r6)))));
        r = half*y+p/q;
        z = one;    /* lgamma(1+s) = log(s) + lgamma(s) */
        switch(i) {
        case 7: z *= (y+6.0);   /* FALLTHRU */
        case 6: z *= (y+5.0);   /* FALLTHRU */
        case 5: z *= (y+4.0);   /* FALLTHRU */
        case 4: z *= (y+3.0);   /* FALLTHRU */
        case 3: z *= (y+2.0);   /* FALLTHRU */
            r += __ieee754_log(z); break;
        }
    /* 8.0 &lt;= x &lt; 2**58 */
    } else if (ix &lt; 0x43900000) {
        t = __ieee754_log(x);
        z = one/x;
        y = z*z;
        w = w0+z*(w1+y*(w2+y*(w3+y*(w4+y*(w5+y*w6)))));
        r = (x-half)*(t-one)+w;
    } else 
    /* 2**58 &lt;= x &lt;= inf */
        r =  x*(__ieee754_log(x)-one);
    if(hx&lt;0) r = nadj - r;
    return r;
}
</code></pre>

<ul>
<li><strong><code>e_log.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/* __ieee754_log(x)
 * Return the logrithm of x
 *
 * Method :                  
 *   1. Argument Reduction: find k and f such that 
 *          x = 2^k * (1+f), 
 *     where  sqrt(2)/2 &lt; 1+f &lt; sqrt(2) .
 *
 *   2. Approximation of log(1+f).
 *  Let s = f/(2+f) ; based on log(1+f) = log(1+s) - log(1-s)
 *       = 2s + 2/3 s**3 + 2/5 s**5 + .....,
 *           = 2s + s*R
 *      We use a special Reme algorithm on [0,0.1716] to generate 
 *  a polynomial of degree 14 to approximate R The maximum error 
 *  of this polynomial approximation is bounded by 2**-58.45. In
 *  other words,
 *              2      4      6      8      10      12      14
 *      R(z) ~ Lg1*s +Lg2*s +Lg3*s +Lg4*s +Lg5*s  +Lg6*s  +Lg7*s
 *      (the values of Lg1 to Lg7 are listed in the program)
 *  and
 *      |      2          14          |     -58.45
 *      | Lg1*s +...+Lg7*s    -  R(z) | &lt;= 2 
 *      |                             |
 *  Note that 2s = f - s*f = f - hfsq + s*hfsq, where hfsq = f*f/2.
 *  In order to guarantee error in log below 1ulp, we compute log
 *  by
 *      log(1+f) = f - s*(f - R)    (if f is not too large)
 *      log(1+f) = f - (hfsq - s*(hfsq+R)). (better accuracy)
 *  
 *  3. Finally,  log(x) = k*ln2 + log(1+f).  
 *              = k*ln2_hi+(f-(hfsq-(s*(hfsq+R)+k*ln2_lo)))
 *     Here ln2 is split into two floating point number: 
 *          ln2_hi + ln2_lo,
 *     where n*ln2_hi is always exact for |n| &lt; 2000.
 *
 * Special cases:
 *  log(x) is NaN with signal if x &lt; 0 (including -INF) ; 
 *  log(+INF) is +INF; log(0) is -INF with signal;
 *  log(NaN) is that NaN with no signal.
 *
 * Accuracy:
 *  according to an error analysis, the error is always less than
 *  1 ulp (unit in the last place).
 *
 * Constants:
 * The hexadecimal values are the intended ones for the following 
 * constants. The decimal values may be used, provided that the 
 * compiler will convert from decimal to binary accurately enough 
 * to produce the hexadecimal values shown.
 */

#include &quot;fdlibm.h&quot;

#ifdef __STDC__
static const double
#else
static double
#endif
ln2_hi  =  6.93147180369123816490e-01,  /* 3fe62e42 fee00000 */
ln2_lo  =  1.90821492927058770002e-10,  /* 3dea39ef 35793c76 */
two54   =  1.80143985094819840000e+16,  /* 43500000 00000000 */
Lg1 = 6.666666666666735130e-01,  /* 3FE55555 55555593 */
Lg2 = 3.999999999940941908e-01,  /* 3FD99999 9997FA04 */
Lg3 = 2.857142874366239149e-01,  /* 3FD24924 94229359 */
Lg4 = 2.222219843214978396e-01,  /* 3FCC71C5 1D8E78AF */
Lg5 = 1.818357216161805012e-01,  /* 3FC74664 96CB03DE */
Lg6 = 1.531383769920937332e-01,  /* 3FC39A09 D078C69F */
Lg7 = 1.479819860511658591e-01;  /* 3FC2F112 DF3E5244 */

static double zero   =  0.0;

#ifdef __STDC__
    double __ieee754_log(double x)
#else
    double __ieee754_log(x)
    double x;
#endif
{
    double hfsq,f,s,z,R,w,t1,t2,dk;
    int k,hx,i,j;
    unsigned lx;

    hx = __HI(x);       /* high word of x */
    lx = __LO(x);       /* low  word of x */

    k=0;
    if (hx &lt; 0x00100000) {          /* x &lt; 2**-1022  */
        if (((hx&amp;0x7fffffff)|lx)==0) 
        return -two54/zero;     /* log(+-0)=-inf */
        if (hx&lt;0) return (x-x)/zero;    /* log(-#) = NaN */
        k -= 54; x *= two54; /* subnormal number, scale up x */
        hx = __HI(x);       /* high word of x */
    } 
    if (hx &gt;= 0x7ff00000) return x+x;
    k += (hx&gt;&gt;20)-1023;
    hx &amp;= 0x000fffff;
    i = (hx+0x95f64)&amp;0x100000;
    __HI(x) = hx|(i^0x3ff00000);    /* normalize x or x/2 */
    k += (i&gt;&gt;20);
    f = x-1.0;
    if((0x000fffff&amp;(2+hx))&lt;3) { /* |f| &lt; 2**-20 */
        if(f==zero) if(k==0) return zero;  else {dk=(double)k;
                 return dk*ln2_hi+dk*ln2_lo;}
        R = f*f*(0.5-0.33333333333333333*f);
        if(k==0) return f-R; else {dk=(double)k;
                 return dk*ln2_hi-((R-dk*ln2_lo)-f);}
    }
    s = f/(2.0+f); 
    dk = (double)k;
    z = s*s;
    i = hx-0x6147a;
    w = z*z;
    j = 0x6b851-hx;
    t1= w*(Lg2+w*(Lg4+w*Lg6)); 
    t2= z*(Lg1+w*(Lg3+w*(Lg5+w*Lg7))); 
    i |= j;
    R = t2+t1;
    if(i&gt;0) {
        hfsq=0.5*f*f;
        if(k==0) return f-(hfsq-s*(hfsq+R)); else
             return dk*ln2_hi-((hfsq-(s*(hfsq+R)+dk*ln2_lo))-f);
    } else {
        if(k==0) return f-s*(f-R); else
             return dk*ln2_hi-((s*(f-R)-dk*ln2_lo)-f);
    }
}
</code></pre>

<ul>
<li><strong><code>e_log10.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/* __ieee754_log10(x)
 * Return the base 10 logarithm of x
 * 
 * Method :
 *  Let log10_2hi = leading 40 bits of log10(2) and
 *      log10_2lo = log10(2) - log10_2hi,
 *      ivln10   = 1/log(10) rounded.
 *  Then
 *      n = ilogb(x), 
 *      if(n&lt;0)  n = n+1;
 *      x = scalbn(x,-n);
 *      log10(x) := n*log10_2hi + (n*log10_2lo + ivln10*log(x))
 *
 * Note 1:
 *  To guarantee log10(10**n)=n, where 10**n is normal, the rounding 
 *  mode must set to Round-to-Nearest.
 * Note 2:
 *  [1/log(10)] rounded to 53 bits has error  .198   ulps;
 *  log10 is monotonic at all binary break points.
 *
 * Special cases:
 *  log10(x) is NaN with signal if x &lt; 0; 
 *  log10(+INF) is +INF with no signal; log10(0) is -INF with signal;
 *  log10(NaN) is that NaN with no signal;
 *  log10(10**N) = N  for N=0,1,...,22.
 *
 * Constants:
 * The hexadecimal values are the intended ones for the following constants.
 * The decimal values may be used, provided that the compiler will convert
 * from decimal to binary accurately enough to produce the hexadecimal values
 * shown.
 */

#include &quot;fdlibm.h&quot;

#ifdef __STDC__
static const double
#else
static double
#endif
two54      =  1.80143985094819840000e+16, /* 0x43500000, 0x00000000 */
ivln10     =  4.34294481903251816668e-01, /* 0x3FDBCB7B, 0x1526E50E */
log10_2hi  =  3.01029995663611771306e-01, /* 0x3FD34413, 0x509F6000 */
log10_2lo  =  3.69423907715893078616e-13; /* 0x3D59FEF3, 0x11F12B36 */

static double zero   =  0.0;

#ifdef __STDC__
    double __ieee754_log10(double x)
#else
    double __ieee754_log10(x)
    double x;
#endif
{
    double y,z;
    int i,k,hx;
    unsigned lx;

    hx = __HI(x);   /* high word of x */
    lx = __LO(x);   /* low word of x */

        k=0;
        if (hx &lt; 0x00100000) {                  /* x &lt; 2**-1022  */
            if (((hx&amp;0x7fffffff)|lx)==0)
                return -two54/zero;             /* log(+-0)=-inf */
            if (hx&lt;0) return (x-x)/zero;        /* log(-#) = NaN */
            k -= 54; x *= two54; /* subnormal number, scale up x */
            hx = __HI(x);                /* high word of x */
        }
    if (hx &gt;= 0x7ff00000) return x+x;
    k += (hx&gt;&gt;20)-1023;
    i  = ((unsigned)k&amp;0x80000000)&gt;&gt;31;
        hx = (hx&amp;0x000fffff)|((0x3ff-i)&lt;&lt;20);
        y  = (double)(k+i);
        __HI(x) = hx;
    z  = y*log10_2lo + ivln10*__ieee754_log(x);
    return  z+y*log10_2hi;
}
</code></pre>

<ul>
<li><strong><code>e_pow.c</code>文件</strong></li>
</ul>
<pre><code class="c++">#include &quot;fdlibm.h&quot;

#ifdef __STDC__
static const double 
#else
static double 
#endif
bp[] = {1.0, 1.5,},
dp_h[] = { 0.0, 5.84962487220764160156e-01,}, /* 0x3FE2B803, 0x40000000 */
dp_l[] = { 0.0, 1.35003920212974897128e-08,}, /* 0x3E4CFDEB, 0x43CFD006 */
zero    =  0.0,
one =  1.0,
two =  2.0,
two53   =  9007199254740992.0,  /* 0x43400000, 0x00000000 */
huge    =  1.0e300,
tiny    =  1.0e-300,
    /* poly coefs for (3/2)*(log(x)-2s-2/3*s**3 */
L1  =  5.99999999999994648725e-01, /* 0x3FE33333, 0x33333303 */
L2  =  4.28571428578550184252e-01, /* 0x3FDB6DB6, 0xDB6FABFF */
L3  =  3.33333329818377432918e-01, /* 0x3FD55555, 0x518F264D */
L4  =  2.72728123808534006489e-01, /* 0x3FD17460, 0xA91D4101 */
L5  =  2.30660745775561754067e-01, /* 0x3FCD864A, 0x93C9DB65 */
L6  =  2.06975017800338417784e-01, /* 0x3FCA7E28, 0x4A454EEF */
P1   =  1.66666666666666019037e-01, /* 0x3FC55555, 0x5555553E */
P2   = -2.77777777770155933842e-03, /* 0xBF66C16C, 0x16BEBD93 */
P3   =  6.61375632143793436117e-05, /* 0x3F11566A, 0xAF25DE2C */
P4   = -1.65339022054652515390e-06, /* 0xBEBBBD41, 0xC5D26BF1 */
P5   =  4.13813679705723846039e-08, /* 0x3E663769, 0x72BEA4D0 */
lg2  =  6.93147180559945286227e-01, /* 0x3FE62E42, 0xFEFA39EF */
lg2_h  =  6.93147182464599609375e-01, /* 0x3FE62E43, 0x00000000 */
lg2_l  = -1.90465429995776804525e-09, /* 0xBE205C61, 0x0CA86C39 */
ovt =  8.0085662595372944372e-0017, /* -(1024-log2(ovfl+.5ulp)) */
cp    =  9.61796693925975554329e-01, /* 0x3FEEC709, 0xDC3A03FD =2/(3ln2) */
cp_h  =  9.61796700954437255859e-01, /* 0x3FEEC709, 0xE0000000 =(float)cp */
cp_l  = -7.02846165095275826516e-09, /* 0xBE3E2FE0, 0x145B01F5 =tail of cp_h*/
ivln2    =  1.44269504088896338700e+00, /* 0x3FF71547, 0x652B82FE =1/ln2 */
ivln2_h  =  1.44269502162933349609e+00, /* 0x3FF71547, 0x60000000 =24b 1/ln2*/
ivln2_l  =  1.92596299112661746887e-08; /* 0x3E54AE0B, 0xF85DDF44 =1/ln2 tail*/

#ifdef __STDC__
    double __ieee754_pow(double x, double y)
#else
    double __ieee754_pow(x,y)
    double x, y;
#endif
{
    double z,ax,z_h,z_l,p_h,p_l;
    double y1,t1,t2,r,s,t,u,v,w;
    int i0,i1,i,j,k,yisint,n;
    int hx,hy,ix,iy;
    unsigned lx,ly;

    i0 = ((*(int*)&amp;one)&gt;&gt;29)^1; i1=1-i0;
    hx = __HI(x); lx = __LO(x);
    hy = __HI(y); ly = __LO(y);
    ix = hx&amp;0x7fffffff;  iy = hy&amp;0x7fffffff;

    /* y==zero: x**0 = 1 */
    if((iy|ly)==0) return one;  

    /* +-NaN return x+y */
    if(ix &gt; 0x7ff00000 || ((ix==0x7ff00000)&amp;&amp;(lx!=0)) ||
       iy &gt; 0x7ff00000 || ((iy==0x7ff00000)&amp;&amp;(ly!=0))) 
        return x+y; 

    /* determine if y is an odd int when x &lt; 0
     * yisint = 0   ... y is not an integer
     * yisint = 1   ... y is an odd int
     * yisint = 2   ... y is an even int
     */
    yisint  = 0;
    if(hx&lt;0) {  
        if(iy&gt;=0x43400000) yisint = 2; /* even integer y */
        else if(iy&gt;=0x3ff00000) {
        k = (iy&gt;&gt;20)-0x3ff;    /* exponent */
        if(k&gt;20) {
            j = ly&gt;&gt;(52-k);
            if((j&lt;&lt;(52-k))==ly) yisint = 2-(j&amp;1);
        } else if(ly==0) {
            j = iy&gt;&gt;(20-k);
            if((j&lt;&lt;(20-k))==iy) yisint = 2-(j&amp;1);
        }
        }       
    } 

    /* special value of y */
    if(ly==0) {     
        if (iy==0x7ff00000) {   /* y is +-inf */
            if(((ix-0x3ff00000)|lx)==0)
            return  y - y;  /* inf**+-1 is NaN */
            else if (ix &gt;= 0x3ff00000)/* (|x|&gt;1)**+-inf = inf,0 */
            return (hy&gt;=0)? y: zero;
            else            /* (|x|&lt;1)**-,+inf = inf,0 */
            return (hy&lt;0)?-y: zero;
        } 
        if(iy==0x3ff00000) {    /* y is  +-1 */
        if(hy&lt;0) return one/x; else return x;
        }
        if(hy==0x40000000) return x*x; /* y is  2 */
        if(hy==0x3fe00000) {    /* y is  0.5 */
        if(hx&gt;=0)   /* x &gt;= +0 */
        return sqrt(x); 
        }
    }

    ax   = fabs(x);
    /* special value of x */
    if(lx==0) {
        if(ix==0x7ff00000||ix==0||ix==0x3ff00000){
        z = ax;         /*x is +-0,+-inf,+-1*/
        if(hy&lt;0) z = one/z; /* z = (1/|x|) */
        if(hx&lt;0) {
            if(((ix-0x3ff00000)|yisint)==0) {
            z = (z-z)/(z-z); /* (-1)**non-int is NaN */
            } else if(yisint==1) 
            z = -z;     /* (x&lt;0)**odd = -(|x|**odd) */
        }
        return z;
        }
    }

    n = (hx&gt;&gt;31)+1;

    /* (x&lt;0)**(non-int) is NaN */
    if((n|yisint)==0) return (x-x)/(x-x);

    s = one; /* s (sign of result -ve**odd) = -1 else = 1 */
    if((n|(yisint-1))==0) s = -one;/* (-ve)**(odd int) */

    /* |y| is huge */
    if(iy&gt;0x41e00000) { /* if |y| &gt; 2**31 */
        if(iy&gt;0x43f00000){  /* if |y| &gt; 2**64, must o/uflow */
        if(ix&lt;=0x3fefffff) return (hy&lt;0)? huge*huge:tiny*tiny;
        if(ix&gt;=0x3ff00000) return (hy&gt;0)? huge*huge:tiny*tiny;
        }
    /* over/underflow if x is not close to one */
        if(ix&lt;0x3fefffff) return (hy&lt;0)? s*huge*huge:s*tiny*tiny;
        if(ix&gt;0x3ff00000) return (hy&gt;0)? s*huge*huge:s*tiny*tiny;
    /* now |1-x| is tiny &lt;= 2**-20, suffice to compute 
       log(x) by x-x^2/2+x^3/3-x^4/4 */
        t = ax-one;     /* t has 20 trailing zeros */
        w = (t*t)*(0.5-t*(0.3333333333333333333333-t*0.25));
        u = ivln2_h*t;  /* ivln2_h has 21 sig. bits */
        v = t*ivln2_l-w*ivln2;
        t1 = u+v;
        __LO(t1) = 0;
        t2 = v-(t1-u);
    } else {
        double ss,s2,s_h,s_l,t_h,t_l;
        n = 0;
    /* take care subnormal number */
        if(ix&lt;0x00100000)
        {ax *= two53; n -= 53; ix = __HI(ax); }
        n  += ((ix)&gt;&gt;20)-0x3ff;
        j  = ix&amp;0x000fffff;
    /* determine interval */
        ix = j|0x3ff00000;      /* normalize ix */
        if(j&lt;=0x3988E) k=0;     /* |x|&lt;sqrt(3/2) */
        else if(j&lt;0xBB67A) k=1; /* |x|&lt;sqrt(3)   */
        else {k=0;n+=1;ix -= 0x00100000;}
        __HI(ax) = ix;

    /* compute ss = s_h+s_l = (x-1)/(x+1) or (x-1.5)/(x+1.5) */
        u = ax-bp[k];       /* bp[0]=1.0, bp[1]=1.5 */
        v = one/(ax+bp[k]);
        ss = u*v;
        s_h = ss;
        __LO(s_h) = 0;
    /* t_h=ax+bp[k] High */
        t_h = zero;
        __HI(t_h)=((ix&gt;&gt;1)|0x20000000)+0x00080000+(k&lt;&lt;18); 
        t_l = ax - (t_h-bp[k]);
        s_l = v*((u-s_h*t_h)-s_h*t_l);
    /* compute log(ax) */
        s2 = ss*ss;
        r = s2*s2*(L1+s2*(L2+s2*(L3+s2*(L4+s2*(L5+s2*L6)))));
        r += s_l*(s_h+ss);
        s2  = s_h*s_h;
        t_h = 3.0+s2+r;
        __LO(t_h) = 0;
        t_l = r-((t_h-3.0)-s2);
    /* u+v = ss*(1+...) */
        u = s_h*t_h;
        v = s_l*t_h+t_l*ss;
    /* 2/(3log2)*(ss+...) */
        p_h = u+v;
        __LO(p_h) = 0;
        p_l = v-(p_h-u);
        z_h = cp_h*p_h;     /* cp_h+cp_l = 2/(3*log2) */
        z_l = cp_l*p_h+p_l*cp+dp_l[k];
    /* log2(ax) = (ss+..)*2/(3*log2) = n + dp_h + z_h + z_l */
        t = (double)n;
        t1 = (((z_h+z_l)+dp_h[k])+t);
        __LO(t1) = 0;
        t2 = z_l-(((t1-t)-dp_h[k])-z_h);
    }

    /* split up y into y1+y2 and compute (y1+y2)*(t1+t2) */
    y1  = y;
    __LO(y1) = 0;
    p_l = (y-y1)*t1+y*t2;
    p_h = y1*t1;
    z = p_l+p_h;
    j = __HI(z);
    i = __LO(z);
    if (j&gt;=0x40900000) {                /* z &gt;= 1024 */
        if(((j-0x40900000)|i)!=0)           /* if z &gt; 1024 */
        return s*huge*huge;         /* overflow */
        else {
        if(p_l+ovt&gt;z-p_h) return s*huge*huge;   /* overflow */
        }
    } else if((j&amp;0x7fffffff)&gt;=0x4090cc00 ) {    /* z &lt;= -1075 */
        if(((j-0xc090cc00)|i)!=0)       /* z &lt; -1075 */
        return s*tiny*tiny;     /* underflow */
        else {
        if(p_l&lt;=z-p_h) return s*tiny*tiny;  /* underflow */
        }
    }
    /*
     * compute 2**(p_h+p_l)
     */
    i = j&amp;0x7fffffff;
    k = (i&gt;&gt;20)-0x3ff;
    n = 0;
    if(i&gt;0x3fe00000) {      /* if |z| &gt; 0.5, set n = [z+0.5] */
        n = j+(0x00100000&gt;&gt;(k+1));
        k = ((n&amp;0x7fffffff)&gt;&gt;20)-0x3ff; /* new k for n */
        t = zero;
        __HI(t) = (n&amp;~(0x000fffff&gt;&gt;k));
        n = ((n&amp;0x000fffff)|0x00100000)&gt;&gt;(20-k);
        if(j&lt;0) n = -n;
        p_h -= t;
    } 
    t = p_l+p_h;
    __LO(t) = 0;
    u = t*lg2_h;
    v = (p_l-(t-p_h))*lg2+t*lg2_l;
    z = u+v;
    w = v-(z-u);
    t  = z*z;
    t1  = z - t*(P1+t*(P2+t*(P3+t*(P4+t*P5))));
    r  = (z*t1)/(t1-two)-(w+z*w);
    z  = one-(r-z);
    j  = __HI(z);
    j += (n&lt;&lt;20);
    if((j&gt;&gt;20)&lt;=0) z = scalbn(z,n); /* subnormal output */
    else __HI(z) += (n&lt;&lt;20);
    return s*z;
}
</code></pre>

<ul>
<li><strong><code>e_rem_pio2.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/* __ieee754_rem_pio2(x,y)
 * 
 * return the remainder of x rem pi/2 in y[0]+y[1] 
 * use __kernel_rem_pio2()
 */

#include &quot;fdlibm.h&quot;

/*
 * Table of constants for 2/pi, 396 Hex digits (476 decimal) of 2/pi 
 */
#ifdef __STDC__
static const int two_over_pi[] = {
#else
static int two_over_pi[] = {
#endif
0xA2F983, 0x6E4E44, 0x1529FC, 0x2757D1, 0xF534DD, 0xC0DB62, 
0x95993C, 0x439041, 0xFE5163, 0xABDEBB, 0xC561B7, 0x246E3A, 
0x424DD2, 0xE00649, 0x2EEA09, 0xD1921C, 0xFE1DEB, 0x1CB129, 
0xA73EE8, 0x8235F5, 0x2EBB44, 0x84E99C, 0x7026B4, 0x5F7E41, 
0x3991D6, 0x398353, 0x39F49C, 0x845F8B, 0xBDF928, 0x3B1FF8, 
0x97FFDE, 0x05980F, 0xEF2F11, 0x8B5A0A, 0x6D1F6D, 0x367ECF, 
0x27CB09, 0xB74F46, 0x3F669E, 0x5FEA2D, 0x7527BA, 0xC7EBE5, 
0xF17B3D, 0x0739F7, 0x8A5292, 0xEA6BFB, 0x5FB11F, 0x8D5D08, 
0x560330, 0x46FC7B, 0x6BABF0, 0xCFBC20, 0x9AF436, 0x1DA9E3, 
0x91615E, 0xE61B08, 0x659985, 0x5F14A0, 0x68408D, 0xFFD880, 
0x4D7327, 0x310606, 0x1556CA, 0x73A8C9, 0x60E27B, 0xC08C6B, 
};

#ifdef __STDC__
static const int npio2_hw[] = {
#else
static int npio2_hw[] = {
#endif
0x3FF921FB, 0x400921FB, 0x4012D97C, 0x401921FB, 0x401F6A7A, 0x4022D97C,
0x4025FDBB, 0x402921FB, 0x402C463A, 0x402F6A7A, 0x4031475C, 0x4032D97C,
0x40346B9C, 0x4035FDBB, 0x40378FDB, 0x403921FB, 0x403AB41B, 0x403C463A,
0x403DD85A, 0x403F6A7A, 0x40407E4C, 0x4041475C, 0x4042106C, 0x4042D97C,
0x4043A28C, 0x40446B9C, 0x404534AC, 0x4045FDBB, 0x4046C6CB, 0x40478FDB,
0x404858EB, 0x404921FB,
};

/*
 * invpio2:  53 bits of 2/pi
 * pio2_1:   first  33 bit of pi/2
 * pio2_1t:  pi/2 - pio2_1
 * pio2_2:   second 33 bit of pi/2
 * pio2_2t:  pi/2 - (pio2_1+pio2_2)
 * pio2_3:   third  33 bit of pi/2
 * pio2_3t:  pi/2 - (pio2_1+pio2_2+pio2_3)
 */

#ifdef __STDC__
static const double 
#else
static double 
#endif
zero =  0.00000000000000000000e+00, /* 0x00000000, 0x00000000 */
half =  5.00000000000000000000e-01, /* 0x3FE00000, 0x00000000 */
two24 =  1.67772160000000000000e+07, /* 0x41700000, 0x00000000 */
invpio2 =  6.36619772367581382433e-01, /* 0x3FE45F30, 0x6DC9C883 */
pio2_1  =  1.57079632673412561417e+00, /* 0x3FF921FB, 0x54400000 */
pio2_1t =  6.07710050650619224932e-11, /* 0x3DD0B461, 0x1A626331 */
pio2_2  =  6.07710050630396597660e-11, /* 0x3DD0B461, 0x1A600000 */
pio2_2t =  2.02226624879595063154e-21, /* 0x3BA3198A, 0x2E037073 */
pio2_3  =  2.02226624871116645580e-21, /* 0x3BA3198A, 0x2E000000 */
pio2_3t =  8.47842766036889956997e-32; /* 0x397B839A, 0x252049C1 */

#ifdef __STDC__
    int __ieee754_rem_pio2(double x, double *y)
#else
    int __ieee754_rem_pio2(x,y)
    double x,y[];
#endif
{
    double z,w,t,r,fn;
    double tx[3];
    int e0,i,j,nx,n,ix,hx;

    hx = __HI(x);       /* high word of x */
    ix = hx&amp;0x7fffffff;
    if(ix&lt;=0x3fe921fb)   /* |x| ~&lt;= pi/4 , no need for reduction */
        {y[0] = x; y[1] = 0; return 0;}
    if(ix&lt;0x4002d97c) {  /* |x| &lt; 3pi/4, special case with n=+-1 */
        if(hx&gt;0) { 
        z = x - pio2_1;
        if(ix!=0x3ff921fb) {    /* 33+53 bit pi is good enough */
            y[0] = z - pio2_1t;
            y[1] = (z-y[0])-pio2_1t;
        } else {        /* near pi/2, use 33+33+53 bit pi */
            z -= pio2_2;
            y[0] = z - pio2_2t;
            y[1] = (z-y[0])-pio2_2t;
        }
        return 1;
        } else {    /* negative x */
        z = x + pio2_1;
        if(ix!=0x3ff921fb) {    /* 33+53 bit pi is good enough */
            y[0] = z + pio2_1t;
            y[1] = (z-y[0])+pio2_1t;
        } else {        /* near pi/2, use 33+33+53 bit pi */
            z += pio2_2;
            y[0] = z + pio2_2t;
            y[1] = (z-y[0])+pio2_2t;
        }
        return -1;
        }
    }
    if(ix&lt;=0x413921fb) { /* |x| ~&lt;= 2^19*(pi/2), medium size */
        t  = fabs(x);
        n  = (int) (t*invpio2+half);
        fn = (double)n;
        r  = t-fn*pio2_1;
        w  = fn*pio2_1t;    /* 1st round good to 85 bit */
        if(n&lt;32&amp;&amp;ix!=npio2_hw[n-1]) {   
        y[0] = r-w; /* quick check no cancellation */
        } else {
            j  = ix&gt;&gt;20;
            y[0] = r-w; 
            i = j-(((__HI(y[0]))&gt;&gt;20)&amp;0x7ff);
            if(i&gt;16) {  /* 2nd iteration needed, good to 118 */
            t  = r;
            w  = fn*pio2_2; 
            r  = t-w;
            w  = fn*pio2_2t-((t-r)-w);  
            y[0] = r-w;
            i = j-(((__HI(y[0]))&gt;&gt;20)&amp;0x7ff);
            if(i&gt;49)  { /* 3rd iteration need, 151 bits acc */
                t  = r; /* will cover all possible cases */
                w  = fn*pio2_3; 
                r  = t-w;
                w  = fn*pio2_3t-((t-r)-w);  
                y[0] = r-w;
            }
        }
        }
        y[1] = (r-y[0])-w;
        if(hx&lt;0)    {y[0] = -y[0]; y[1] = -y[1]; return -n;}
        else     return n;
    }
    /* 
     * all other (large) arguments
     */
    if(ix&gt;=0x7ff00000) {        /* x is inf or NaN */
        y[0]=y[1]=x-x; return 0;
    }
    /* set z = scalbn(|x|,ilogb(x)-23) */
    __LO(z) = __LO(x);
    e0  = (ix&gt;&gt;20)-1046;    /* e0 = ilogb(z)-23; */
    __HI(z) = ix - (e0&lt;&lt;20);
    for(i=0;i&lt;2;i++) {
        tx[i] = (double)((int)(z));
        z     = (z-tx[i])*two24;
    }
    tx[2] = z;
    nx = 3;
    while(tx[nx-1]==zero) nx--; /* skip zero term */
    n  =  __kernel_rem_pio2(tx,y,e0,nx,2,two_over_pi);
    if(hx&lt;0) {y[0] = -y[0]; y[1] = -y[1]; return -n;}
    return n;
}
</code></pre>

<ul>
<li><strong><code>e_remainder.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/* __ieee754_remainder(x,p)
 * Return :                  
 *  returns  x REM p  =  x - [x/p]*p as if in infinite 
 *  precise arithmetic, where [x/p] is the (infinite bit) 
 *  integer nearest x/p (in half way case choose the even one).
 * Method : 
 *  Based on fmod() return x-[x/p]chopped*p exactlp.
 */

#include &quot;fdlibm.h&quot;

#ifdef __STDC__
static const double zero = 0.0;
#else
static double zero = 0.0;
#endif


#ifdef __STDC__
    double __ieee754_remainder(double x, double p)
#else
    double __ieee754_remainder(x,p)
    double x,p;
#endif
{
    int hx,hp;
    unsigned sx,lx,lp;
    double p_half;

    hx = __HI(x);       /* high word of x */
    lx = __LO(x);       /* low  word of x */
    hp = __HI(p);       /* high word of p */
    lp = __LO(p);       /* low  word of p */
    sx = hx&amp;0x80000000;
    hp &amp;= 0x7fffffff;
    hx &amp;= 0x7fffffff;

    /* purge off exception values */
    if((hp|lp)==0) return (x*p)/(x*p);  /* p = 0 */
    if((hx&gt;=0x7ff00000)||           /* x not finite */
      ((hp&gt;=0x7ff00000)&amp;&amp;           /* p is NaN */
      (((hp-0x7ff00000)|lp)!=0)))
        return (x*p)/(x*p);


    if (hp&lt;=0x7fdfffff) x = __ieee754_fmod(x,p+p);  /* now x &lt; 2p */
    if (((hx-hp)|(lx-lp))==0) return zero*x;
    x  = fabs(x);
    p  = fabs(p);
    if (hp&lt;0x00200000) {
        if(x+x&gt;p) {
        x-=p;
        if(x+x&gt;=p) x -= p;
        }
    } else {
        p_half = 0.5*p;
        if(x&gt;p_half) {
        x-=p;
        if(x&gt;=p_half) x -= p;
        }
    }
    __HI(x) ^= sx;
    return x;
}
</code></pre>

<ul>
<li><strong><code>e_scalb.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/*
 * __ieee754_scalb(x, fn) is provide for
 * passing various standard test suite. One 
 * should use scalbn() instead.
 */

#include &quot;fdlibm.h&quot;

#ifdef _SCALB_INT
#ifdef __STDC__
    double __ieee754_scalb(double x, int fn)
#else
    double __ieee754_scalb(x,fn)
    double x; int fn;
#endif
#else
#ifdef __STDC__
    double __ieee754_scalb(double x, double fn)
#else
    double __ieee754_scalb(x,fn)
    double x, fn;
#endif
#endif
{
#ifdef _SCALB_INT
    return scalbn(x,fn);
#else
    if (isnan(x)||isnan(fn)) return x*fn;
    if (!finite(fn)) {
        if(fn&gt;0.0) return x*fn;
        else       return x/(-fn);
    }
    if (rint(fn)!=fn) return (fn-fn)/(fn-fn);
    if ( fn &gt; 65000.0) return scalbn(x, 65000);
    if (-fn &gt; 65000.0) return scalbn(x,-65000);
    return scalbn(x,(int)fn);
#endif
}
</code></pre>

<ul>
<li><strong><code>e_sinh.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/* __ieee754_sinh(x)
 * Method : 
 * mathematically sinh(x) if defined to be (exp(x)-exp(-x))/2
 *  1. Replace x by |x| (sinh(-x) = -sinh(x)). 
 *  2. 
 *                                          E + E/(E+1)
 *      0        &lt;= x &lt;= 22     :  sinh(x) := --------------, E=expm1(x)
 *                                  2
 *
 *      22       &lt;= x &lt;= lnovft :  sinh(x) := exp(x)/2 
 *      lnovft   &lt;= x &lt;= ln2ovft:  sinh(x) := exp(x/2)/2 * exp(x/2)
 *      ln2ovft  &lt;  x       :  sinh(x) := x*shuge (overflow)
 *
 * Special cases:
 *  sinh(x) is |x| if x is +INF, -INF, or NaN.
 *  only sinh(0)=0 is exact for finite x.
 */

#include &quot;fdlibm.h&quot;

#ifdef __STDC__
static const double one = 1.0, shuge = 1.0e307;
#else
static double one = 1.0, shuge = 1.0e307;
#endif

#ifdef __STDC__
    double __ieee754_sinh(double x)
#else
    double __ieee754_sinh(x)
    double x;
#endif
{   
    double t,w,h;
    int ix,jx;
    unsigned lx;

    /* High word of |x|. */
    jx = __HI(x);
    ix = jx&amp;0x7fffffff;

    /* x is INF or NaN */
    if(ix&gt;=0x7ff00000) return x+x;  

    h = 0.5;
    if (jx&lt;0) h = -h;
    /* |x| in [0,22], return sign(x)*0.5*(E+E/(E+1))) */
    if (ix &lt; 0x40360000) {      /* |x|&lt;22 */
        if (ix&lt;0x3e300000)      /* |x|&lt;2**-28 */
        if(shuge+x&gt;one) return x;/* sinh(tiny) = tiny with inexact */
        t = expm1(fabs(x));
        if(ix&lt;0x3ff00000) return h*(2.0*t-t*t/(t+one));
        return h*(t+t/(t+one));
    }

    /* |x| in [22, log(maxdouble)] return 0.5*exp(|x|) */
    if (ix &lt; 0x40862E42)  return h*__ieee754_exp(fabs(x));

    /* |x| in [log(maxdouble), overflowthresold] */
    lx = *( (((*(unsigned*)&amp;one)&gt;&gt;29)) + (unsigned*)&amp;x);
    if (ix&lt;0x408633CE || (ix==0x408633ce)&amp;&amp;(lx&lt;=(unsigned)0x8fb9f87d)) {
        w = __ieee754_exp(0.5*fabs(x));
        t = h*w;
        return t*w;
    }

    /* |x| &gt; overflowthresold, sinh(x) overflow */
    return x*shuge;
}
</code></pre>

<ul>
<li><strong><code>e_sqrt.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/* __ieee754_sqrt(x)
 * Return correctly rounded sqrt.
 *           ------------------------------------------
 *       |  Use the hardware sqrt if you have one |
 *           ------------------------------------------
 * Method: 
 *   Bit by bit method using integer arithmetic. (Slow, but portable) 
 *   1. Normalization
 *  Scale x to y in [1,4) with even powers of 2: 
 *  find an integer k such that  1 &lt;= (y=x*2^(2k)) &lt; 4, then
 *      sqrt(x) = 2^k * sqrt(y)
 *   2. Bit by bit computation
 *  Let q  = sqrt(y) truncated to i bit after binary point (q = 1),
 *       i                           0
 *                                     i+1         2
 *      s  = 2*q , and  y  =  2   * ( y - q  ).     (1)
 *       i      i            i                 i
 *                                                        
 *  To compute q    from q , one checks whether 
 *          i+1       i                       
 *
 *                -(i+1) 2
 *          (q + 2      ) &lt;= y.         (2)
 *                i
 *                                -(i+1)
 *  If (2) is false, then q   = q ; otherwise q   = q  + 2      .
 *                 i+1   i             i+1   i
 *
 *  With some algebric manipulation, it is not difficult to see
 *  that (2) is equivalent to 
 *                             -(i+1)
 *          s  +  2       &lt;= y          (3)
 *           i                i
 *
 *  The advantage of (3) is that s  and y  can be computed by 
 *                    i      i
 *  the following recurrence formula:
 *      if (3) is false
 *
 *      s     =  s  ,   y    = y   ;            (4)
 *       i+1      i      i+1    i
 *
 *      otherwise,
 *                         -i                     -(i+1)
 *      s     =  s  + 2  ,  y    = y  -  s  - 2         (5)
 *           i+1      i          i+1    i     i
 *              
 *  One may easily use induction to prove (4) and (5). 
 *  Note. Since the left hand side of (3) contain only i+2 bits,
 *        it does not necessary to do a full (53-bit) comparison 
 *        in (3).
 *   3. Final rounding
 *  After generating the 53 bits result, we compute one more bit.
 *  Together with the remainder, we can decide whether the
 *  result is exact, bigger than 1/2ulp, or less than 1/2ulp
 *  (it will never equal to 1/2ulp).
 *  The rounding mode can be detected by checking whether
 *  huge + tiny is equal to huge, and whether huge - tiny is
 *  equal to huge for some floating point number &quot;huge&quot; and &quot;tiny&quot;.
 *      
 * Special cases:
 *  sqrt(+-0) = +-0     ... exact
 *  sqrt(inf) = inf
 *  sqrt(-ve) = NaN     ... with invalid signal
 *  sqrt(NaN) = NaN     ... with invalid signal for signaling NaN
 *
 * Other methods : see the appended file at the end of the program below.
 *---------------
 */

#include &quot;fdlibm.h&quot;

#ifdef __STDC__
static  const double    one = 1.0, tiny=1.0e-300;
#else
static  double  one = 1.0, tiny=1.0e-300;
#endif

#ifdef __STDC__
    double __ieee754_sqrt(double x)
#else
    double __ieee754_sqrt(x)
    double x;
#endif
{
    double z;
    int     sign = (int)0x80000000; 
    unsigned r,t1,s1,ix1,q1;
    int ix0,s0,q,m,t,i;

    ix0 = __HI(x);          /* high word of x */
    ix1 = __LO(x);      /* low word of x */

    /* take care of Inf and NaN */
    if((ix0&amp;0x7ff00000)==0x7ff00000) {          
        return x*x+x;       /* sqrt(NaN)=NaN, sqrt(+inf)=+inf
                       sqrt(-inf)=sNaN */
    } 
    /* take care of zero */
    if(ix0&lt;=0) {
        if(((ix0&amp;(~sign))|ix1)==0) return x;/* sqrt(+-0) = +-0 */
        else if(ix0&lt;0)
        return (x-x)/(x-x);     /* sqrt(-ve) = sNaN */
    }
    /* normalize x */
    m = (ix0&gt;&gt;20);
    if(m==0) {              /* subnormal x */
        while(ix0==0) {
        m -= 21;
        ix0 |= (ix1&gt;&gt;11); ix1 &lt;&lt;= 21;
        }
        for(i=0;(ix0&amp;0x00100000)==0;i++) ix0&lt;&lt;=1;
        m -= i-1;
        ix0 |= (ix1&gt;&gt;(32-i));
        ix1 &lt;&lt;= i;
    }
    m -= 1023;  /* unbias exponent */
    ix0 = (ix0&amp;0x000fffff)|0x00100000;
    if(m&amp;1){    /* odd m, double x to make it even */
        ix0 += ix0 + ((ix1&amp;sign)&gt;&gt;31);
        ix1 += ix1;
    }
    m &gt;&gt;= 1;    /* m = [m/2] */

    /* generate sqrt(x) bit by bit */
    ix0 += ix0 + ((ix1&amp;sign)&gt;&gt;31);
    ix1 += ix1;
    q = q1 = s0 = s1 = 0;   /* [q,q1] = sqrt(x) */
    r = 0x00200000;     /* r = moving bit from right to left */

    while(r!=0) {
        t = s0+r; 
        if(t&lt;=ix0) { 
        s0   = t+r; 
        ix0 -= t; 
        q   += r; 
        } 
        ix0 += ix0 + ((ix1&amp;sign)&gt;&gt;31);
        ix1 += ix1;
        r&gt;&gt;=1;
    }

    r = sign;
    while(r!=0) {
        t1 = s1+r; 
        t  = s0;
        if((t&lt;ix0)||((t==ix0)&amp;&amp;(t1&lt;=ix1))) { 
        s1  = t1+r;
        if(((t1&amp;sign)==sign)&amp;&amp;(s1&amp;sign)==0) s0 += 1;
        ix0 -= t;
        if (ix1 &lt; t1) ix0 -= 1;
        ix1 -= t1;
        q1  += r;
        }
        ix0 += ix0 + ((ix1&amp;sign)&gt;&gt;31);
        ix1 += ix1;
        r&gt;&gt;=1;
    }

    /* use floating add to find out rounding direction */
    if((ix0|ix1)!=0) {
        z = one-tiny; /* trigger inexact flag */
        if (z&gt;=one) {
            z = one+tiny;
            if (q1==(unsigned)0xffffffff) { q1=0; q += 1;}
        else if (z&gt;one) {
            if (q1==(unsigned)0xfffffffe) q+=1;
            q1+=2; 
        } else
                q1 += (q1&amp;1);
        }
    }
    ix0 = (q&gt;&gt;1)+0x3fe00000;
    ix1 =  q1&gt;&gt;1;
    if ((q&amp;1)==1) ix1 |= sign;
    ix0 += (m &lt;&lt;20);
    __HI(z) = ix0;
    __LO(z) = ix1;
    return z;
}

/*
Other methods  (use floating-point arithmetic)
-------------
(This is a copy of a drafted paper by Prof W. Kahan 
and K.C. Ng, written in May, 1986)

    Two algorithms are given here to implement sqrt(x) 
    (IEEE double precision arithmetic) in software.
    Both supply sqrt(x) correctly rounded. The first algorithm (in
    Section A) uses newton iterations and involves four divisions.
    The second one uses reciproot iterations to avoid division, but
    requires more multiplications. Both algorithms need the ability
    to chop results of arithmetic operations instead of round them, 
    and the INEXACT flag to indicate when an arithmetic operation
    is executed exactly with no roundoff error, all part of the 
    standard (IEEE 754-1985). The ability to perform shift, add,
    subtract and logical AND operations upon 32-bit words is needed
    too, though not part of the standard.

A.  sqrt(x) by Newton Iteration

   (1)  Initial approximation

    Let x0 and x1 be the leading and the trailing 32-bit words of
    a floating point number x (in IEEE double format) respectively 

        1    11          52               ...widths
       ------------------------------------------------------
    x: |s|    e     |         f             |
       ------------------------------------------------------
          msb    lsb  msb                     lsb ...order


         ------------------------        ------------------------
    x0:  |s|   e    |    f1     |    x1: |          f2           |
         ------------------------        ------------------------

    By performing shifts and subtracts on x0 and x1 (both regarded
    as integers), we obtain an 8-bit approximation of sqrt(x) as
    follows.

        k  := (x0&gt;&gt;1) + 0x1ff80000;
        y0 := k - T1[31&amp;(k&gt;&gt;15)].   ... y ~ sqrt(x) to 8 bits
    Here k is a 32-bit integer and T1[] is an integer array containing
    correction terms. Now magically the floating value of y (y's
    leading 32-bit word is y0, the value of its trailing word is 0)
    approximates sqrt(x) to almost 8-bit.

    Value of T1:
    static int T1[32]= {
    0,  1024,   3062,   5746,   9193,   13348,  18162,  23592,
    29598,  36145,  43202,  50740,  58733,  67158,  75992,  85215,
    83599,  71378,  60428,  50647,  41945,  34246,  27478,  21581,
    16499,  12183,  8588,   5674,   3403,   1742,   661,    130,};

    (2) Iterative refinement

    Apply Heron's rule three times to y, we have y approximates 
    sqrt(x) to within 1 ulp (Unit in the Last Place):

        y := (y+x/y)/2      ... almost 17 sig. bits
        y := (y+x/y)/2      ... almost 35 sig. bits
        y := y-(y-x/y)/2    ... within 1 ulp


    Remark 1.
        Another way to improve y to within 1 ulp is:

        y := (y+x/y)        ... almost 17 sig. bits to 2*sqrt(x)
        y := y - 0x00100006 ... almost 18 sig. bits to sqrt(x)

                2
                (x-y )*y
        y := y + 2* ----------  ...within 1 ulp
                   2
                 3y  + x


    This formula has one division fewer than the one above; however,
    it requires more multiplications and additions. Also x must be
    scaled in advance to avoid spurious overflow in evaluating the
    expression 3y*y+x. Hence it is not recommended uless division
    is slow. If division is very slow, then one should use the 
    reciproot algorithm given in section B.

    (3) Final adjustment

    By twiddling y's last bit it is possible to force y to be 
    correctly rounded according to the prevailing rounding mode
    as follows. Let r and i be copies of the rounding mode and
    inexact flag before entering the square root program. Also we
    use the expression y+-ulp for the next representable floating
    numbers (up and down) of y. Note that y+-ulp = either fixed
    point y+-1, or multiply y by nextafter(1,+-inf) in chopped
    mode.

        I := FALSE; ... reset INEXACT flag I
        R := RZ;    ... set rounding mode to round-toward-zero
        z := x/y;   ... chopped quotient, possibly inexact
        If(not I) then {    ... if the quotient is exact
            if(z=y) {
                I := i;  ... restore inexact flag
                R := r;  ... restore rounded mode
                return sqrt(x):=y.
            } else {
            z := z - ulp;   ... special rounding
            }
        }
        i := TRUE;      ... sqrt(x) is inexact
        If (r=RN) then z=z+ulp  ... rounded-to-nearest
        If (r=RP) then {    ... round-toward-+inf
            y = y+ulp; z=z+ulp;
        }
        y := y+z;       ... chopped sum
        y0:=y0-0x00100000;  ... y := y/2 is correctly rounded.
            I := i;         ... restore inexact flag
            R := r;         ... restore rounded mode
            return sqrt(x):=y.

    (4) Special cases

    Square root of +inf, +-0, or NaN is itself;
    Square root of a negative number is NaN with invalid signal.


B.  sqrt(x) by Reciproot Iteration

   (1)  Initial approximation

    Let x0 and x1 be the leading and the trailing 32-bit words of
    a floating point number x (in IEEE double format) respectively
    (see section A). By performing shifs and subtracts on x0 and y0,
    we obtain a 7.8-bit approximation of 1/sqrt(x) as follows.

        k := 0x5fe80000 - (x0&gt;&gt;1);
        y0:= k - T2[63&amp;(k&gt;&gt;14)].    ... y ~ 1/sqrt(x) to 7.8 bits

    Here k is a 32-bit integer and T2[] is an integer array 
    containing correction terms. Now magically the floating
    value of y (y's leading 32-bit word is y0, the value of
    its trailing word y1 is set to zero) approximates 1/sqrt(x)
    to almost 7.8-bit.

    Value of T2:
    static int T2[64]= {
    0x1500, 0x2ef8, 0x4d67, 0x6b02, 0x87be, 0xa395, 0xbe7a, 0xd866,
    0xf14a, 0x1091b,0x11fcd,0x13552,0x14999,0x15c98,0x16e34,0x17e5f,
    0x18d03,0x19a01,0x1a545,0x1ae8a,0x1b5c4,0x1bb01,0x1bfde,0x1c28d,
    0x1c2de,0x1c0db,0x1ba73,0x1b11c,0x1a4b5,0x1953d,0x18266,0x16be0,
    0x1683e,0x179d8,0x18a4d,0x19992,0x1a789,0x1b445,0x1bf61,0x1c989,
    0x1d16d,0x1d77b,0x1dddf,0x1e2ad,0x1e5bf,0x1e6e8,0x1e654,0x1e3cd,
    0x1df2a,0x1d635,0x1cb16,0x1be2c,0x1ae4e,0x19bde,0x1868e,0x16e2e,
    0x1527f,0x1334a,0x11051,0xe951, 0xbe01, 0x8e0d, 0x5924, 0x1edd,};

    (2) Iterative refinement

    Apply Reciproot iteration three times to y and multiply the
    result by x to get an approximation z that matches sqrt(x)
    to about 1 ulp. To be exact, we will have 
        -1ulp &lt; sqrt(x)-z&lt;1.0625ulp.

    ... set rounding mode to Round-to-nearest
       y := y*(1.5-0.5*x*y*y)   ... almost 15 sig. bits to 1/sqrt(x)
       y := y*((1.5-2^-30)+0.5*x*y*y)... about 29 sig. bits to 1/sqrt(x)
    ... special arrangement for better accuracy
       z := x*y         ... 29 bits to sqrt(x), with z*y&lt;1
       z := z + 0.5*z*(1-z*y)   ... about 1 ulp to sqrt(x)

    Remark 2. The constant 1.5-2^-30 is chosen to bias the error so that
    (a) the term z*y in the final iteration is always less than 1; 
    (b) the error in the final result is biased upward so that
        -1 ulp &lt; sqrt(x) - z &lt; 1.0625 ulp
        instead of |sqrt(x)-z|&lt;1.03125ulp.

    (3) Final adjustment

    By twiddling y's last bit it is possible to force y to be 
    correctly rounded according to the prevailing rounding mode
    as follows. Let r and i be copies of the rounding mode and
    inexact flag before entering the square root program. Also we
    use the expression y+-ulp for the next representable floating
    numbers (up and down) of y. Note that y+-ulp = either fixed
    point y+-1, or multiply y by nextafter(1,+-inf) in chopped
    mode.

    R := RZ;        ... set rounding mode to round-toward-zero
    switch(r) {
        case RN:        ... round-to-nearest
           if(x&lt;= z*(z-ulp)...chopped) z = z - ulp; else
           if(x&lt;= z*(z+ulp)...chopped) z = z; else z = z+ulp;
           break;
        case RZ:case RM:    ... round-to-zero or round-to--inf
           R:=RP;       ... reset rounding mod to round-to-+inf
           if(x&lt;z*z ... rounded up) z = z - ulp; else
           if(x&gt;=(z+ulp)*(z+ulp) ...rounded up) z = z+ulp;
           break;
        case RP:        ... round-to-+inf
           if(x&gt;(z+ulp)*(z+ulp)...chopped) z = z+2*ulp; else
           if(x&gt;z*z ...chopped) z = z+ulp;
           break;
    }

    Remark 3. The above comparisons can be done in fixed point. For
    example, to compare x and w=z*z chopped, it suffices to compare
    x1 and w1 (the trailing parts of x and w), regarding them as
    two's complement integers.

    ...Is z an exact square root?
    To determine whether z is an exact square root of x, let z1 be the
    trailing part of z, and also let x0 and x1 be the leading and
    trailing parts of x.

    If ((z1&amp;0x03ffffff)!=0) ... not exact if trailing 26 bits of z!=0
        I := 1;     ... Raise Inexact flag: z is not exact
    else {
        j := 1 - [(x0&gt;&gt;20)&amp;1]   ... j = logb(x) mod 2
        k := z1 &gt;&gt; 26;      ... get z's 25-th and 26-th 
                        fraction bits
        I := i or (k&amp;j) or ((k&amp;(j+j+1))!=(x1&amp;3));
    }
    R:= r       ... restore rounded mode
    return sqrt(x):=z.

    If multiplication is cheaper then the foregoing red tape, the 
    Inexact flag can be evaluated by

        I := i;
        I := (z*z!=x) or I.

    Note that z*z can overwrite I; this value must be sensed if it is 
    True.

    Remark 4. If z*z = x exactly, then bit 25 to bit 0 of z1 must be
    zero.

            --------------------
        z1: |        f2        | 
            --------------------
        bit 31         bit 0

    Further more, bit 27 and 26 of z1, bit 0 and 1 of x1, and the odd
    or even of logb(x) have the following relations:

    -------------------------------------------------
    bit 27,26 of z1     bit 1,0 of x1   logb(x)
    -------------------------------------------------
    00          00      odd and even
    01          01      even
    10          10      odd
    10          00      even
    11          01      even
    -------------------------------------------------

    (4) Special cases (see (4) of Section A).   

 */

</code></pre>

<ul>
<li><strong><code>k_cos.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/*
 * __kernel_cos( x,  y )
 * kernel cos function on [-pi/4, pi/4], pi/4 ~ 0.785398164
 * Input x is assumed to be bounded by ~pi/4 in magnitude.
 * Input y is the tail of x. 
 *
 * Algorithm
 *  1. Since cos(-x) = cos(x), we need only to consider positive x.
 *  2. if x &lt; 2^-27 (hx&lt;0x3e400000 0), return 1 with inexact if x!=0.
 *  3. cos(x) is approximated by a polynomial of degree 14 on
 *     [0,pi/4]
 *                           4            14
 *      cos(x) ~ 1 - x*x/2 + C1*x + ... + C6*x
 *     where the remez error is
 *  
 *  |              2     4     6     8     10    12     14 |     -58
 *  |cos(x)-(1-.5*x +C1*x +C2*x +C3*x +C4*x +C5*x  +C6*x  )| &lt;= 2
 *  |                                      | 
 * 
 *                 4     6     8     10    12     14 
 *  4. let r = C1*x +C2*x +C3*x +C4*x +C5*x  +C6*x  , then
 *         cos(x) = 1 - x*x/2 + r
 *     since cos(x+y) ~ cos(x) - sin(x)*y 
 *            ~ cos(x) - x*y,
 *     a correction term is necessary in cos(x) and hence
 *      cos(x+y) = 1 - (x*x/2 - (r - x*y))
 *     For better accuracy when x &gt; 0.3, let qx = |x|/4 with
 *     the last 32 bits mask off, and if x &gt; 0.78125, let qx = 0.28125.
 *     Then
 *      cos(x+y) = (1-qx) - ((x*x/2-qx) - (r-x*y)).
 *     Note that 1-qx and (x*x/2-qx) is EXACT here, and the
 *     magnitude of the latter is at least a quarter of x*x/2,
 *     thus, reducing the rounding error in the subtraction.
 */

#include &quot;fdlibm.h&quot;

#ifdef __STDC__
static const double 
#else
static double 
#endif
one =  1.00000000000000000000e+00, /* 0x3FF00000, 0x00000000 */
C1  =  4.16666666666666019037e-02, /* 0x3FA55555, 0x5555554C */
C2  = -1.38888888888741095749e-03, /* 0xBF56C16C, 0x16C15177 */
C3  =  2.48015872894767294178e-05, /* 0x3EFA01A0, 0x19CB1590 */
C4  = -2.75573143513906633035e-07, /* 0xBE927E4F, 0x809C52AD */
C5  =  2.08757232129817482790e-09, /* 0x3E21EE9E, 0xBDB4B1C4 */
C6  = -1.13596475577881948265e-11; /* 0xBDA8FAE9, 0xBE8838D4 */

#ifdef __STDC__
    double __kernel_cos(double x, double y)
#else
    double __kernel_cos(x, y)
    double x,y;
#endif
{
    double a,hz,z,r,qx;
    int ix;
    ix = __HI(x)&amp;0x7fffffff;    /* ix = |x|'s high word*/
    if(ix&lt;0x3e400000) {         /* if x &lt; 2**27 */
        if(((int)x)==0) return one;     /* generate inexact */
    }
    z  = x*x;
    r  = z*(C1+z*(C2+z*(C3+z*(C4+z*(C5+z*C6)))));
    if(ix &lt; 0x3FD33333)             /* if |x| &lt; 0.3 */ 
        return one - (0.5*z - (z*r - x*y));
    else {
        if(ix &gt; 0x3fe90000) {       /* x &gt; 0.78125 */
        qx = 0.28125;
        } else {
            __HI(qx) = ix-0x00200000;   /* x/4 */
            __LO(qx) = 0;
        }
        hz = 0.5*z-qx;
        a  = one-qx;
        return a - (hz - (z*r-x*y));
    }
}
</code></pre>

<ul>
<li><strong><code>k_rem_pio2.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/*
 * __kernel_rem_pio2(x,y,e0,nx,prec,ipio2)
 * double x[],y[]; int e0,nx,prec; int ipio2[];
 * 
 * __kernel_rem_pio2 return the last three digits of N with 
 *      y = x - N*pi/2
 * so that |y| &lt; pi/2.
 *
 * The method is to compute the integer (mod 8) and fraction parts of 
 * (2/pi)*x without doing the full multiplication. In general we
 * skip the part of the product that are known to be a huge integer (
 * more accurately, = 0 mod 8 ). Thus the number of operations are
 * independent of the exponent of the input.
 *
 * (2/pi) is represented by an array of 24-bit integers in ipio2[].
 *
 * Input parameters:
 *  x[] The input value (must be positive) is broken into nx 
 *      pieces of 24-bit integers in double precision format.
 *      x[i] will be the i-th 24 bit of x. The scaled exponent 
 *      of x[0] is given in input parameter e0 (i.e., x[0]*2^e0 
 *      match x's up to 24 bits.
 *
 *      Example of breaking a double positive z into x[0]+x[1]+x[2]:
 *          e0 = ilogb(z)-23
 *          z  = scalbn(z,-e0)
 *      for i = 0,1,2
 *          x[i] = floor(z)
 *          z    = (z-x[i])*2**24
 *
 *
 *  y[] ouput result in an array of double precision numbers.
 *      The dimension of y[] is:
 *          24-bit  precision   1
 *          53-bit  precision   2
 *          64-bit  precision   2
 *          113-bit precision   3
 *      The actual value is the sum of them. Thus for 113-bit
 *      precison, one may have to do something like:
 *
 *      long double t,w,r_head, r_tail;
 *      t = (long double)y[2] + (long double)y[1];
 *      w = (long double)y[0];
 *      r_head = t+w;
 *      r_tail = w - (r_head - t);
 *
 *  e0  The exponent of x[0]
 *
 *  nx  dimension of x[]
 *
 *      prec    an integer indicating the precision:
 *          0   24  bits (single)
 *          1   53  bits (double)
 *          2   64  bits (extended)
 *          3   113 bits (quad)
 *
 *  ipio2[]
 *      integer array, contains the (24*i)-th to (24*i+23)-th 
 *      bit of 2/pi after binary point. The corresponding 
 *      floating value is
 *
 *          ipio2[i] * 2^(-24(i+1)).
 *
 * External function:
 *  double scalbn(), floor();
 *
 *
 * Here is the description of some local variables:
 *
 *  jk  jk+1 is the initial number of terms of ipio2[] needed
 *      in the computation. The recommended value is 2,3,4,
 *      6 for single, double, extended,and quad.
 *
 *  jz  local integer variable indicating the number of 
 *      terms of ipio2[] used. 
 *
 *  jx  nx - 1
 *
 *  jv  index for pointing to the suitable ipio2[] for the
 *      computation. In general, we want
 *          ( 2^e0*x[0] * ipio2[jv-1]*2^(-24jv) )/8
 *      is an integer. Thus
 *          e0-3-24*jv &gt;= 0 or (e0-3)/24 &gt;= jv
 *      Hence jv = max(0,(e0-3)/24).
 *
 *  jp  jp+1 is the number of terms in PIo2[] needed, jp = jk.
 *
 *  q[] double array with integral value, representing the
 *      24-bits chunk of the product of x and 2/pi.
 *
 *  q0  the corresponding exponent of q[0]. Note that the
 *      exponent for q[i] would be q0-24*i.
 *
 *  PIo2[]  double precision array, obtained by cutting pi/2
 *      into 24 bits chunks. 
 *
 *  f[] ipio2[] in floating point 
 *
 *  iq[]    integer array by breaking up q[] in 24-bits chunk.
 *
 *  fq[]    final product of x*(2/pi) in fq[0],..,fq[jk]
 *
 *  ih  integer. If &gt;0 it indicates q[] is &gt;= 0.5, hence
 *      it also indicates the *sign* of the result.
 *
 */


/*
 * Constants:
 * The hexadecimal values are the intended ones for the following 
 * constants. The decimal values may be used, provided that the 
 * compiler will convert from decimal to binary accurately enough 
 * to produce the hexadecimal values shown.
 */

#include &quot;fdlibm.h&quot;

#ifdef __STDC__
static const int init_jk[] = {2,3,4,6}; /* initial value for jk */
#else
static int init_jk[] = {2,3,4,6}; 
#endif

#ifdef __STDC__
static const double PIo2[] = {
#else
static double PIo2[] = {
#endif
  1.57079625129699707031e+00, /* 0x3FF921FB, 0x40000000 */
  7.54978941586159635335e-08, /* 0x3E74442D, 0x00000000 */
  5.39030252995776476554e-15, /* 0x3CF84698, 0x80000000 */
  3.28200341580791294123e-22, /* 0x3B78CC51, 0x60000000 */
  1.27065575308067607349e-29, /* 0x39F01B83, 0x80000000 */
  1.22933308981111328932e-36, /* 0x387A2520, 0x40000000 */
  2.73370053816464559624e-44, /* 0x36E38222, 0x80000000 */
  2.16741683877804819444e-51, /* 0x3569F31D, 0x00000000 */
};

#ifdef __STDC__
static const double         
#else
static double           
#endif
zero   = 0.0,
one    = 1.0,
two24   =  1.67772160000000000000e+07, /* 0x41700000, 0x00000000 */
twon24  =  5.96046447753906250000e-08; /* 0x3E700000, 0x00000000 */

#ifdef __STDC__
    int __kernel_rem_pio2(double *x, double *y, int e0, int nx, int prec, const int *ipio2) 
#else
    int __kernel_rem_pio2(x,y,e0,nx,prec,ipio2)     
    double x[], y[]; int e0,nx,prec; int ipio2[];
#endif
{
    int jz,jx,jv,jp,jk,carry,n,iq[20],i,j,k,m,q0,ih;
    double z,fw,f[20],fq[20],q[20];

    /* initialize jk*/
    jk = init_jk[prec];
    jp = jk;

    /* determine jx,jv,q0, note that 3&gt;q0 */
    jx =  nx-1;
    jv = (e0-3)/24; if(jv&lt;0) jv=0;
    q0 =  e0-24*(jv+1);

    /* set up f[0] to f[jx+jk] where f[jx+jk] = ipio2[jv+jk] */
    j = jv-jx; m = jx+jk;
    for(i=0;i&lt;=m;i++,j++) f[i] = (j&lt;0)? zero : (double) ipio2[j];

    /* compute q[0],q[1],...q[jk] */
    for (i=0;i&lt;=jk;i++) {
        for(j=0,fw=0.0;j&lt;=jx;j++) fw += x[j]*f[jx+i-j]; q[i] = fw;
    }

    jz = jk;
recompute:
    /* distill q[] into iq[] reversingly */
    for(i=0,j=jz,z=q[jz];j&gt;0;i++,j--) {
        fw    =  (double)((int)(twon24* z));
        iq[i] =  (int)(z-two24*fw);
        z     =  q[j-1]+fw;
    }

    /* compute n */
    z  = scalbn(z,q0);      /* actual value of z */
    z -= 8.0*floor(z*0.125);        /* trim off integer &gt;= 8 */
    n  = (int) z;
    z -= (double)n;
    ih = 0;
    if(q0&gt;0) {  /* need iq[jz-1] to determine n */
        i  = (iq[jz-1]&gt;&gt;(24-q0)); n += i;
        iq[jz-1] -= i&lt;&lt;(24-q0);
        ih = iq[jz-1]&gt;&gt;(23-q0);
    } 
    else if(q0==0) ih = iq[jz-1]&gt;&gt;23;
    else if(z&gt;=0.5) ih=2;

    if(ih&gt;0) {  /* q &gt; 0.5 */
        n += 1; carry = 0;
        for(i=0;i&lt;jz ;i++) {    /* compute 1-q */
        j = iq[i];
        if(carry==0) {
            if(j!=0) {
            carry = 1; iq[i] = 0x1000000- j;
            }
        } else  iq[i] = 0xffffff - j;
        }
        if(q0&gt;0) {      /* rare case: chance is 1 in 12 */
            switch(q0) {
            case 1:
               iq[jz-1] &amp;= 0x7fffff; break;
            case 2:
               iq[jz-1] &amp;= 0x3fffff; break;
            }
        }
        if(ih==2) {
        z = one - z;
        if(carry!=0) z -= scalbn(one,q0);
        }
    }

    /* check if recomputation is needed */
    if(z==zero) {
        j = 0;
        for (i=jz-1;i&gt;=jk;i--) j |= iq[i];
        if(j==0) { /* need recomputation */
        for(k=1;iq[jk-k]==0;k++);   /* k = no. of terms needed */

        for(i=jz+1;i&lt;=jz+k;i++) {   /* add q[jz+1] to q[jz+k] */
            f[jx+i] = (double) ipio2[jv+i];
            for(j=0,fw=0.0;j&lt;=jx;j++) fw += x[j]*f[jx+i-j];
            q[i] = fw;
        }
        jz += k;
        goto recompute;
        }
    }

    /* chop off zero terms */
    if(z==0.0) {
        jz -= 1; q0 -= 24;
        while(iq[jz]==0) { jz--; q0-=24;}
    } else { /* break z into 24-bit if necessary */
        z = scalbn(z,-q0);
        if(z&gt;=two24) { 
        fw = (double)((int)(twon24*z));
        iq[jz] = (int)(z-two24*fw);
        jz += 1; q0 += 24;
        iq[jz] = (int) fw;
        } else iq[jz] = (int) z ;
    }

    /* convert integer &quot;bit&quot; chunk to floating-point value */
    fw = scalbn(one,q0);
    for(i=jz;i&gt;=0;i--) {
        q[i] = fw*(double)iq[i]; fw*=twon24;
    }

    /* compute PIo2[0,...,jp]*q[jz,...,0] */
    for(i=jz;i&gt;=0;i--) {
        for(fw=0.0,k=0;k&lt;=jp&amp;&amp;k&lt;=jz-i;k++) fw += PIo2[k]*q[i+k];
        fq[jz-i] = fw;
    }

    /* compress fq[] into y[] */
    switch(prec) {
        case 0:
        fw = 0.0;
        for (i=jz;i&gt;=0;i--) fw += fq[i];
        y[0] = (ih==0)? fw: -fw; 
        break;
        case 1:
        case 2:
        fw = 0.0;
        for (i=jz;i&gt;=0;i--) fw += fq[i]; 
        y[0] = (ih==0)? fw: -fw; 
        fw = fq[0]-fw;
        for (i=1;i&lt;=jz;i++) fw += fq[i];
        y[1] = (ih==0)? fw: -fw; 
        break;
        case 3: /* painful */
        for (i=jz;i&gt;0;i--) {
            fw      = fq[i-1]+fq[i]; 
            fq[i]  += fq[i-1]-fw;
            fq[i-1] = fw;
        }
        for (i=jz;i&gt;1;i--) {
            fw      = fq[i-1]+fq[i]; 
            fq[i]  += fq[i-1]-fw;
            fq[i-1] = fw;
        }
        for (fw=0.0,i=jz;i&gt;=2;i--) fw += fq[i]; 
        if(ih==0) {
            y[0] =  fq[0]; y[1] =  fq[1]; y[2] =  fw;
        } else {
            y[0] = -fq[0]; y[1] = -fq[1]; y[2] = -fw;
        }
    }
    return n&amp;7;
}
</code></pre>

<ul>
<li><strong><code>k_sin.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/* __kernel_sin( x, y, iy)
 * kernel sin function on [-pi/4, pi/4], pi/4 ~ 0.7854
 * Input x is assumed to be bounded by ~pi/4 in magnitude.
 * Input y is the tail of x.
 * Input iy indicates whether y is 0. (if iy=0, y assume to be 0). 
 *
 * Algorithm
 *  1. Since sin(-x) = -sin(x), we need only to consider positive x. 
 *  2. if x &lt; 2^-27 (hx&lt;0x3e400000 0), return x with inexact if x!=0.
 *  3. sin(x) is approximated by a polynomial of degree 13 on
 *     [0,pi/4]
 *                   3            13
 *      sin(x) ~ x + S1*x + ... + S6*x
 *     where
 *  
 *  |sin(x)         2     4     6     8     10     12  |     -58
 *  |----- - (1+S1*x +S2*x +S3*x +S4*x +S5*x  +S6*x   )| &lt;= 2
 *  |  x                               | 
 * 
 *  4. sin(x+y) = sin(x) + sin'(x')*y
 *          ~ sin(x) + (1-x*x/2)*y
 *     For better accuracy, let 
 *           3      2      2      2      2
 *      r = x *(S2+x *(S3+x *(S4+x *(S5+x *S6))))
 *     then                   3    2
 *      sin(x) = x + (S1*x + (x *(r-y/2)+y))
 */

#include &quot;fdlibm.h&quot;

#ifdef __STDC__
static const double 
#else
static double 
#endif
half =  5.00000000000000000000e-01, /* 0x3FE00000, 0x00000000 */
S1  = -1.66666666666666324348e-01, /* 0xBFC55555, 0x55555549 */
S2  =  8.33333333332248946124e-03, /* 0x3F811111, 0x1110F8A6 */
S3  = -1.98412698298579493134e-04, /* 0xBF2A01A0, 0x19C161D5 */
S4  =  2.75573137070700676789e-06, /* 0x3EC71DE3, 0x57B1FE7D */
S5  = -2.50507602534068634195e-08, /* 0xBE5AE5E6, 0x8A2B9CEB */
S6  =  1.58969099521155010221e-10; /* 0x3DE5D93A, 0x5ACFD57C */

#ifdef __STDC__
    double __kernel_sin(double x, double y, int iy)
#else
    double __kernel_sin(x, y, iy)
    double x,y; int iy;     /* iy=0 if y is zero */
#endif
{
    double z,r,v;
    int ix;
    ix = __HI(x)&amp;0x7fffffff;    /* high word of x */
    if(ix&lt;0x3e400000)           /* |x| &lt; 2**-27 */
       {if((int)x==0) return x;}        /* generate inexact */
    z   =  x*x;
    v   =  z*x;
    r   =  S2+z*(S3+z*(S4+z*(S5+z*S6)));
    if(iy==0) return x+v*(S1+z*r);
    else      return x-((z*(half*y-v*r)-y)-v*S1);
}
</code></pre>

<ul>
<li><strong><code>k_standard.c</code>文件</strong></li>
</ul>
<pre><code class="c++">#include &quot;fdlibm.h&quot;
#include &lt;errno.h&gt;

#ifndef _USE_WRITE
#include &lt;stdio.h&gt;          /* fputs(), stderr */
#define WRITE2(u,v) fputs(u, stderr)
#else   /* !defined(_USE_WRITE) */
#include &lt;unistd.h&gt;         /* write */
#define WRITE2(u,v) write(2, u, v)
#undef fflush
#endif  /* !defined(_USE_WRITE) */

static double zero = 0.0;   /* used as const */

/* 
 * Standard conformance (non-IEEE) on exception cases.
 * Mapping:
 *  1 -- acos(|x|&gt;1)
 *  2 -- asin(|x|&gt;1)
 *  3 -- atan2(+-0,+-0)
 *  4 -- hypot overflow
 *  5 -- cosh overflow
 *  6 -- exp overflow
 *  7 -- exp underflow
 *  8 -- y0(0)
 *  9 -- y0(-ve)
 *  10-- y1(0)
 *  11-- y1(-ve)
 *  12-- yn(0)
 *  13-- yn(-ve)
 *  14-- lgamma(finite) overflow
 *  15-- lgamma(-integer)
 *  16-- log(0)
 *  17-- log(x&lt;0)
 *  18-- log10(0)
 *  19-- log10(x&lt;0)
 *  20-- pow(0.0,0.0)
 *  21-- pow(x,y) overflow
 *  22-- pow(x,y) underflow
 *  23-- pow(0,negative) 
 *  24-- pow(neg,non-integral)
 *  25-- sinh(finite) overflow
 *  26-- sqrt(negative)
 *      27-- fmod(x,0)
 *      28-- remainder(x,0)
 *  29-- acosh(x&lt;1)
 *  30-- atanh(|x|&gt;1)
 *  31-- atanh(|x|=1)
 *  32-- scalb overflow
 *  33-- scalb underflow
 *  34-- j0(|x|&gt;X_TLOSS)
 *  35-- y0(x&gt;X_TLOSS)
 *  36-- j1(|x|&gt;X_TLOSS)
 *  37-- y1(x&gt;X_TLOSS)
 *  38-- jn(|x|&gt;X_TLOSS, n)
 *  39-- yn(x&gt;X_TLOSS, n)
 *  40-- gamma(finite) overflow
 *  41-- gamma(-integer)
 *  42-- pow(NaN,0.0)
 */


#ifdef __STDC__
    double __kernel_standard(double x, double y, int type) 
#else
    double __kernel_standard(x,y,type) 
    double x,y; int type;
#endif
{
    struct exception exc;
#ifndef HUGE_VAL    /* this is the only routine that uses HUGE_VAL */ 
#define HUGE_VAL inf
    double inf = 0.0;

    __HI(inf) = 0x7ff00000; /* set inf to infinite */
#endif

#ifdef _USE_WRITE
    (void) fflush(stdout);
#endif
    exc.arg1 = x;
    exc.arg2 = y;
    switch(type) {
        case 1:
        /* acos(|x|&gt;1) */
        exc.type = DOMAIN;
        exc.name = &quot;acos&quot;;
        exc.retval = zero;
        if (_LIB_VERSION == _POSIX_)
          errno = EDOM;
        else if (!matherr(&amp;exc)) {
          if(_LIB_VERSION == _SVID_) {
            (void) WRITE2(&quot;acos: DOMAIN error\n&quot;, 19);
          }
          errno = EDOM;
        }
        break;
        case 2:
        /* asin(|x|&gt;1) */
        exc.type = DOMAIN;
        exc.name = &quot;asin&quot;;
        exc.retval = zero;
        if(_LIB_VERSION == _POSIX_)
          errno = EDOM;
        else if (!matherr(&amp;exc)) {
          if(_LIB_VERSION == _SVID_) {
                (void) WRITE2(&quot;asin: DOMAIN error\n&quot;, 19);
          }
          errno = EDOM;
        }
        break;
        case 3:
        /* atan2(+-0,+-0) */
        exc.arg1 = y;
        exc.arg2 = x;
        exc.type = DOMAIN;
        exc.name = &quot;atan2&quot;;
        exc.retval = zero;
        if(_LIB_VERSION == _POSIX_)
          errno = EDOM;
        else if (!matherr(&amp;exc)) {
          if(_LIB_VERSION == _SVID_) {
            (void) WRITE2(&quot;atan2: DOMAIN error\n&quot;, 20);
              }
          errno = EDOM;
        }
        break;
        case 4:
        /* hypot(finite,finite) overflow */
        exc.type = OVERFLOW;
        exc.name = &quot;hypot&quot;;
        if (_LIB_VERSION == _SVID_)
          exc.retval = HUGE;
        else
          exc.retval = HUGE_VAL;
        if (_LIB_VERSION == _POSIX_)
          errno = ERANGE;
        else if (!matherr(&amp;exc)) {
            errno = ERANGE;
        }
        break;
        case 5:
        /* cosh(finite) overflow */
        exc.type = OVERFLOW;
        exc.name = &quot;cosh&quot;;
        if (_LIB_VERSION == _SVID_)
          exc.retval = HUGE;
        else
          exc.retval = HUGE_VAL;
        if (_LIB_VERSION == _POSIX_)
          errno = ERANGE;
        else if (!matherr(&amp;exc)) {
            errno = ERANGE;
        }
        break;
        case 6:
        /* exp(finite) overflow */
        exc.type = OVERFLOW;
        exc.name = &quot;exp&quot;;
        if (_LIB_VERSION == _SVID_)
          exc.retval = HUGE;
        else
          exc.retval = HUGE_VAL;
        if (_LIB_VERSION == _POSIX_)
          errno = ERANGE;
        else if (!matherr(&amp;exc)) {
            errno = ERANGE;
        }
        break;
        case 7:
        /* exp(finite) underflow */
        exc.type = UNDERFLOW;
        exc.name = &quot;exp&quot;;
        exc.retval = zero;
        if (_LIB_VERSION == _POSIX_)
          errno = ERANGE;
        else if (!matherr(&amp;exc)) {
            errno = ERANGE;
        }
        break;
        case 8:
        /* y0(0) = -inf */
        exc.type = DOMAIN;  /* should be SING for IEEE */
        exc.name = &quot;y0&quot;;
        if (_LIB_VERSION == _SVID_)
          exc.retval = -HUGE;
        else
          exc.retval = -HUGE_VAL;
        if (_LIB_VERSION == _POSIX_)
          errno = EDOM;
        else if (!matherr(&amp;exc)) {
          if (_LIB_VERSION == _SVID_) {
            (void) WRITE2(&quot;y0: DOMAIN error\n&quot;, 17);
              }
          errno = EDOM;
        }
        break;
        case 9:
        /* y0(x&lt;0) = NaN */
        exc.type = DOMAIN;
        exc.name = &quot;y0&quot;;
        if (_LIB_VERSION == _SVID_)
          exc.retval = -HUGE;
        else
          exc.retval = -HUGE_VAL;
        if (_LIB_VERSION == _POSIX_)
          errno = EDOM;
        else if (!matherr(&amp;exc)) {
          if (_LIB_VERSION == _SVID_) {
            (void) WRITE2(&quot;y0: DOMAIN error\n&quot;, 17);
              }
          errno = EDOM;
        }
        break;
        case 10:
        /* y1(0) = -inf */
        exc.type = DOMAIN;  /* should be SING for IEEE */
        exc.name = &quot;y1&quot;;
        if (_LIB_VERSION == _SVID_)
          exc.retval = -HUGE;
        else
          exc.retval = -HUGE_VAL;
        if (_LIB_VERSION == _POSIX_)
          errno = EDOM;
        else if (!matherr(&amp;exc)) {
          if (_LIB_VERSION == _SVID_) {
            (void) WRITE2(&quot;y1: DOMAIN error\n&quot;, 17);
              }
          errno = EDOM;
        }
        break;
        case 11:
        /* y1(x&lt;0) = NaN */
        exc.type = DOMAIN;
        exc.name = &quot;y1&quot;;
        if (_LIB_VERSION == _SVID_)
          exc.retval = -HUGE;
        else
          exc.retval = -HUGE_VAL;
        if (_LIB_VERSION == _POSIX_)
          errno = EDOM;
        else if (!matherr(&amp;exc)) {
          if (_LIB_VERSION == _SVID_) {
            (void) WRITE2(&quot;y1: DOMAIN error\n&quot;, 17);
              }
          errno = EDOM;
        }
        break;
        case 12:
        /* yn(n,0) = -inf */
        exc.type = DOMAIN;  /* should be SING for IEEE */
        exc.name = &quot;yn&quot;;
        if (_LIB_VERSION == _SVID_)
          exc.retval = -HUGE;
        else
          exc.retval = -HUGE_VAL;
        if (_LIB_VERSION == _POSIX_)
          errno = EDOM;
        else if (!matherr(&amp;exc)) {
          if (_LIB_VERSION == _SVID_) {
            (void) WRITE2(&quot;yn: DOMAIN error\n&quot;, 17);
              }
          errno = EDOM;
        }
        break;
        case 13:
        /* yn(x&lt;0) = NaN */
        exc.type = DOMAIN;
        exc.name = &quot;yn&quot;;
        if (_LIB_VERSION == _SVID_)
          exc.retval = -HUGE;
        else
          exc.retval = -HUGE_VAL;
        if (_LIB_VERSION == _POSIX_)
          errno = EDOM;
        else if (!matherr(&amp;exc)) {
          if (_LIB_VERSION == _SVID_) {
            (void) WRITE2(&quot;yn: DOMAIN error\n&quot;, 17);
              }
          errno = EDOM;
        }
        break;
        case 14:
        /* lgamma(finite) overflow */
        exc.type = OVERFLOW;
        exc.name = &quot;lgamma&quot;;
                if (_LIB_VERSION == _SVID_)
                  exc.retval = HUGE;
                else
                  exc.retval = HUGE_VAL;
                if (_LIB_VERSION == _POSIX_)
            errno = ERANGE;
                else if (!matherr(&amp;exc)) {
                        errno = ERANGE;
        }
        break;
        case 15:
        /* lgamma(-integer) or lgamma(0) */
        exc.type = SING;
        exc.name = &quot;lgamma&quot;;
                if (_LIB_VERSION == _SVID_)
                  exc.retval = HUGE;
                else
                  exc.retval = HUGE_VAL;
        if (_LIB_VERSION == _POSIX_)
          errno = EDOM;
        else if (!matherr(&amp;exc)) {
          if (_LIB_VERSION == _SVID_) {
            (void) WRITE2(&quot;lgamma: SING error\n&quot;, 19);
              }
          errno = EDOM;
        }
        break;
        case 16:
        /* log(0) */
        exc.type = SING;
        exc.name = &quot;log&quot;;
        if (_LIB_VERSION == _SVID_)
          exc.retval = -HUGE;
        else
          exc.retval = -HUGE_VAL;
        if (_LIB_VERSION == _POSIX_)
          errno = ERANGE;
        else if (!matherr(&amp;exc)) {
          if (_LIB_VERSION == _SVID_) {
            (void) WRITE2(&quot;log: SING error\n&quot;, 16);
              }
          errno = EDOM;
        }
        break;
        case 17:
        /* log(x&lt;0) */
        exc.type = DOMAIN;
        exc.name = &quot;log&quot;;
        if (_LIB_VERSION == _SVID_)
          exc.retval = -HUGE;
        else
          exc.retval = -HUGE_VAL;
        if (_LIB_VERSION == _POSIX_)
          errno = EDOM;
        else if (!matherr(&amp;exc)) {
          if (_LIB_VERSION == _SVID_) {
            (void) WRITE2(&quot;log: DOMAIN error\n&quot;, 18);
              }
          errno = EDOM;
        }
        break;
        case 18:
        /* log10(0) */
        exc.type = SING;
        exc.name = &quot;log10&quot;;
        if (_LIB_VERSION == _SVID_)
          exc.retval = -HUGE;
        else
          exc.retval = -HUGE_VAL;
        if (_LIB_VERSION == _POSIX_)
          errno = ERANGE;
        else if (!matherr(&amp;exc)) {
          if (_LIB_VERSION == _SVID_) {
            (void) WRITE2(&quot;log10: SING error\n&quot;, 18);
              }
          errno = EDOM;
        }
        break;
        case 19:
        /* log10(x&lt;0) */
        exc.type = DOMAIN;
        exc.name = &quot;log10&quot;;
        if (_LIB_VERSION == _SVID_)
          exc.retval = -HUGE;
        else
          exc.retval = -HUGE_VAL;
        if (_LIB_VERSION == _POSIX_)
          errno = EDOM;
        else if (!matherr(&amp;exc)) {
          if (_LIB_VERSION == _SVID_) {
            (void) WRITE2(&quot;log10: DOMAIN error\n&quot;, 20);
              }
          errno = EDOM;
        }
        break;
        case 20:
        /* pow(0.0,0.0) */
        /* error only if _LIB_VERSION == _SVID_ */
        exc.type = DOMAIN;
        exc.name = &quot;pow&quot;;
        exc.retval = zero;
        if (_LIB_VERSION != _SVID_) exc.retval = 1.0;
        else if (!matherr(&amp;exc)) {
            (void) WRITE2(&quot;pow(0,0): DOMAIN error\n&quot;, 23);
            errno = EDOM;
        }
        break;
        case 21:
        /* pow(x,y) overflow */
        exc.type = OVERFLOW;
        exc.name = &quot;pow&quot;;
        if (_LIB_VERSION == _SVID_) {
          exc.retval = HUGE;
          y *= 0.5;
          if(x&lt;zero&amp;&amp;rint(y)!=y) exc.retval = -HUGE;
        } else {
          exc.retval = HUGE_VAL;
          y *= 0.5;
          if(x&lt;zero&amp;&amp;rint(y)!=y) exc.retval = -HUGE_VAL;
        }
        if (_LIB_VERSION == _POSIX_)
          errno = ERANGE;
        else if (!matherr(&amp;exc)) {
            errno = ERANGE;
        }
        break;
        case 22:
        /* pow(x,y) underflow */
        exc.type = UNDERFLOW;
        exc.name = &quot;pow&quot;;
        exc.retval =  zero;
        if (_LIB_VERSION == _POSIX_)
          errno = ERANGE;
        else if (!matherr(&amp;exc)) {
            errno = ERANGE;
        }
        break;
        case 23:
        /* 0**neg */
        exc.type = DOMAIN;
        exc.name = &quot;pow&quot;;
        if (_LIB_VERSION == _SVID_) 
          exc.retval = zero;
        else
          exc.retval = -HUGE_VAL;
        if (_LIB_VERSION == _POSIX_)
          errno = EDOM;
        else if (!matherr(&amp;exc)) {
          if (_LIB_VERSION == _SVID_) {
            (void) WRITE2(&quot;pow(0,neg): DOMAIN error\n&quot;, 25);
              }
          errno = EDOM;
        }
        break;
        case 24:
        /* neg**non-integral */
        exc.type = DOMAIN;
        exc.name = &quot;pow&quot;;
        if (_LIB_VERSION == _SVID_) 
            exc.retval = zero;
        else 
            exc.retval = zero/zero; /* X/Open allow NaN */
        if (_LIB_VERSION == _POSIX_) 
           errno = EDOM;
        else if (!matherr(&amp;exc)) {
          if (_LIB_VERSION == _SVID_) {
            (void) WRITE2(&quot;neg**non-integral: DOMAIN error\n&quot;, 32);
              }
          errno = EDOM;
        }
        break;
        case 25:
        /* sinh(finite) overflow */
        exc.type = OVERFLOW;
        exc.name = &quot;sinh&quot;;
        if (_LIB_VERSION == _SVID_)
          exc.retval = ( (x&gt;zero) ? HUGE : -HUGE);
        else
          exc.retval = ( (x&gt;zero) ? HUGE_VAL : -HUGE_VAL);
        if (_LIB_VERSION == _POSIX_)
          errno = ERANGE;
        else if (!matherr(&amp;exc)) {
            errno = ERANGE;
        }
        break;
        case 26:
        /* sqrt(x&lt;0) */
        exc.type = DOMAIN;
        exc.name = &quot;sqrt&quot;;
        if (_LIB_VERSION == _SVID_)
          exc.retval = zero;
        else
          exc.retval = zero/zero;
        if (_LIB_VERSION == _POSIX_)
          errno = EDOM;
        else if (!matherr(&amp;exc)) {
          if (_LIB_VERSION == _SVID_) {
            (void) WRITE2(&quot;sqrt: DOMAIN error\n&quot;, 19);
              }
          errno = EDOM;
        }
        break;
            case 27:
                /* fmod(x,0) */
                exc.type = DOMAIN;
                exc.name = &quot;fmod&quot;;
                if (_LIB_VERSION == _SVID_)
                    exc.retval = x;
        else
            exc.retval = zero/zero;
                if (_LIB_VERSION == _POSIX_)
                  errno = EDOM;
                else if (!matherr(&amp;exc)) {
                  if (_LIB_VERSION == _SVID_) {
                    (void) WRITE2(&quot;fmod:  DOMAIN error\n&quot;, 20);
                  }
                  errno = EDOM;
                }
                break;
            case 28:
                /* remainder(x,0) */
                exc.type = DOMAIN;
                exc.name = &quot;remainder&quot;;
                exc.retval = zero/zero;
                if (_LIB_VERSION == _POSIX_)
                  errno = EDOM;
                else if (!matherr(&amp;exc)) {
                  if (_LIB_VERSION == _SVID_) {
                    (void) WRITE2(&quot;remainder: DOMAIN error\n&quot;, 24);
                  }
                  errno = EDOM;
                }
                break;
            case 29:
                /* acosh(x&lt;1) */
                exc.type = DOMAIN;
                exc.name = &quot;acosh&quot;;
                exc.retval = zero/zero;
                if (_LIB_VERSION == _POSIX_)
                  errno = EDOM;
                else if (!matherr(&amp;exc)) {
                  if (_LIB_VERSION == _SVID_) {
                    (void) WRITE2(&quot;acosh: DOMAIN error\n&quot;, 20);
                  }
                  errno = EDOM;
                }
                break;
            case 30:
                /* atanh(|x|&gt;1) */
                exc.type = DOMAIN;
                exc.name = &quot;atanh&quot;;
                exc.retval = zero/zero;
                if (_LIB_VERSION == _POSIX_)
                  errno = EDOM;
                else if (!matherr(&amp;exc)) {
                  if (_LIB_VERSION == _SVID_) {
                    (void) WRITE2(&quot;atanh: DOMAIN error\n&quot;, 20);
                  }
                  errno = EDOM;
                }
                break;
            case 31:
                /* atanh(|x|=1) */
                exc.type = SING;
                exc.name = &quot;atanh&quot;;
        exc.retval = x/zero;    /* sign(x)*inf */
                if (_LIB_VERSION == _POSIX_)
                  errno = EDOM;
                else if (!matherr(&amp;exc)) {
                  if (_LIB_VERSION == _SVID_) {
                    (void) WRITE2(&quot;atanh: SING error\n&quot;, 18);
                  }
                  errno = EDOM;
                }
                break;
        case 32:
        /* scalb overflow; SVID also returns +-HUGE_VAL */
        exc.type = OVERFLOW;
        exc.name = &quot;scalb&quot;;
        exc.retval = x &gt; zero ? HUGE_VAL : -HUGE_VAL;
        if (_LIB_VERSION == _POSIX_)
          errno = ERANGE;
        else if (!matherr(&amp;exc)) {
            errno = ERANGE;
        }
        break;
        case 33:
        /* scalb underflow */
        exc.type = UNDERFLOW;
        exc.name = &quot;scalb&quot;;
        exc.retval = copysign(zero,x);
        if (_LIB_VERSION == _POSIX_)
          errno = ERANGE;
        else if (!matherr(&amp;exc)) {
            errno = ERANGE;
        }
        break;
        case 34:
        /* j0(|x|&gt;X_TLOSS) */
                exc.type = TLOSS;
                exc.name = &quot;j0&quot;;
                exc.retval = zero;
                if (_LIB_VERSION == _POSIX_)
                        errno = ERANGE;
                else if (!matherr(&amp;exc)) {
                        if (_LIB_VERSION == _SVID_) {
                                (void) WRITE2(exc.name, 2);
                                (void) WRITE2(&quot;: TLOSS error\n&quot;, 14);
                        }
                        errno = ERANGE;
                }        
        break;
        case 35:
        /* y0(x&gt;X_TLOSS) */
                exc.type = TLOSS;
                exc.name = &quot;y0&quot;;
                exc.retval = zero;
                if (_LIB_VERSION == _POSIX_)
                        errno = ERANGE;
                else if (!matherr(&amp;exc)) {
                        if (_LIB_VERSION == _SVID_) {
                                (void) WRITE2(exc.name, 2);
                                (void) WRITE2(&quot;: TLOSS error\n&quot;, 14);
                        }
                        errno = ERANGE;
                }        
        break;
        case 36:
        /* j1(|x|&gt;X_TLOSS) */
                exc.type = TLOSS;
                exc.name = &quot;j1&quot;;
                exc.retval = zero;
                if (_LIB_VERSION == _POSIX_)
                        errno = ERANGE;
                else if (!matherr(&amp;exc)) {
                        if (_LIB_VERSION == _SVID_) {
                                (void) WRITE2(exc.name, 2);
                                (void) WRITE2(&quot;: TLOSS error\n&quot;, 14);
                        }
                        errno = ERANGE;
                }        
        break;
        case 37:
        /* y1(x&gt;X_TLOSS) */
                exc.type = TLOSS;
                exc.name = &quot;y1&quot;;
                exc.retval = zero;
                if (_LIB_VERSION == _POSIX_)
                        errno = ERANGE;
                else if (!matherr(&amp;exc)) {
                        if (_LIB_VERSION == _SVID_) {
                                (void) WRITE2(exc.name, 2);
                                (void) WRITE2(&quot;: TLOSS error\n&quot;, 14);
                        }
                        errno = ERANGE;
                }        
        break;
        case 38:
        /* jn(|x|&gt;X_TLOSS) */
                exc.type = TLOSS;
                exc.name = &quot;jn&quot;;
                exc.retval = zero;
                if (_LIB_VERSION == _POSIX_)
                        errno = ERANGE;
                else if (!matherr(&amp;exc)) {
                        if (_LIB_VERSION == _SVID_) {
                                (void) WRITE2(exc.name, 2);
                                (void) WRITE2(&quot;: TLOSS error\n&quot;, 14);
                        }
                        errno = ERANGE;
                }        
        break;
        case 39:
        /* yn(x&gt;X_TLOSS) */
                exc.type = TLOSS;
                exc.name = &quot;yn&quot;;
                exc.retval = zero;
                if (_LIB_VERSION == _POSIX_)
                        errno = ERANGE;
                else if (!matherr(&amp;exc)) {
                        if (_LIB_VERSION == _SVID_) {
                                (void) WRITE2(exc.name, 2);
                                (void) WRITE2(&quot;: TLOSS error\n&quot;, 14);
                        }
                        errno = ERANGE;
                }        
        break;
        case 40:
        /* gamma(finite) overflow */
        exc.type = OVERFLOW;
        exc.name = &quot;gamma&quot;;
                if (_LIB_VERSION == _SVID_)
                  exc.retval = HUGE;
                else
                  exc.retval = HUGE_VAL;
                if (_LIB_VERSION == _POSIX_)
          errno = ERANGE;
                else if (!matherr(&amp;exc)) {
                  errno = ERANGE;
                }
        break;
        case 41:
        /* gamma(-integer) or gamma(0) */
        exc.type = SING;
        exc.name = &quot;gamma&quot;;
                if (_LIB_VERSION == _SVID_)
                  exc.retval = HUGE;
                else
                  exc.retval = HUGE_VAL;
        if (_LIB_VERSION == _POSIX_)
          errno = EDOM;
        else if (!matherr(&amp;exc)) {
          if (_LIB_VERSION == _SVID_) {
            (void) WRITE2(&quot;gamma: SING error\n&quot;, 18);
              }
          errno = EDOM;
        }
        break;
        case 42:
        /* pow(NaN,0.0) */
        /* error only if _LIB_VERSION == _SVID_ &amp; _XOPEN_ */
        exc.type = DOMAIN;
        exc.name = &quot;pow&quot;;
        exc.retval = x;
        if (_LIB_VERSION == _IEEE_ ||
            _LIB_VERSION == _POSIX_) exc.retval = 1.0;
        else if (!matherr(&amp;exc)) {
            errno = EDOM;
        }
        break;
    }
    return exc.retval; 
}
</code></pre>

<ul>
<li><strong><code>k_tan.c</code>文件</strong></li>
</ul>
<p>```c++/<em> __kernel_tan( x, y, k )
 * kernel tan function on [-pi/4, pi/4], pi/4 ~ 0.7854
 * Input x is assumed to be bounded by ~pi/4 in magnitude.
 * Input y is the tail of x.
 * Input k indicates whether tan (if k = 1) or -1/tan (if k = -1) is returned.
 *
 * Algorithm
 *  1. Since tan(-x) = -tan(x), we need only to consider positive x.
 *  2. if x &lt; 2^-28 (hx&lt;0x3e300000 0), return x with inexact if x!=0.
 *  3. tan(x) is approximated by a odd polynomial of degree 27 on
 *     [0,0.67434]
 *                   3             27
 *      tan(x) ~ x + T1</em>x + ... + T13<em>x
 *     where
 *
 *          |tan(x)         2     4            26   |     -59.2
 *          |----- - (1+T1</em>x +T2<em>x +.... +T13</em>x    )| &lt;= 2
 *          |  x                    |
 *
 *     Note: tan(x+y) = tan(x) + tan'(x)<em>y
 *                ~ tan(x) + (1+x</em>x)<em>y
 *     Therefore, for better accuracy in computing tan(x+y), let
 *           3      2      2       2       2
 *      r = x </em>(T2+x <em>(T3+x </em>(...+x <em>(T12+x </em>T13))))
 *     then
 *                  3    2
 *      tan(x+y) = x + (T1<em>x + (x </em>(r+y)+y))
 *
 *      4. For x in [0.67434,pi/4],  let y = pi/4 - x, then
 *      tan(x) = tan(pi/4-y) = (1-tan(y))/(1+tan(y))
 *             = 1 - 2<em>(tan(y) - (tan(y)^2)/(1+tan(y)))
 </em>/</p>
<h1 id="include-fdlibmh">include "fdlibm.h"</h1>
<p>static const double xxx[] = {
         3.33333333333334091986e-01,    /<em> 3FD55555, 55555563 </em>/
         1.33333333333201242699e-01,    /<em> 3FC11111, 1110FE7A </em>/
         5.39682539762260521377e-02,    /<em> 3FABA1BA, 1BB341FE </em>/
         2.18694882948595424599e-02,    /<em> 3F9664F4, 8406D637 </em>/
         8.86323982359930005737e-03,    /<em> 3F8226E3, E96E8493 </em>/
         3.59207910759131235356e-03,    /<em> 3F6D6D22, C9560328 </em>/
         1.45620945432529025516e-03,    /<em> 3F57DBC8, FEE08315 </em>/
         5.88041240820264096874e-04,    /<em> 3F4344D8, F2F26501 </em>/
         2.46463134818469906812e-04,    /<em> 3F3026F7, 1A8D1068 </em>/
         7.81794442939557092300e-05,    /<em> 3F147E88, A03792A6 </em>/
         7.14072491382608190305e-05,    /<em> 3F12B80F, 32F0A7E9 </em>/
        -1.85586374855275456654e-05,    /<em> BEF375CB, DB605373 </em>/
         2.59073051863633712884e-05,    /<em> 3EFB2A70, 74BF7AD4 </em>/
/<em> one </em>/    1.00000000000000000000e+00,    /<em> 3FF00000, 00000000 </em>/
/<em> pio4 </em>/   7.85398163397448278999e-01,    /<em> 3FE921FB, 54442D18 </em>/
/<em> pio4lo </em>/     3.06161699786838301793e-17 /<em> 3C81A626, 33145C07 </em>/
};</p>
<h1 id="define-one-xxx13">define one xxx[13]</h1>
<h1 id="define-pio4-xxx14">define pio4    xxx[14]</h1>
<h1 id="define-pio4lo-xxx15">define pio4lo  xxx[15]</h1>
<h1 id="define-t-xxx">define T   xxx</h1>
<p>/<em> INDENT ON </em>/</p>
<p>double
__kernel_tan(double x, double y, int iy) {
    double z, r, v, w, s;
    int ix, hx;</p>
<pre><code>hx = __HI(x);       /* high word of x */
ix = hx &amp; 0x7fffffff;           /* high word of |x| */
if (ix &lt; 0x3e300000) {          /* x &lt; 2**-28 */
    if ((int) x == 0) {     /* generate inexact */
        if (((ix | __LO(x)) | (iy + 1)) == 0)
            return one / fabs(x);
        else {
            if (iy == 1)
                return x;
            else {  /* compute -1 / (x+y) carefully */
                double a, t;

                z = w = x + y;
                __LO(z) = 0;
                v = y - (z - x);
                t = a = -one / w;
                __LO(t) = 0;
                s = one + t * z;
                return t + a * (s + t * v);
            }
        }
    }
}
if (ix &gt;= 0x3FE59428) { /* |x| &gt;= 0.6744 */
    if (hx &lt; 0) {
        x = -x;
        y = -y;
    }
    z = pio4 - x;
    w = pio4lo - y;
    x = z + w;
    y = 0.0;
}
z = x * x;
w = z * z;
/*
 * Break x^5*(T[1]+x^2*T[2]+...) into
 * x^5(T[1]+x^4*T[3]+...+x^20*T[11]) +
 * x^5(x^2*(T[2]+x^4*T[4]+...+x^22*[T12]))
 */
r = T[1] + w * (T[3] + w * (T[5] + w * (T[7] + w * (T[9] +
    w * T[11]))));
v = z * (T[2] + w * (T[4] + w * (T[6] + w * (T[8] + w * (T[10] +
    w * T[12])))));
s = z * x;
r = y + z * (s * (r + v) + y);
r += T[0] * s;
w = x + r;
if (ix &gt;= 0x3FE59428) {
    v = (double) iy;
    return (double) (1 - ((hx &gt;&gt; 30) &amp; 2)) *
        (v - 2.0 * (x - (w * w / (w + v) - r)));
}
if (iy == 1)
    return w;
else {
    /*
     * if allow error up to 2 ulp, simply return
     * -1.0 / (x+r) here
     */
    /* compute -1.0 / (x+r) accurately */
    double a, t;
    z = w;
    __LO(z) = 0;
    v = r - (z - x);    /* z+v = r+x */
    t = a = -1.0 / w;   /* a = -1.0/w */
    __LO(t) = 0;
    s = 1.0 + t * z;
    return t + a * (s + t * v);
}
</code></pre>
<p>}</p>
<pre><code>
* **`s_asinh.c`文件**

```c++
/* asinh(x)
 * Method :
 *  Based on 
 *      asinh(x) = sign(x) * log [ |x| + sqrt(x*x+1) ]
 *  we have
 *  asinh(x) := x  if  1+x*x=1,
 *       := sign(x)*(log(x)+ln2)) for large |x|, else
 *       := sign(x)*log(2|x|+1/(|x|+sqrt(x*x+1))) if|x|&gt;2, else
 *       := sign(x)*log1p(|x| + x^2/(1 + sqrt(1+x^2)))  
 */

#include &quot;fdlibm.h&quot;

#ifdef __STDC__
static const double 
#else
static double 
#endif
one =  1.00000000000000000000e+00, /* 0x3FF00000, 0x00000000 */
ln2 =  6.93147180559945286227e-01, /* 0x3FE62E42, 0xFEFA39EF */
huge=  1.00000000000000000000e+300; 

#ifdef __STDC__
    double asinh(double x)
#else
    double asinh(x)
    double x;
#endif
{   
    double t,w;
    int hx,ix;
    hx = __HI(x);
    ix = hx&amp;0x7fffffff;
    if(ix&gt;=0x7ff00000) return x+x;  /* x is inf or NaN */
    if(ix&lt; 0x3e300000) {    /* |x|&lt;2**-28 */
        if(huge+x&gt;one) return x;    /* return x inexact except 0 */
    } 
    if(ix&gt;0x41b00000) { /* |x| &gt; 2**28 */
        w = __ieee754_log(fabs(x))+ln2;
    } else if (ix&gt;0x40000000) { /* 2**28 &gt; |x| &gt; 2.0 */
        t = fabs(x);
        w = __ieee754_log(2.0*t+one/(sqrt(x*x+one)+t));
    } else {        /* 2.0 &gt; |x| &gt; 2**-28 */
        t = x*x;
        w =log1p(fabs(x)+t/(one+sqrt(one+t)));
    }
    if(hx&gt;0) return w; else return -w;
}
</code></pre>

<ul>
<li><strong><code>s_atan.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/* atan(x)
 * Method
 *   1. Reduce x to positive by atan(x) = -atan(-x).
 *   2. According to the integer k=4t+0.25 chopped, t=x, the argument
 *      is further reduced to one of the following intervals and the
 *      arctangent of t is evaluated by the corresponding formula:
 *
 *      [0,7/16]      atan(x) = t-t^3*(a1+t^2*(a2+...(a10+t^2*a11)...)
 *      [7/16,11/16]  atan(x) = atan(1/2) + atan( (t-0.5)/(1+t/2) )
 *      [11/16.19/16] atan(x) = atan( 1 ) + atan( (t-1)/(1+t) )
 *      [19/16,39/16] atan(x) = atan(3/2) + atan( (t-1.5)/(1+1.5t) )
 *      [39/16,INF]   atan(x) = atan(INF) + atan( -1/t )
 *
 * Constants:
 * The hexadecimal values are the intended ones for the following 
 * constants. The decimal values may be used, provided that the 
 * compiler will convert from decimal to binary accurately enough 
 * to produce the hexadecimal values shown.
 */

#include &quot;fdlibm.h&quot;

#ifdef __STDC__
static const double atanhi[] = {
#else
static double atanhi[] = {
#endif
  4.63647609000806093515e-01, /* atan(0.5)hi 0x3FDDAC67, 0x0561BB4F */
  7.85398163397448278999e-01, /* atan(1.0)hi 0x3FE921FB, 0x54442D18 */
  9.82793723247329054082e-01, /* atan(1.5)hi 0x3FEF730B, 0xD281F69B */
  1.57079632679489655800e+00, /* atan(inf)hi 0x3FF921FB, 0x54442D18 */
};

#ifdef __STDC__
static const double atanlo[] = {
#else
static double atanlo[] = {
#endif
  2.26987774529616870924e-17, /* atan(0.5)lo 0x3C7A2B7F, 0x222F65E2 */
  3.06161699786838301793e-17, /* atan(1.0)lo 0x3C81A626, 0x33145C07 */
  1.39033110312309984516e-17, /* atan(1.5)lo 0x3C700788, 0x7AF0CBBD */
  6.12323399573676603587e-17, /* atan(inf)lo 0x3C91A626, 0x33145C07 */
};

#ifdef __STDC__
static const double aT[] = {
#else
static double aT[] = {
#endif
  3.33333333333329318027e-01, /* 0x3FD55555, 0x5555550D */
 -1.99999999998764832476e-01, /* 0xBFC99999, 0x9998EBC4 */
  1.42857142725034663711e-01, /* 0x3FC24924, 0x920083FF */
 -1.11111104054623557880e-01, /* 0xBFBC71C6, 0xFE231671 */
  9.09088713343650656196e-02, /* 0x3FB745CD, 0xC54C206E */
 -7.69187620504482999495e-02, /* 0xBFB3B0F2, 0xAF749A6D */
  6.66107313738753120669e-02, /* 0x3FB10D66, 0xA0D03D51 */
 -5.83357013379057348645e-02, /* 0xBFADDE2D, 0x52DEFD9A */
  4.97687799461593236017e-02, /* 0x3FA97B4B, 0x24760DEB */
 -3.65315727442169155270e-02, /* 0xBFA2B444, 0x2C6A6C2F */
  1.62858201153657823623e-02, /* 0x3F90AD3A, 0xE322DA11 */
};

#ifdef __STDC__
    static const double 
#else
    static double 
#endif
one   = 1.0,
huge   = 1.0e300;

#ifdef __STDC__
    double atan(double x)
#else
    double atan(x)
    double x;
#endif
{
    double w,s1,s2,z;
    int ix,hx,id;

    hx = __HI(x);
    ix = hx&amp;0x7fffffff;
    if(ix&gt;=0x44100000) {    /* if |x| &gt;= 2^66 */
        if(ix&gt;0x7ff00000||
        (ix==0x7ff00000&amp;&amp;(__LO(x)!=0)))
        return x+x;     /* NaN */
        if(hx&gt;0) return  atanhi[3]+atanlo[3];
        else     return -atanhi[3]-atanlo[3];
    } if (ix &lt; 0x3fdc0000) {    /* |x| &lt; 0.4375 */
        if (ix &lt; 0x3e200000) {  /* |x| &lt; 2^-29 */
        if(huge+x&gt;one) return x;    /* raise inexact */
        }
        id = -1;
    } else {
    x = fabs(x);
    if (ix &lt; 0x3ff30000) {      /* |x| &lt; 1.1875 */
        if (ix &lt; 0x3fe60000) {  /* 7/16 &lt;=|x|&lt;11/16 */
        id = 0; x = (2.0*x-one)/(2.0+x); 
        } else {            /* 11/16&lt;=|x|&lt; 19/16 */
        id = 1; x  = (x-one)/(x+one); 
        }
    } else {
        if (ix &lt; 0x40038000) {  /* |x| &lt; 2.4375 */
        id = 2; x  = (x-1.5)/(one+1.5*x);
        } else {            /* 2.4375 &lt;= |x| &lt; 2^66 */
        id = 3; x  = -1.0/x;
        }
    }}
    /* end of argument reduction */
    z = x*x;
    w = z*z;
    /* break sum from i=0 to 10 aT[i]z**(i+1) into odd and even poly */
    s1 = z*(aT[0]+w*(aT[2]+w*(aT[4]+w*(aT[6]+w*(aT[8]+w*aT[10])))));
    s2 = w*(aT[1]+w*(aT[3]+w*(aT[5]+w*(aT[7]+w*aT[9]))));
    if (id&lt;0) return x - x*(s1+s2);
    else {
        z = atanhi[id] - ((x*(s1+s2) - atanlo[id]) - x);
        return (hx&lt;0)? -z:z;
    }
}
</code></pre>

<ul>
<li><strong><code>s_cbrt.c</code>文件</strong></li>
</ul>
<pre><code class="c++">#include &quot;fdlibm.h&quot;

/* cbrt(x)
 * Return cube root of x
 */
#ifdef __STDC__
static const unsigned 
#else
static unsigned 
#endif
    B1 = 715094163, /* B1 = (682-0.03306235651)*2**20 */
    B2 = 696219795; /* B2 = (664-0.03306235651)*2**20 */

#ifdef __STDC__
static const double
#else
static double
#endif
C =  5.42857142857142815906e-01, /* 19/35     = 0x3FE15F15, 0xF15F15F1 */
D = -7.05306122448979611050e-01, /* -864/1225 = 0xBFE691DE, 0x2532C834 */
E =  1.41428571428571436819e+00, /* 99/70     = 0x3FF6A0EA, 0x0EA0EA0F */
F =  1.60714285714285720630e+00, /* 45/28     = 0x3FF9B6DB, 0x6DB6DB6E */
G =  3.57142857142857150787e-01; /* 5/14      = 0x3FD6DB6D, 0xB6DB6DB7 */

#ifdef __STDC__
    double cbrt(double x) 
#else
    double cbrt(x) 
    double x;
#endif
{
    int hx;
    double r,s,t=0.0,w;
    unsigned sign;


    hx = __HI(x);       /* high word of x */
    sign=hx&amp;0x80000000;         /* sign= sign(x) */
    hx  ^=sign;
    if(hx&gt;=0x7ff00000) return(x+x); /* cbrt(NaN,INF) is itself */
    if((hx|__LO(x))==0) 
        return(x);      /* cbrt(0) is itself */

    __HI(x) = hx;   /* x &lt;- |x| */
    /* rough cbrt to 5 bits */
    if(hx&lt;0x00100000)       /* subnormal number */
      {__HI(t)=0x43500000;      /* set t= 2**54 */
       t*=x; __HI(t)=__HI(t)/3+B2;
      }
    else
      __HI(t)=hx/3+B1;  


    /* new cbrt to 23 bits, may be implemented in single precision */
    r=t*t/x;
    s=C+r*t;
    t*=G+F/(s+E+D/s);   

    /* chopped to 20 bits and make it larger than cbrt(x) */ 
    __LO(t)=0; __HI(t)+=0x00000001;


    /* one step newton iteration to 53 bits with error less than 0.667 ulps */
    s=t*t;      /* t*t is exact */
    r=x/s;
    w=t+t;
    r=(r-t)/(w+r);  /* r-s is exact */
    t=t+t*r;

    /* retore the sign bit */
    __HI(t) |= sign;
    return(t);
}
</code></pre>

<ul>
<li><strong><code>s_ceil.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/*
 * ceil(x)
 * Return x rounded toward -inf to integral value
 * Method:
 *  Bit twiddling.
 * Exception:
 *  Inexact flag raised if x not equal to ceil(x).
 */

#include &quot;fdlibm.h&quot;

#ifdef __STDC__
static const double huge = 1.0e300;
#else
static double huge = 1.0e300;
#endif

#ifdef __STDC__
    double ceil(double x)
#else
    double ceil(x)
    double x;
#endif
{
    int i0,i1,j0;
    unsigned i,j;
    i0 =  __HI(x);
    i1 =  __LO(x);
    j0 = ((i0&gt;&gt;20)&amp;0x7ff)-0x3ff;
    if(j0&lt;20) {
        if(j0&lt;0) {  /* raise inexact if x != 0 */
        if(huge+x&gt;0.0) {/* return 0*sign(x) if |x|&lt;1 */
            if(i0&lt;0) {i0=0x80000000;i1=0;} 
            else if((i0|i1)!=0) { i0=0x3ff00000;i1=0;}
        }
        } else {
        i = (0x000fffff)&gt;&gt;j0;
        if(((i0&amp;i)|i1)==0) return x; /* x is integral */
        if(huge+x&gt;0.0) {    /* raise inexact flag */
            if(i0&gt;0) i0 += (0x00100000)&gt;&gt;j0;
            i0 &amp;= (~i); i1=0;
        }
        }
    } else if (j0&gt;51) {
        if(j0==0x400) return x+x;   /* inf or NaN */
        else return x;      /* x is integral */
    } else {
        i = ((unsigned)(0xffffffff))&gt;&gt;(j0-20);
        if((i1&amp;i)==0) return x; /* x is integral */
        if(huge+x&gt;0.0) {        /* raise inexact flag */
        if(i0&gt;0) {
            if(j0==20) i0+=1; 
            else {
            j = i1 + (1&lt;&lt;(52-j0));
            if(j&lt;i1) i0+=1; /* got a carry */
            i1 = j;
            }
        }
        i1 &amp;= (~i);
        }
    }
    __HI(x) = i0;
    __LO(x) = i1;
    return x;
}
</code></pre>

<ul>
<li><strong><code>s_copysign.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/*
 * copysign(double x, double y)
 * copysign(x,y) returns a value with the magnitude of x and
 * with the sign bit of y.
 */

#include &quot;fdlibm.h&quot;

#ifdef __STDC__
    double copysign(double x, double y)
#else
    double copysign(x,y)
    double x,y;
#endif
{
    __HI(x) = (__HI(x)&amp;0x7fffffff)|(__HI(y)&amp;0x80000000);
        return x;
}
</code></pre>

<ul>
<li><strong><code>s_cos.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/* cos(x)
 * Return cosine function of x.
 *
 * kernel function:
 *  __kernel_sin        ... sine function on [-pi/4,pi/4]
 *  __kernel_cos        ... cosine function on [-pi/4,pi/4]
 *  __ieee754_rem_pio2  ... argument reduction routine
 *
 * Method.
 *      Let S,C and T denote the sin, cos and tan respectively on 
 *  [-PI/4, +PI/4]. Reduce the argument x to y1+y2 = x-k*pi/2 
 *  in [-pi/4 , +pi/4], and let n = k mod 4.
 *  We have
 *
 *          n        sin(x)      cos(x)        tan(x)
 *     ----------------------------------------------------------
 *      0          S       C         T
 *      1          C      -S        -1/T
 *      2         -S      -C         T
 *      3         -C       S        -1/T
 *     ----------------------------------------------------------
 *
 * Special cases:
 *      Let trig be any of sin, cos, or tan.
 *      trig(+-INF)  is NaN, with signals;
 *      trig(NaN)    is that NaN;
 *
 * Accuracy:
 *  TRIG(x) returns trig(x) nearly rounded 
 */

#include &quot;fdlibm.h&quot;

#ifdef __STDC__
    double cos(double x)
#else
    double cos(x)
    double x;
#endif
{
    double y[2],z=0.0;
    int n, ix;

    /* High word of x. */
    ix = __HI(x);

    /* |x| ~&lt; pi/4 */
    ix &amp;= 0x7fffffff;
    if(ix &lt;= 0x3fe921fb) return __kernel_cos(x,z);

    /* cos(Inf or NaN) is NaN */
    else if (ix&gt;=0x7ff00000) return x-x;

    /* argument reduction needed */
    else {
        n = __ieee754_rem_pio2(x,y);
        switch(n&amp;3) {
        case 0: return  __kernel_cos(y[0],y[1]);
        case 1: return -__kernel_sin(y[0],y[1],1);
        case 2: return -__kernel_cos(y[0],y[1]);
        default:
                return  __kernel_sin(y[0],y[1],1);
        }
    }
}
</code></pre>

<ul>
<li><strong><code>s_erf.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/* double erf(double x)
 * double erfc(double x)
 *               x
 *            2      |\
 *     erf(x)  =  ---------  | exp(-t*t)dt
 *         sqrt(pi) \| 
 *               0
 *
 *     erfc(x) =  1-erf(x)
 *  Note that 
 *      erf(-x) = -erf(x)
 *      erfc(-x) = 2 - erfc(x)
 *
 * Method:
 *  1. For |x| in [0, 0.84375]
 *      erf(x)  = x + x*R(x^2)
 *          erfc(x) = 1 - erf(x)           if x in [-.84375,0.25]
 *                  = 0.5 + ((0.5-x)-x*R)  if x in [0.25,0.84375]
 *     where R = P/Q where P is an odd poly of degree 8 and
 *     Q is an odd poly of degree 10.
 *                       -57.90
 *          | R - (erf(x)-x)/x | &lt;= 2
 *  
 *
 *     Remark. The formula is derived by noting
 *          erf(x) = (2/sqrt(pi))*(x - x^3/3 + x^5/10 - x^7/42 + ....)
 *     and that
 *          2/sqrt(pi) = 1.128379167095512573896158903121545171688
 *     is close to one. The interval is chosen because the fix
 *     point of erf(x) is near 0.6174 (i.e., erf(x)=x when x is
 *     near 0.6174), and by some experiment, 0.84375 is chosen to
 *     guarantee the error is less than one ulp for erf.
 *
 *      2. For |x| in [0.84375,1.25], let s = |x| - 1, and
 *         c = 0.84506291151 rounded to single (24 bits)
 *          erf(x)  = sign(x) * (c  + P1(s)/Q1(s))
 *          erfc(x) = (1-c)  - P1(s)/Q1(s) if x &gt; 0
 *            1+(c+P1(s)/Q1(s))    if x &lt; 0
 *          |P1/Q1 - (erf(|x|)-c)| &lt;= 2**-59.06
 *     Remark: here we use the taylor series expansion at x=1.
 *      erf(1+s) = erf(1) + s*Poly(s)
 *           = 0.845.. + P1(s)/Q1(s)
 *     That is, we use rational approximation to approximate
 *          erf(1+s) - (c = (single)0.84506291151)
 *     Note that |P1/Q1|&lt; 0.078 for x in [0.84375,1.25]
 *     where 
 *      P1(s) = degree 6 poly in s
 *      Q1(s) = degree 6 poly in s
 *
 *      3. For x in [1.25,1/0.35(~2.857143)], 
 *          erfc(x) = (1/x)*exp(-x*x-0.5625+R1/S1)
 *          erf(x)  = 1 - erfc(x)
 *     where 
 *      R1(z) = degree 7 poly in z, (z=1/x^2)
 *      S1(z) = degree 8 poly in z
 *
 *      4. For x in [1/0.35,28]
 *          erfc(x) = (1/x)*exp(-x*x-0.5625+R2/S2) if x &gt; 0
 *          = 2.0 - (1/x)*exp(-x*x-0.5625+R2/S2) if -6&lt;x&lt;0
 *          = 2.0 - tiny        (if x &lt;= -6)
 *          erf(x)  = sign(x)*(1.0 - erfc(x)) if x &lt; 6, else
 *          erf(x)  = sign(x)*(1.0 - tiny)
 *     where
 *      R2(z) = degree 6 poly in z, (z=1/x^2)
 *      S2(z) = degree 7 poly in z
 *
 *      Note1:
 *     To compute exp(-x*x-0.5625+R/S), let s be a single
 *     precision number and s := x; then
 *      -x*x = -s*s + (s-x)*(s+x)
 *          exp(-x*x-0.5626+R/S) = 
 *          exp(-s*s-0.5625)*exp((s-x)*(s+x)+R/S);
 *      Note2:
 *     Here 4 and 5 make use of the asymptotic series
 *            exp(-x*x)
 *      erfc(x) ~ ---------- * ( 1 + Poly(1/x^2) )
 *            x*sqrt(pi)
 *     We use rational approximation to approximate
 *          g(s)=f(1/x^2) = log(erfc(x)*x) - x*x + 0.5625
 *     Here is the error bound for R1/S1 and R2/S2
 *          |R1/S1 - f(x)|  &lt; 2**(-62.57)
 *          |R2/S2 - f(x)|  &lt; 2**(-61.52)
 *
 *      5. For inf &gt; x &gt;= 28
 *          erf(x)  = sign(x) *(1 - tiny)  (raise inexact)
 *          erfc(x) = tiny*tiny (raise underflow) if x &gt; 0
 *          = 2 - tiny if x&lt;0
 *
 *      7. Special case:
 *          erf(0)  = 0, erf(inf)  = 1, erf(-inf) = -1,
 *          erfc(0) = 1, erfc(inf) = 0, erfc(-inf) = 2, 
 *      erfc/erf(NaN) is NaN
 */


#include &quot;fdlibm.h&quot;

#ifdef __STDC__
static const double
#else
static double
#endif
tiny        = 1e-300,
half=  5.00000000000000000000e-01, /* 0x3FE00000, 0x00000000 */
one =  1.00000000000000000000e+00, /* 0x3FF00000, 0x00000000 */
two =  2.00000000000000000000e+00, /* 0x40000000, 0x00000000 */
    /* c = (float)0.84506291151 */
erx =  8.45062911510467529297e-01, /* 0x3FEB0AC1, 0x60000000 */
/*
 * Coefficients for approximation to  erf on [0,0.84375]
 */
efx =  1.28379167095512586316e-01, /* 0x3FC06EBA, 0x8214DB69 */
efx8=  1.02703333676410069053e+00, /* 0x3FF06EBA, 0x8214DB69 */
pp0  =  1.28379167095512558561e-01, /* 0x3FC06EBA, 0x8214DB68 */
pp1  = -3.25042107247001499370e-01, /* 0xBFD4CD7D, 0x691CB913 */
pp2  = -2.84817495755985104766e-02, /* 0xBF9D2A51, 0xDBD7194F */
pp3  = -5.77027029648944159157e-03, /* 0xBF77A291, 0x236668E4 */
pp4  = -2.37630166566501626084e-05, /* 0xBEF8EAD6, 0x120016AC */
qq1  =  3.97917223959155352819e-01, /* 0x3FD97779, 0xCDDADC09 */
qq2  =  6.50222499887672944485e-02, /* 0x3FB0A54C, 0x5536CEBA */
qq3  =  5.08130628187576562776e-03, /* 0x3F74D022, 0xC4D36B0F */
qq4  =  1.32494738004321644526e-04, /* 0x3F215DC9, 0x221C1A10 */
qq5  = -3.96022827877536812320e-06, /* 0xBED09C43, 0x42A26120 */
/*
 * Coefficients for approximation to  erf  in [0.84375,1.25] 
 */
pa0  = -2.36211856075265944077e-03, /* 0xBF6359B8, 0xBEF77538 */
pa1  =  4.14856118683748331666e-01, /* 0x3FDA8D00, 0xAD92B34D */
pa2  = -3.72207876035701323847e-01, /* 0xBFD7D240, 0xFBB8C3F1 */
pa3  =  3.18346619901161753674e-01, /* 0x3FD45FCA, 0x805120E4 */
pa4  = -1.10894694282396677476e-01, /* 0xBFBC6398, 0x3D3E28EC */
pa5  =  3.54783043256182359371e-02, /* 0x3FA22A36, 0x599795EB */
pa6  = -2.16637559486879084300e-03, /* 0xBF61BF38, 0x0A96073F */
qa1  =  1.06420880400844228286e-01, /* 0x3FBB3E66, 0x18EEE323 */
qa2  =  5.40397917702171048937e-01, /* 0x3FE14AF0, 0x92EB6F33 */
qa3  =  7.18286544141962662868e-02, /* 0x3FB2635C, 0xD99FE9A7 */
qa4  =  1.26171219808761642112e-01, /* 0x3FC02660, 0xE763351F */
qa5  =  1.36370839120290507362e-02, /* 0x3F8BEDC2, 0x6B51DD1C */
qa6  =  1.19844998467991074170e-02, /* 0x3F888B54, 0x5735151D */
/*
 * Coefficients for approximation to  erfc in [1.25,1/0.35]
 */
ra0  = -9.86494403484714822705e-03, /* 0xBF843412, 0x600D6435 */
ra1  = -6.93858572707181764372e-01, /* 0xBFE63416, 0xE4BA7360 */
ra2  = -1.05586262253232909814e+01, /* 0xC0251E04, 0x41B0E726 */
ra3  = -6.23753324503260060396e+01, /* 0xC04F300A, 0xE4CBA38D */
ra4  = -1.62396669462573470355e+02, /* 0xC0644CB1, 0x84282266 */
ra5  = -1.84605092906711035994e+02, /* 0xC067135C, 0xEBCCABB2 */
ra6  = -8.12874355063065934246e+01, /* 0xC0545265, 0x57E4D2F2 */
ra7  = -9.81432934416914548592e+00, /* 0xC023A0EF, 0xC69AC25C */
sa1  =  1.96512716674392571292e+01, /* 0x4033A6B9, 0xBD707687 */
sa2  =  1.37657754143519042600e+02, /* 0x4061350C, 0x526AE721 */
sa3  =  4.34565877475229228821e+02, /* 0x407B290D, 0xD58A1A71 */
sa4  =  6.45387271733267880336e+02, /* 0x40842B19, 0x21EC2868 */
sa5  =  4.29008140027567833386e+02, /* 0x407AD021, 0x57700314 */
sa6  =  1.08635005541779435134e+02, /* 0x405B28A3, 0xEE48AE2C */
sa7  =  6.57024977031928170135e+00, /* 0x401A47EF, 0x8E484A93 */
sa8  = -6.04244152148580987438e-02, /* 0xBFAEEFF2, 0xEE749A62 */
/*
 * Coefficients for approximation to  erfc in [1/.35,28]
 */
rb0  = -9.86494292470009928597e-03, /* 0xBF843412, 0x39E86F4A */
rb1  = -7.99283237680523006574e-01, /* 0xBFE993BA, 0x70C285DE */
rb2  = -1.77579549177547519889e+01, /* 0xC031C209, 0x555F995A */
rb3  = -1.60636384855821916062e+02, /* 0xC064145D, 0x43C5ED98 */
rb4  = -6.37566443368389627722e+02, /* 0xC083EC88, 0x1375F228 */
rb5  = -1.02509513161107724954e+03, /* 0xC0900461, 0x6A2E5992 */
rb6  = -4.83519191608651397019e+02, /* 0xC07E384E, 0x9BDC383F */
sb1  =  3.03380607434824582924e+01, /* 0x403E568B, 0x261D5190 */
sb2  =  3.25792512996573918826e+02, /* 0x40745CAE, 0x221B9F0A */
sb3  =  1.53672958608443695994e+03, /* 0x409802EB, 0x189D5118 */
sb4  =  3.19985821950859553908e+03, /* 0x40A8FFB7, 0x688C246A */
sb5  =  2.55305040643316442583e+03, /* 0x40A3F219, 0xCEDF3BE6 */
sb6  =  4.74528541206955367215e+02, /* 0x407DA874, 0xE79FE763 */
sb7  = -2.24409524465858183362e+01; /* 0xC03670E2, 0x42712D62 */

#ifdef __STDC__
    double erf(double x) 
#else
    double erf(x) 
    double x;
#endif
{
    int hx,ix,i;
    double R,S,P,Q,s,y,z,r;
    hx = __HI(x);
    ix = hx&amp;0x7fffffff;
    if(ix&gt;=0x7ff00000) {        /* erf(nan)=nan */
        i = ((unsigned)hx&gt;&gt;31)&lt;&lt;1;
        return (double)(1-i)+one/x; /* erf(+-inf)=+-1 */
    }

    if(ix &lt; 0x3feb0000) {       /* |x|&lt;0.84375 */
        if(ix &lt; 0x3e300000) {   /* |x|&lt;2**-28 */
            if (ix &lt; 0x00800000) 
            return 0.125*(8.0*x+efx8*x);  /*avoid underflow */
        return x + efx*x;
        }
        z = x*x;
        r = pp0+z*(pp1+z*(pp2+z*(pp3+z*pp4)));
        s = one+z*(qq1+z*(qq2+z*(qq3+z*(qq4+z*qq5))));
        y = r/s;
        return x + x*y;
    }
    if(ix &lt; 0x3ff40000) {       /* 0.84375 &lt;= |x| &lt; 1.25 */
        s = fabs(x)-one;
        P = pa0+s*(pa1+s*(pa2+s*(pa3+s*(pa4+s*(pa5+s*pa6)))));
        Q = one+s*(qa1+s*(qa2+s*(qa3+s*(qa4+s*(qa5+s*qa6)))));
        if(hx&gt;=0) return erx + P/Q; else return -erx - P/Q;
    }
    if (ix &gt;= 0x40180000) {     /* inf&gt;|x|&gt;=6 */
        if(hx&gt;=0) return one-tiny; else return tiny-one;
    }
    x = fabs(x);
    s = one/(x*x);
    if(ix&lt; 0x4006DB6E) {    /* |x| &lt; 1/0.35 */
        R=ra0+s*(ra1+s*(ra2+s*(ra3+s*(ra4+s*(
                ra5+s*(ra6+s*ra7))))));
        S=one+s*(sa1+s*(sa2+s*(sa3+s*(sa4+s*(
                sa5+s*(sa6+s*(sa7+s*sa8)))))));
    } else {    /* |x| &gt;= 1/0.35 */
        R=rb0+s*(rb1+s*(rb2+s*(rb3+s*(rb4+s*(
                rb5+s*rb6)))));
        S=one+s*(sb1+s*(sb2+s*(sb3+s*(sb4+s*(
                sb5+s*(sb6+s*sb7))))));
    }
    z  = x;  
    __LO(z) = 0;
    r  =  __ieee754_exp(-z*z-0.5625)*__ieee754_exp((z-x)*(z+x)+R/S);
    if(hx&gt;=0) return one-r/x; else return  r/x-one;
}

#ifdef __STDC__
    double erfc(double x) 
#else
    double erfc(x) 
    double x;
#endif
{
    int hx,ix;
    double R,S,P,Q,s,y,z,r;
    hx = __HI(x);
    ix = hx&amp;0x7fffffff;
    if(ix&gt;=0x7ff00000) {            /* erfc(nan)=nan */
                        /* erfc(+-inf)=0,2 */
        return (double)(((unsigned)hx&gt;&gt;31)&lt;&lt;1)+one/x;
    }

    if(ix &lt; 0x3feb0000) {       /* |x|&lt;0.84375 */
        if(ix &lt; 0x3c700000)     /* |x|&lt;2**-56 */
        return one-x;
        z = x*x;
        r = pp0+z*(pp1+z*(pp2+z*(pp3+z*pp4)));
        s = one+z*(qq1+z*(qq2+z*(qq3+z*(qq4+z*qq5))));
        y = r/s;
        if(hx &lt; 0x3fd00000) {   /* x&lt;1/4 */
        return one-(x+x*y);
        } else {
        r = x*y;
        r += (x-half);
            return half - r ;
        }
    }
    if(ix &lt; 0x3ff40000) {       /* 0.84375 &lt;= |x| &lt; 1.25 */
        s = fabs(x)-one;
        P = pa0+s*(pa1+s*(pa2+s*(pa3+s*(pa4+s*(pa5+s*pa6)))));
        Q = one+s*(qa1+s*(qa2+s*(qa3+s*(qa4+s*(qa5+s*qa6)))));
        if(hx&gt;=0) {
            z  = one-erx; return z - P/Q; 
        } else {
        z = erx+P/Q; return one+z;
        }
    }
    if (ix &lt; 0x403c0000) {      /* |x|&lt;28 */
        x = fabs(x);
        s = one/(x*x);
        if(ix&lt; 0x4006DB6D) {    /* |x| &lt; 1/.35 ~ 2.857143*/
            R=ra0+s*(ra1+s*(ra2+s*(ra3+s*(ra4+s*(
                ra5+s*(ra6+s*ra7))))));
            S=one+s*(sa1+s*(sa2+s*(sa3+s*(sa4+s*(
                sa5+s*(sa6+s*(sa7+s*sa8)))))));
        } else {            /* |x| &gt;= 1/.35 ~ 2.857143 */
        if(hx&lt;0&amp;&amp;ix&gt;=0x40180000) return two-tiny;/* x &lt; -6 */
            R=rb0+s*(rb1+s*(rb2+s*(rb3+s*(rb4+s*(
                rb5+s*rb6)))));
            S=one+s*(sb1+s*(sb2+s*(sb3+s*(sb4+s*(
                sb5+s*(sb6+s*sb7))))));
        }
        z  = x;
        __LO(z)  = 0;
        r  =  __ieee754_exp(-z*z-0.5625)*
            __ieee754_exp((z-x)*(z+x)+R/S);
        if(hx&gt;0) return r/x; else return two-r/x;
    } else {
        if(hx&gt;0) return tiny*tiny; else return two-tiny;
    }
}
</code></pre>

<ul>
<li><strong><code>s_expm1.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/* expm1(x)
 * Returns exp(x)-1, the exponential of x minus 1.
 *
 * Method
 *   1. Argument reduction:
 *  Given x, find r and integer k such that
 *
 *               x = k*ln2 + r,  |r| &lt;= 0.5*ln2 ~ 0.34658  
 *
 *      Here a correction term c will be computed to compensate 
 *  the error in r when rounded to a floating-point number.
 *
 *   2. Approximating expm1(r) by a special rational function on
 *  the interval [0,0.34658]:
 *  Since
 *      r*(exp(r)+1)/(exp(r)-1) = 2+ r^2/6 - r^4/360 + ...
 *  we define R1(r*r) by
 *      r*(exp(r)+1)/(exp(r)-1) = 2+ r^2/6 * R1(r*r)
 *  That is,
 *      R1(r**2) = 6/r *((exp(r)+1)/(exp(r)-1) - 2/r)
 *           = 6/r * ( 1 + 2.0*(1/(exp(r)-1) - 1/r))
 *           = 1 - r^2/60 + r^4/2520 - r^6/100800 + ...
 *      We use a special Remes algorithm on [0,0.347] to generate 
 *  a polynomial of degree 5 in r*r to approximate R1. The 
 *  maximum error of this polynomial approximation is bounded 
 *  by 2**-61. In other words,
 *      R1(z) ~ 1.0 + Q1*z + Q2*z**2 + Q3*z**3 + Q4*z**4 + Q5*z**5
 *  where   Q1  =  -1.6666666666666567384E-2,
 *      Q2  =   3.9682539681370365873E-4,
 *      Q3  =  -9.9206344733435987357E-6,
 *      Q4  =   2.5051361420808517002E-7,
 *      Q5  =  -6.2843505682382617102E-9;
 *      (where z=r*r, and the values of Q1 to Q5 are listed below)
 *  with error bounded by
 *      |                  5           |     -61
 *      | 1.0+Q1*z+...+Q5*z   -  R1(z) | &lt;= 2 
 *      |                              |
 *  
 *  expm1(r) = exp(r)-1 is then computed by the following 
 *  specific way which minimize the accumulation rounding error: 
 *                 2     3
 *                r     r    [ 3 - (R1 + R1*r/2)  ]
 *        expm1(r) = r + --- + --- * [--------------------]
 *                    2     2    [ 6 - r*(3 - R1*r/2) ]
 *  
 *  To compensate the error in the argument reduction, we use
 *      expm1(r+c) = expm1(r) + c + expm1(r)*c 
 *             ~ expm1(r) + c + r*c 
 *  Thus c+r*c will be added in as the correction terms for
 *  expm1(r+c). Now rearrange the term to avoid optimization 
 *  screw up:
 *              (      2                                    2 )
 *              ({  ( r    [ R1 -  (3 - R1*r/2) ]  )  }    r  )
 *   expm1(r+c)~r - ({r*(--- * [--------------------]-c)-c} - --- )
 *                  ({  ( 2    [ 6 - r*(3 - R1*r/2) ]  )  }    2  )
 *                      (                                             )
 *      
 *         = r - E
 *   3. Scale back to obtain expm1(x):
 *  From step 1, we have
 *     expm1(x) = either 2^k*[expm1(r)+1] - 1
 *          = or     2^k*[expm1(r) + (1-2^-k)]
 *   4. Implementation notes:
 *  (A). To save one multiplication, we scale the coefficient Qi
 *       to Qi*2^i, and replace z by (x^2)/2.
 *  (B). To achieve maximum accuracy, we compute expm1(x) by
 *    (i)   if x &lt; -56*ln2, return -1.0, (raise inexact if x!=inf)
 *    (ii)  if k=0, return r-E
 *    (iii) if k=-1, return 0.5*(r-E)-0.5
 *        (iv)  if k=1 if r &lt; -0.25, return 2*((r+0.5)- E)
 *                 else      return  1.0+2.0*(r-E);
 *    (v)   if (k&lt;-2||k&gt;56) return 2^k(1-(E-r)) - 1 (or exp(x)-1)
 *    (vi)  if k &lt;= 20, return 2^k((1-2^-k)-(E-r)), else
 *    (vii) return 2^k(1-((E+2^-k)-r)) 
 *
 * Special cases:
 *  expm1(INF) is INF, expm1(NaN) is NaN;
 *  expm1(-INF) is -1, and
 *  for finite argument, only expm1(0)=0 is exact.
 *
 * Accuracy:
 *  according to an error analysis, the error is always less than
 *  1 ulp (unit in the last place).
 *
 * Misc. info.
 *  For IEEE double 
 *      if x &gt;  7.09782712893383973096e+02 then expm1(x) overflow
 *
 * Constants:
 * The hexadecimal values are the intended ones for the following 
 * constants. The decimal values may be used, provided that the 
 * compiler will convert from decimal to binary accurately enough
 * to produce the hexadecimal values shown.
 */

#include &quot;fdlibm.h&quot;

#ifdef __STDC__
static const double
#else
static double
#endif
one     = 1.0,
huge        = 1.0e+300,
tiny        = 1.0e-300,
o_threshold = 7.09782712893383973096e+02,/* 0x40862E42, 0xFEFA39EF */
ln2_hi      = 6.93147180369123816490e-01,/* 0x3fe62e42, 0xfee00000 */
ln2_lo      = 1.90821492927058770002e-10,/* 0x3dea39ef, 0x35793c76 */
invln2      = 1.44269504088896338700e+00,/* 0x3ff71547, 0x652b82fe */
    /* scaled coefficients related to expm1 */
Q1  =  -3.33333333333331316428e-02, /* BFA11111 111110F4 */
Q2  =   1.58730158725481460165e-03, /* 3F5A01A0 19FE5585 */
Q3  =  -7.93650757867487942473e-05, /* BF14CE19 9EAADBB7 */
Q4  =   4.00821782732936239552e-06, /* 3ED0CFCA 86E65239 */
Q5  =  -2.01099218183624371326e-07; /* BE8AFDB7 6E09C32D */

#ifdef __STDC__
    double expm1(double x)
#else
    double expm1(x)
    double x;
#endif
{
    double y,hi,lo,c,t,e,hxs,hfx,r1;
    int k,xsb;
    unsigned hx;

    hx  = __HI(x);  /* high word of x */
    xsb = hx&amp;0x80000000;        /* sign bit of x */
    if(xsb==0) y=x; else y= -x; /* y = |x| */
    hx &amp;= 0x7fffffff;       /* high word of |x| */

    /* filter out huge and non-finite argument */
    if(hx &gt;= 0x4043687A) {          /* if |x|&gt;=56*ln2 */
        if(hx &gt;= 0x40862E42) {      /* if |x|&gt;=709.78... */
                if(hx&gt;=0x7ff00000) {
            if(((hx&amp;0xfffff)|__LO(x))!=0) 
                 return x+x;     /* NaN */
            else return (xsb==0)? x:-1.0;/* exp(+-inf)={inf,-1} */
            }
            if(x &gt; o_threshold) return huge*huge; /* overflow */
        }
        if(xsb!=0) { /* x &lt; -56*ln2, return -1.0 with inexact */
        if(x+tiny&lt;0.0)      /* raise inexact */
        return tiny-one;    /* return -1 */
        }
    }

    /* argument reduction */
    if(hx &gt; 0x3fd62e42) {       /* if  |x| &gt; 0.5 ln2 */ 
        if(hx &lt; 0x3FF0A2B2) {   /* and |x| &lt; 1.5 ln2 */
        if(xsb==0)
            {hi = x - ln2_hi; lo =  ln2_lo;  k =  1;}
        else
            {hi = x + ln2_hi; lo = -ln2_lo;  k = -1;}
        } else {
        k  = invln2*x+((xsb==0)?0.5:-0.5);
        t  = k;
        hi = x - t*ln2_hi;  /* t*ln2_hi is exact here */
        lo = t*ln2_lo;
        }
        x  = hi - lo;
        c  = (hi-x)-lo;
    } 
    else if(hx &lt; 0x3c900000) {      /* when |x|&lt;2**-54, return x */
        t = huge+x; /* return x with inexact flags when x!=0 */
        return x - (t-(huge+x));    
    }
    else k = 0;

    /* x is now in primary range */
    hfx = 0.5*x;
    hxs = x*hfx;
    r1 = one+hxs*(Q1+hxs*(Q2+hxs*(Q3+hxs*(Q4+hxs*Q5))));
    t  = 3.0-r1*hfx;
    e  = hxs*((r1-t)/(6.0 - x*t));
    if(k==0) return x - (x*e-hxs);      /* c is 0 */
    else {
        e  = (x*(e-c)-c);
        e -= hxs;
        if(k== -1) return 0.5*(x-e)-0.5;
        if(k==1) 
            if(x &lt; -0.25) return -2.0*(e-(x+0.5));
            else          return  one+2.0*(x-e);
        if (k &lt;= -2 || k&gt;56) {   /* suffice to return exp(x)-1 */
            y = one-(e-x);
            __HI(y) += (k&lt;&lt;20); /* add k to y's exponent */
            return y-one;
        }
        t = one;
        if(k&lt;20) {
            __HI(t) = 0x3ff00000 - (0x200000&gt;&gt;k);  /* t=1-2^-k */
            y = t-(e-x);
            __HI(y) += (k&lt;&lt;20); /* add k to y's exponent */
       } else {
            __HI(t)  = ((0x3ff-k)&lt;&lt;20); /* 2^-k */
            y = x-(e+t);
            y += one;
            __HI(y) += (k&lt;&lt;20); /* add k to y's exponent */
        }
    }
    return y;
}
</code></pre>

<ul>
<li><strong><code>s_fabs.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/*
 * fabs(x) returns the absolute value of x.
 */

#include &quot;fdlibm.h&quot;

#ifdef __STDC__
    double fabs(double x)
#else
    double fabs(x)
    double x;
#endif
{
    __HI(x) &amp;= 0x7fffffff;
        return x;
}
</code></pre>

<ul>
<li><strong><code>s_finite.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/*
 * finite(x) returns 1 is x is finite, else 0;
 * no branching!
 */

#include &quot;fdlibm.h&quot;

#ifdef __STDC__
    int finite(double x)
#else
    int finite(x)
    double x;
#endif
{
    int hx; 
    hx = __HI(x);
    return  (unsigned)((hx&amp;0x7fffffff)-0x7ff00000)&gt;&gt;31;
}
</code></pre>

<ul>
<li><strong><code>s_floor.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/*
 * floor(x)
 * Return x rounded toward -inf to integral value
 * Method:
 *  Bit twiddling.
 * Exception:
 *  Inexact flag raised if x not equal to floor(x).
 */

#include &quot;fdlibm.h&quot;

#ifdef __STDC__
static const double huge = 1.0e300;
#else
static double huge = 1.0e300;
#endif

#ifdef __STDC__
    double floor(double x)
#else
    double floor(x)
    double x;
#endif
{
    int i0,i1,j0;
    unsigned i,j;
    i0 =  __HI(x);
    i1 =  __LO(x);
    j0 = ((i0&gt;&gt;20)&amp;0x7ff)-0x3ff;
    if(j0&lt;20) {
        if(j0&lt;0) {  /* raise inexact if x != 0 */
        if(huge+x&gt;0.0) {/* return 0*sign(x) if |x|&lt;1 */
            if(i0&gt;=0) {i0=i1=0;} 
            else if(((i0&amp;0x7fffffff)|i1)!=0)
            { i0=0xbff00000;i1=0;}
        }
        } else {
        i = (0x000fffff)&gt;&gt;j0;
        if(((i0&amp;i)|i1)==0) return x; /* x is integral */
        if(huge+x&gt;0.0) {    /* raise inexact flag */
            if(i0&lt;0) i0 += (0x00100000)&gt;&gt;j0;
            i0 &amp;= (~i); i1=0;
        }
        }
    } else if (j0&gt;51) {
        if(j0==0x400) return x+x;   /* inf or NaN */
        else return x;      /* x is integral */
    } else {
        i = ((unsigned)(0xffffffff))&gt;&gt;(j0-20);
        if((i1&amp;i)==0) return x; /* x is integral */
        if(huge+x&gt;0.0) {        /* raise inexact flag */
        if(i0&lt;0) {
            if(j0==20) i0+=1; 
            else {
            j = i1+(1&lt;&lt;(52-j0));
            if(j&lt;i1) i0 +=1 ;   /* got a carry */
            i1=j;
            }
        }
        i1 &amp;= (~i);
        }
    }
    __HI(x) = i0;
    __LO(x) = i1;
    return x;
}
</code></pre>

<ul>
<li><strong><code>s_frexp.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/*
 * for non-zero x 
 *  x = frexp(arg,&amp;exp);
 * return a double fp quantity x such that 0.5 &lt;= |x| &lt;1.0
 * and the corresponding binary exponent &quot;exp&quot;. That is
 *  arg = x*2^exp.
 * If arg is inf, 0.0, or NaN, then frexp(arg,&amp;exp) returns arg 
 * with *exp=0. 
 */

#include &quot;fdlibm.h&quot;

#ifdef __STDC__
static const double
#else
static double
#endif
two54 =  1.80143985094819840000e+16; /* 0x43500000, 0x00000000 */

#ifdef __STDC__
    double frexp(double x, int *eptr)
#else
    double frexp(x, eptr)
    double x; int *eptr;
#endif
{
    int  hx, ix, lx;
    hx = __HI(x);
    ix = 0x7fffffff&amp;hx;
    lx = __LO(x);
    *eptr = 0;
    if(ix&gt;=0x7ff00000||((ix|lx)==0)) return x;  /* 0,inf,nan */
    if (ix&lt;0x00100000) {        /* subnormal */
        x *= two54;
        hx = __HI(x);
        ix = hx&amp;0x7fffffff;
        *eptr = -54;
    }
    *eptr += (ix&gt;&gt;20)-1022;
    hx = (hx&amp;0x800fffff)|0x3fe00000;
    __HI(x) = hx;
    return x;
}
</code></pre>

<ul>
<li><strong><code>s_ilogb.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/* ilogb(double x)
 * return the binary exponent of non-zero x
 * ilogb(0) = 0x80000001
 * ilogb(inf/NaN) = 0x7fffffff (no signal is raised)
 */

#include &quot;fdlibm.h&quot;

#ifdef __STDC__
    int ilogb(double x)
#else
    int ilogb(x)
    double x;
#endif
{
    int hx,lx,ix;

    hx  = (__HI(x))&amp;0x7fffffff; /* high word of x */
    if(hx&lt;0x00100000) {
        lx = __LO(x);
        if((hx|lx)==0) 
        return 0x80000001;  /* ilogb(0) = 0x80000001 */
        else            /* subnormal x */
        if(hx==0) {
            for (ix = -1043; lx&gt;0; lx&lt;&lt;=1) ix -=1;
        } else {
            for (ix = -1022,hx&lt;&lt;=11; hx&gt;0; hx&lt;&lt;=1) ix -=1;
        }
        return ix;
    }
    else if (hx&lt;0x7ff00000) return (hx&gt;&gt;20)-1023;
    else return 0x7fffffff;
}
</code></pre>

<ul>
<li><strong><code>s_isnan.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/*
 * isnan(x) returns 1 is x is nan, else 0;
 * no branching!
 */

#include &quot;fdlibm.h&quot;

#ifdef __STDC__
    int isnan(double x)
#else
    int isnan(x)
    double x;
#endif
{
    int hx,lx;
    hx = (__HI(x)&amp;0x7fffffff);
    lx = __LO(x);
    hx |= (unsigned)(lx|(-lx))&gt;&gt;31; 
    hx = 0x7ff00000 - hx;
    return ((unsigned)(hx))&gt;&gt;31;
}
</code></pre>

<ul>
<li><strong><code>s_ldexp.c</code>文件</strong></li>
</ul>
<pre><code class="c++">#include &quot;fdlibm.h&quot;
#include &lt;errno.h&gt;

#ifdef __STDC__
    double ldexp(double value, int exp)
#else
    double ldexp(value, exp)
    double value; int exp;
#endif
{
    if(!finite(value)||value==0.0) return value;
    value = scalbn(value,exp);
    if(!finite(value)||value==0.0) errno = ERANGE;
    return value;
}
</code></pre>

<ul>
<li><strong><code>s_lib_version.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/*
 * MACRO for standards
 */

#include &quot;fdlibm.h&quot;

/*
 * define and initialize _LIB_VERSION
 */
#ifdef _POSIX_MODE
_LIB_VERSION_TYPE _LIB_VERSION = _POSIX_;
#else
#ifdef _XOPEN_MODE
_LIB_VERSION_TYPE _LIB_VERSION = _XOPEN_;
#else
#ifdef _SVID3_MODE
_LIB_VERSION_TYPE _LIB_VERSION = _SVID_;
#else                   /* default _IEEE_MODE */
_LIB_VERSION_TYPE _LIB_VERSION = _IEEE_;
#endif
#endif
#endif
</code></pre>

<ul>
<li><strong><code>s_log1p.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/* double log1p(double x)
 *
 * Method :                  
 *   1. Argument Reduction: find k and f such that 
 *          1+x = 2^k * (1+f), 
 *     where  sqrt(2)/2 &lt; 1+f &lt; sqrt(2) .
 *
 *      Note. If k=0, then f=x is exact. However, if k!=0, then f
 *  may not be representable exactly. In that case, a correction
 *  term is need. Let u=1+x rounded. Let c = (1+x)-u, then
 *  log(1+x) - log(u) ~ c/u. Thus, we proceed to compute log(u),
 *  and add back the correction term c/u.
 *  (Note: when x &gt; 2**53, one can simply return log(x))
 *
 *   2. Approximation of log1p(f).
 *  Let s = f/(2+f) ; based on log(1+f) = log(1+s) - log(1-s)
 *       = 2s + 2/3 s**3 + 2/5 s**5 + .....,
 *           = 2s + s*R
 *      We use a special Reme algorithm on [0,0.1716] to generate 
 *  a polynomial of degree 14 to approximate R The maximum error 
 *  of this polynomial approximation is bounded by 2**-58.45. In
 *  other words,
 *              2      4      6      8      10      12      14
 *      R(z) ~ Lp1*s +Lp2*s +Lp3*s +Lp4*s +Lp5*s  +Lp6*s  +Lp7*s
 *      (the values of Lp1 to Lp7 are listed in the program)
 *  and
 *      |      2          14          |     -58.45
 *      | Lp1*s +...+Lp7*s    -  R(z) | &lt;= 2 
 *      |                             |
 *  Note that 2s = f - s*f = f - hfsq + s*hfsq, where hfsq = f*f/2.
 *  In order to guarantee error in log below 1ulp, we compute log
 *  by
 *      log1p(f) = f - (hfsq - s*(hfsq+R)).
 *  
 *  3. Finally, log1p(x) = k*ln2 + log1p(f).  
 *               = k*ln2_hi+(f-(hfsq-(s*(hfsq+R)+k*ln2_lo)))
 *     Here ln2 is split into two floating point number: 
 *          ln2_hi + ln2_lo,
 *     where n*ln2_hi is always exact for |n| &lt; 2000.
 *
 * Special cases:
 *  log1p(x) is NaN with signal if x &lt; -1 (including -INF) ; 
 *  log1p(+INF) is +INF; log1p(-1) is -INF with signal;
 *  log1p(NaN) is that NaN with no signal.
 *
 * Accuracy:
 *  according to an error analysis, the error is always less than
 *  1 ulp (unit in the last place).
 *
 * Constants:
 * The hexadecimal values are the intended ones for the following 
 * constants. The decimal values may be used, provided that the 
 * compiler will convert from decimal to binary accurately enough 
 * to produce the hexadecimal values shown.
 *
 * Note: Assuming log() return accurate answer, the following
 *   algorithm can be used to compute log1p(x) to within a few ULP:
 *  
 *      u = 1+x;
 *      if(u==1.0) return x ; else
 *             return log(u)*(x/(u-1.0));
 *
 *   See HP-15C Advanced Functions Handbook, p.193.
 */

#include &quot;fdlibm.h&quot;

#ifdef __STDC__
static const double
#else
static double
#endif
ln2_hi  =  6.93147180369123816490e-01,  /* 3fe62e42 fee00000 */
ln2_lo  =  1.90821492927058770002e-10,  /* 3dea39ef 35793c76 */
two54   =  1.80143985094819840000e+16,  /* 43500000 00000000 */
Lp1 = 6.666666666666735130e-01,  /* 3FE55555 55555593 */
Lp2 = 3.999999999940941908e-01,  /* 3FD99999 9997FA04 */
Lp3 = 2.857142874366239149e-01,  /* 3FD24924 94229359 */
Lp4 = 2.222219843214978396e-01,  /* 3FCC71C5 1D8E78AF */
Lp5 = 1.818357216161805012e-01,  /* 3FC74664 96CB03DE */
Lp6 = 1.531383769920937332e-01,  /* 3FC39A09 D078C69F */
Lp7 = 1.479819860511658591e-01;  /* 3FC2F112 DF3E5244 */

static double zero = 0.0;

#ifdef __STDC__
    double log1p(double x)
#else
    double log1p(x)
    double x;
#endif
{
    double hfsq,f,c,s,z,R,u;
    int k,hx,hu,ax;

    hx = __HI(x);       /* high word of x */
    ax = hx&amp;0x7fffffff;

    k = 1;
    if (hx &lt; 0x3FDA827A) {          /* x &lt; 0.41422  */
        if(ax&gt;=0x3ff00000) {        /* x &lt;= -1.0 */
        if(x==-1.0) return -two54/zero; /* log1p(-1)=+inf */
        else return (x-x)/(x-x);    /* log1p(x&lt;-1)=NaN */
        }
        if(ax&lt;0x3e200000) {         /* |x| &lt; 2**-29 */
        if(two54+x&gt;zero         /* raise inexact */
                &amp;&amp;ax&lt;0x3c900000)        /* |x| &lt; 2**-54 */
            return x;
        else
            return x - x*x*0.5;
        }
        if(hx&gt;0||hx&lt;=((int)0xbfd2bec3)) {
        k=0;f=x;hu=1;}  /* -0.2929&lt;x&lt;0.41422 */
    } 
    if (hx &gt;= 0x7ff00000) return x+x;
    if(k!=0) {
        if(hx&lt;0x43400000) {
        u  = 1.0+x; 
            hu = __HI(u);       /* high word of u */
            k  = (hu&gt;&gt;20)-1023;
            c  = (k&gt;0)? 1.0-(u-x):x-(u-1.0);/* correction term */
        c /= u;
        } else {
        u  = x;
            hu = __HI(u);       /* high word of u */
            k  = (hu&gt;&gt;20)-1023;
        c  = 0;
        }
        hu &amp;= 0x000fffff;
        if(hu&lt;0x6a09e) {
            __HI(u) = hu|0x3ff00000;    /* normalize u */
        } else {
            k += 1; 
            __HI(u) = hu|0x3fe00000;    /* normalize u/2 */
            hu = (0x00100000-hu)&gt;&gt;2;
        }
        f = u-1.0;
    }
    hfsq=0.5*f*f;
    if(hu==0) { /* |f| &lt; 2**-20 */
        if(f==zero) if(k==0) return zero;  
            else {c += k*ln2_lo; return k*ln2_hi+c;}
        R = hfsq*(1.0-0.66666666666666666*f);
        if(k==0) return f-R; else
                 return k*ln2_hi-((R-(k*ln2_lo+c))-f);
    }
    s = f/(2.0+f); 
    z = s*s;
    R = z*(Lp1+z*(Lp2+z*(Lp3+z*(Lp4+z*(Lp5+z*(Lp6+z*Lp7))))));
    if(k==0) return f-(hfsq-s*(hfsq+R)); else
         return k*ln2_hi-((hfsq-(s*(hfsq+R)+(k*ln2_lo+c)))-f);
}
</code></pre>

<ul>
<li><strong><code>s_logb.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/*
 * double logb(x)
 * IEEE 754 logb. Included to pass IEEE test suite. Not recommend.
 * Use ilogb instead.
 */

#include &quot;fdlibm.h&quot;

#ifdef __STDC__
    double logb(double x)
#else
    double logb(x)
    double x;
#endif
{
    int lx,ix;
    ix = (__HI(x))&amp;0x7fffffff;  /* high |x| */
    lx = __LO(x);           /* low x */
    if((ix|lx)==0) return -1.0/fabs(x);
    if(ix&gt;=0x7ff00000) return x*x;
    if((ix&gt;&gt;=20)==0)            /* IEEE 754 logb */
        return -1022.0; 
    else
        return (double) (ix-1023); 
}
</code></pre>

<ul>
<li><strong><code>s_matherr.c</code>文件</strong></li>
</ul>
<pre><code class="c++">#include &quot;fdlibm.h&quot;

#ifdef __STDC__
    int matherr(struct exception *x)
#else
    int matherr(x)
    struct exception *x;
#endif
{
    int n=0;
    if(x-&gt;arg1!=x-&gt;arg1) return 0;
    return n;
}
</code></pre>

<ul>
<li><strong><code>s_modf.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/*
 * modf(double x, double *iptr) 
 * return fraction part of x, and return x's integral part in *iptr.
 * Method:
 *  Bit twiddling.
 *
 * Exception:
 *  No exception.
 */

#include &quot;fdlibm.h&quot;

#ifdef __STDC__
static const double one = 1.0;
#else
static double one = 1.0;
#endif

#ifdef __STDC__
    double modf(double x, double *iptr)
#else
    double modf(x, iptr)
    double x,*iptr;
#endif
{
    int i0,i1,j0;
    unsigned i;
    i0 =  __HI(x);      /* high x */
    i1 =  __LO(x);      /* low  x */
    j0 = ((i0&gt;&gt;20)&amp;0x7ff)-0x3ff;    /* exponent of x */
    if(j0&lt;20) {         /* integer part in high x */
        if(j0&lt;0) {          /* |x|&lt;1 */
        __HIp(iptr) = i0&amp;0x80000000;
        __LOp(iptr) = 0;        /* *iptr = +-0 */
        return x;
        } else {
        i = (0x000fffff)&gt;&gt;j0;
        if(((i0&amp;i)|i1)==0) {        /* x is integral */
            *iptr = x;
            __HI(x) &amp;= 0x80000000;
            __LO(x)  = 0;   /* return +-0 */
            return x;
        } else {
            __HIp(iptr) = i0&amp;(~i);
            __LOp(iptr) = 0;
            return x - *iptr;
        }
        }
    } else if (j0&gt;51) {     /* no fraction part */
        *iptr = x*one;
        __HI(x) &amp;= 0x80000000;
        __LO(x)  = 0;   /* return +-0 */
        return x;
    } else {            /* fraction part in low x */
        i = ((unsigned)(0xffffffff))&gt;&gt;(j0-20);
        if((i1&amp;i)==0) {         /* x is integral */
        *iptr = x;
        __HI(x) &amp;= 0x80000000;
        __LO(x)  = 0;   /* return +-0 */
        return x;
        } else {
        __HIp(iptr) = i0;
        __LOp(iptr) = i1&amp;(~i);
        return x - *iptr;
        }
    }
}
</code></pre>

<ul>
<li><strong><code>s_nextafter.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/* IEEE functions
 *  nextafter(x,y)
 *  return the next machine floating-point number of x in the
 *  direction toward y.
 *   Special cases:
 */

#include &quot;fdlibm.h&quot;

#ifdef __STDC__
    double nextafter(double x, double y)
#else
    double nextafter(x,y)
    double x,y;
#endif
{
    int hx,hy,ix,iy;
    unsigned lx,ly;

    hx = __HI(x);       /* high word of x */
    lx = __LO(x);       /* low  word of x */
    hy = __HI(y);       /* high word of y */
    ly = __LO(y);       /* low  word of y */
    ix = hx&amp;0x7fffffff;     /* |x| */
    iy = hy&amp;0x7fffffff;     /* |y| */

    if(((ix&gt;=0x7ff00000)&amp;&amp;((ix-0x7ff00000)|lx)!=0) ||   /* x is nan */ 
       ((iy&gt;=0x7ff00000)&amp;&amp;((iy-0x7ff00000)|ly)!=0))     /* y is nan */ 
       return x+y;              
    if(x==y) return x;      /* x=y, return x */
    if((ix|lx)==0) {            /* x == 0 */
        __HI(x) = hy&amp;0x80000000;    /* return +-minsubnormal */
        __LO(x) = 1;
        y = x*x;
        if(y==x) return y; else return x;   /* raise underflow flag */
    } 
    if(hx&gt;=0) {             /* x &gt; 0 */
        if(hx&gt;hy||((hx==hy)&amp;&amp;(lx&gt;ly))) {    /* x &gt; y, x -= ulp */
        if(lx==0) hx -= 1;
        lx -= 1;
        } else {                /* x &lt; y, x += ulp */
        lx += 1;
        if(lx==0) hx += 1;
        }
    } else {                /* x &lt; 0 */
        if(hy&gt;=0||hx&gt;hy||((hx==hy)&amp;&amp;(lx&gt;ly))){/* x &lt; y, x -= ulp */
        if(lx==0) hx -= 1;
        lx -= 1;
        } else {                /* x &gt; y, x += ulp */
        lx += 1;
        if(lx==0) hx += 1;
        }
    }
    hy = hx&amp;0x7ff00000;
    if(hy&gt;=0x7ff00000) return x+x;  /* overflow  */
    if(hy&lt;0x00100000) {     /* underflow */
        y = x*x;
        if(y!=x) {      /* raise underflow flag */
        __HI(y) = hx; __LO(y) = lx;
        return y;
        }
    }
    __HI(x) = hx; __LO(x) = lx;
    return x;
}
</code></pre>

<ul>
<li><strong><code>s_rint.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/*
 * rint(x)
 * Return x rounded to integral value according to the prevailing
 * rounding mode.
 * Method:
 *  Using floating addition.
 * Exception:
 *  Inexact flag raised if x not equal to rint(x).
 */

#include &quot;fdlibm.h&quot;

#ifdef __STDC__
static const double
#else
static double 
#endif
TWO52[2]={
  4.50359962737049600000e+15, /* 0x43300000, 0x00000000 */
 -4.50359962737049600000e+15, /* 0xC3300000, 0x00000000 */
};

#ifdef __STDC__
    double rint(double x)
#else
    double rint(x)
    double x;
#endif
{
    int i0,j0,sx;
    unsigned i,i1;
    double w,t;
    i0 =  __HI(x);
    sx = (i0&gt;&gt;31)&amp;1;
    i1 =  __LO(x);
    j0 = ((i0&gt;&gt;20)&amp;0x7ff)-0x3ff;
    if(j0&lt;20) {
        if(j0&lt;0) {  
        if(((i0&amp;0x7fffffff)|i1)==0) return x;
        i1 |= (i0&amp;0x0fffff);
        i0 &amp;= 0xfffe0000;
        i0 |= ((i1|-i1)&gt;&gt;12)&amp;0x80000;
        __HI(x)=i0;
            w = TWO52[sx]+x;
            t =  w-TWO52[sx];
            i0 = __HI(t);
            __HI(t) = (i0&amp;0x7fffffff)|(sx&lt;&lt;31);
            return t;
        } else {
        i = (0x000fffff)&gt;&gt;j0;
        if(((i0&amp;i)|i1)==0) return x; /* x is integral */
        i&gt;&gt;=1;
        if(((i0&amp;i)|i1)!=0) {
            if(j0==19) i1 = 0x40000000; else
            i0 = (i0&amp;(~i))|((0x20000)&gt;&gt;j0);
        }
        }
    } else if (j0&gt;51) {
        if(j0==0x400) return x+x;   /* inf or NaN */
        else return x;      /* x is integral */
    } else {
        i = ((unsigned)(0xffffffff))&gt;&gt;(j0-20);
        if((i1&amp;i)==0) return x; /* x is integral */
        i&gt;&gt;=1;
        if((i1&amp;i)!=0) i1 = (i1&amp;(~i))|((0x40000000)&gt;&gt;(j0-20));
    }
    __HI(x) = i0;
    __LO(x) = i1;
    w = TWO52[sx]+x;
    return w-TWO52[sx];
}
</code></pre>

<ul>
<li><strong><code>s_scalbn.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/* 
 * scalbn (double x, int n)
 * scalbn(x,n) returns x* 2**n  computed by  exponent  
 * manipulation rather than by actually performing an 
 * exponentiation or a multiplication.
 */

#include &quot;fdlibm.h&quot;

#ifdef __STDC__
static const double
#else
static double
#endif
two54   =  1.80143985094819840000e+16, /* 0x43500000, 0x00000000 */
twom54  =  5.55111512312578270212e-17, /* 0x3C900000, 0x00000000 */
huge   = 1.0e+300,
tiny   = 1.0e-300;

#ifdef __STDC__
    double scalbn (double x, int n)
#else
    double scalbn (x,n)
    double x; int n;
#endif
{
    int  k,hx,lx;
    hx = __HI(x);
    lx = __LO(x);
        k = (hx&amp;0x7ff00000)&gt;&gt;20;        /* extract exponent */
        if (k==0) {             /* 0 or subnormal x */
            if ((lx|(hx&amp;0x7fffffff))==0) return x; /* +-0 */
        x *= two54; 
        hx = __HI(x);
        k = ((hx&amp;0x7ff00000)&gt;&gt;20) - 54; 
            if (n&lt; -50000) return tiny*x;   /*underflow*/
        }
        if (k==0x7ff) return x+x;       /* NaN or Inf */
        k = k+n; 
        if (k &gt;  0x7fe) return huge*copysign(huge,x); /* overflow  */
        if (k &gt; 0)              /* normal result */
        {__HI(x) = (hx&amp;0x800fffff)|(k&lt;&lt;20); return x;}
        if (k &lt;= -54)
            if (n &gt; 50000)  /* in case integer overflow in n+k */
        return huge*copysign(huge,x);   /*overflow*/
        else return tiny*copysign(tiny,x);  /*underflow*/
        k += 54;                /* subnormal result */
        __HI(x) = (hx&amp;0x800fffff)|(k&lt;&lt;20);
        return x*twom54;
}
</code></pre>

<ul>
<li><strong><code>s_signgam.c</code>文件</strong></li>
</ul>
<p>```c++#include "fdlibm.h"
int signgam = 0;</p>
<pre><code>
* **`s_significand.c`文件**

```c++
/*
 * significand(x) computes just
 *  scalb(x, (double) -ilogb(x)),
 * for exercising the fraction-part(F) IEEE 754-1985 test vector.
 */

#include &quot;fdlibm.h&quot;

#ifdef __STDC__
    double significand(double x)
#else
    double significand(x)
    double x;
#endif
{
    return __ieee754_scalb(x,(double) -ilogb(x));
}
</code></pre>

<ul>
<li><strong><code>s_sin.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/* sin(x)
 * Return sine function of x.
 *
 * kernel function:
 *  __kernel_sin        ... sine function on [-pi/4,pi/4]
 *  __kernel_cos        ... cose function on [-pi/4,pi/4]
 *  __ieee754_rem_pio2  ... argument reduction routine
 *
 * Method.
 *      Let S,C and T denote the sin, cos and tan respectively on 
 *  [-PI/4, +PI/4]. Reduce the argument x to y1+y2 = x-k*pi/2 
 *  in [-pi/4 , +pi/4], and let n = k mod 4.
 *  We have
 *
 *          n        sin(x)      cos(x)        tan(x)
 *     ----------------------------------------------------------
 *      0          S       C         T
 *      1          C      -S        -1/T
 *      2         -S      -C         T
 *      3         -C       S        -1/T
 *     ----------------------------------------------------------
 *
 * Special cases:
 *      Let trig be any of sin, cos, or tan.
 *      trig(+-INF)  is NaN, with signals;
 *      trig(NaN)    is that NaN;
 *
 * Accuracy:
 *  TRIG(x) returns trig(x) nearly rounded 
 */

#include &quot;fdlibm.h&quot;

#ifdef __STDC__
    double sin(double x)
#else
    double sin(x)
    double x;
#endif
{
    double y[2],z=0.0;
    int n, ix;

    /* High word of x. */
    ix = __HI(x);

    /* |x| ~&lt; pi/4 */
    ix &amp;= 0x7fffffff;
    if(ix &lt;= 0x3fe921fb) return __kernel_sin(x,z,0);

    /* sin(Inf or NaN) is NaN */
    else if (ix&gt;=0x7ff00000) return x-x;

    /* argument reduction needed */
    else {
        n = __ieee754_rem_pio2(x,y);
        switch(n&amp;3) {
        case 0: return  __kernel_sin(y[0],y[1],1);
        case 1: return  __kernel_cos(y[0],y[1]);
        case 2: return -__kernel_sin(y[0],y[1],1);
        default:
            return -__kernel_cos(y[0],y[1]);
        }
    }
}
</code></pre>

<ul>
<li><strong><code>s_tan.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/* tan(x)
 * Return tangent function of x.
 *
 * kernel function:
 *  __kernel_tan        ... tangent function on [-pi/4,pi/4]
 *  __ieee754_rem_pio2  ... argument reduction routine
 *
 * Method.
 *      Let S,C and T denote the sin, cos and tan respectively on 
 *  [-PI/4, +PI/4]. Reduce the argument x to y1+y2 = x-k*pi/2 
 *  in [-pi/4 , +pi/4], and let n = k mod 4.
 *  We have
 *
 *          n        sin(x)      cos(x)        tan(x)
 *     ----------------------------------------------------------
 *      0          S       C         T
 *      1          C      -S        -1/T
 *      2         -S      -C         T
 *      3         -C       S        -1/T
 *     ----------------------------------------------------------
 *
 * Special cases:
 *      Let trig be any of sin, cos, or tan.
 *      trig(+-INF)  is NaN, with signals;
 *      trig(NaN)    is that NaN;
 *
 * Accuracy:
 *  TRIG(x) returns trig(x) nearly rounded 
 */

#include &quot;fdlibm.h&quot;

#ifdef __STDC__
    double tan(double x)
#else
    double tan(x)
    double x;
#endif
{
    double y[2],z=0.0;
    int n, ix;

    /* High word of x. */
    ix = __HI(x);

    /* |x| ~&lt; pi/4 */
    ix &amp;= 0x7fffffff;
    if(ix &lt;= 0x3fe921fb) return __kernel_tan(x,z,1);

    /* tan(Inf or NaN) is NaN */
    else if (ix&gt;=0x7ff00000) return x-x;        /* NaN */

    /* argument reduction needed */
    else {
        n = __ieee754_rem_pio2(x,y);
        return __kernel_tan(y[0],y[1],1-((n&amp;1)&lt;&lt;1)); /*   1 -- n even
                            -1 -- n odd */
    }
}
</code></pre>

<ul>
<li><strong><code>s_tanh.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/* Tanh(x)
 * Return the Hyperbolic Tangent of x
 *
 * Method :
 *                     x    -x
 *                    e  - e
 *  0. tanh(x) is defined to be -----------
 *                     x    -x
 *                    e  + e
 *  1. reduce x to non-negative by tanh(-x) = -tanh(x).
 *  2.  0      &lt;= x &lt;= 2**-55 : tanh(x) := x*(one+x)
 *                          -t
 *      2**-55 &lt;  x &lt;=  1     : tanh(x) := -----; t = expm1(-2x)
 *                         t + 2
 *                           2
 *      1      &lt;= x &lt;=  22.0  : tanh(x) := 1-  ----- ; t=expm1(2x)
 *                         t + 2
 *      22.0   &lt;  x &lt;= INF    : tanh(x) := 1.
 *
 * Special cases:
 *  tanh(NaN) is NaN;
 *  only tanh(0)=0 is exact for finite argument.
 */

#include &quot;fdlibm.h&quot;

#ifdef __STDC__
static const double one=1.0, two=2.0, tiny = 1.0e-300;
#else
static double one=1.0, two=2.0, tiny = 1.0e-300;
#endif

#ifdef __STDC__
    double tanh(double x)
#else
    double tanh(x)
    double x;
#endif
{
    double t,z;
    int jx,ix;

    /* High word of |x|. */
    jx = __HI(x);
    ix = jx&amp;0x7fffffff;

    /* x is INF or NaN */
    if(ix&gt;=0x7ff00000) { 
        if (jx&gt;=0) return one/x+one;    /* tanh(+-inf)=+-1 */
        else       return one/x-one;    /* tanh(NaN) = NaN */
    }

    /* |x| &lt; 22 */
    if (ix &lt; 0x40360000) {      /* |x|&lt;22 */
        if (ix&lt;0x3c800000)      /* |x|&lt;2**-55 */
        return x*(one+x);       /* tanh(small) = small */
        if (ix&gt;=0x3ff00000) {   /* |x|&gt;=1  */
        t = expm1(two*fabs(x));
        z = one - two/(t+two);
        } else {
            t = expm1(-two*fabs(x));
            z= -t/(t+two);
        }
    /* |x| &gt; 22, return +-1 */
    } else {
        z = one - tiny;     /* raised inexact flag */
    }
    return (jx&gt;=0)? z: -z;
}
</code></pre>

<ul>
<li><strong><code>w_acos.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/*
 * wrap_acos(x)
 */

#include &quot;fdlibm.h&quot;


#ifdef __STDC__
    double acos(double x)       /* wrapper acos */
#else
    double acos(x)          /* wrapper acos */
    double x;
#endif
{
#ifdef _IEEE_LIBM
    return __ieee754_acos(x);
#else
    double z;
    z = __ieee754_acos(x);
    if(_LIB_VERSION == _IEEE_ || isnan(x)) return z;
    if(fabs(x)&gt;1.0) {
            return __kernel_standard(x,x,1); /* acos(|x|&gt;1) */
    } else
        return z;
#endif
}
</code></pre>

<ul>
<li><strong><code>w_acosh.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/* 
 * wrapper acosh(x)
 */

#include &quot;fdlibm.h&quot;

#ifdef __STDC__
    double acosh(double x)      /* wrapper acosh */
#else
    double acosh(x)         /* wrapper acosh */
    double x;
#endif
{
#ifdef _IEEE_LIBM
    return __ieee754_acosh(x);
#else
    double z;
    z = __ieee754_acosh(x);
    if(_LIB_VERSION == _IEEE_ || isnan(x)) return z;
    if(x&lt;1.0) {
            return __kernel_standard(x,x,29); /* acosh(x&lt;1) */
    } else
        return z;
#endif
}
</code></pre>

<ul>
<li><strong><code>w_asin.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/* 
 * wrapper asin(x)
 */


#include &quot;fdlibm.h&quot;


#ifdef __STDC__
    double asin(double x)       /* wrapper asin */
#else
    double asin(x)          /* wrapper asin */
    double x;
#endif
{
#ifdef _IEEE_LIBM
    return __ieee754_asin(x);
#else
    double z;
    z = __ieee754_asin(x);
    if(_LIB_VERSION == _IEEE_ || isnan(x)) return z;
    if(fabs(x)&gt;1.0) {
            return __kernel_standard(x,x,2); /* asin(|x|&gt;1) */
    } else
        return z;
#endif
}
</code></pre>

<ul>
<li><strong><code>w_atan2.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/* 
 * wrapper atan2(y,x)
 */

#include &quot;fdlibm.h&quot;


#ifdef __STDC__
    double atan2(double y, double x)    /* wrapper atan2 */
#else
    double atan2(y,x)           /* wrapper atan2 */
    double y,x;
#endif
{
#ifdef _IEEE_LIBM
    return __ieee754_atan2(y,x);
#else
    double z;
    z = __ieee754_atan2(y,x);
    if(_LIB_VERSION == _IEEE_||isnan(x)||isnan(y)) return z;
    if(x==0.0&amp;&amp;y==0.0) {
            return __kernel_standard(y,x,3); /* atan2(+-0,+-0) */
    } else
        return z;
#endif
}
</code></pre>

<ul>
<li><strong><code>w_atanh.c</code>文件</strong></li>
</ul>
<p>```c++/<em> 
 * wrapper atanh(x)
 </em>/</p>
<h1 id="include-fdlibmh_1">include "fdlibm.h"</h1>
<h1 id="ifdef-stdc">ifdef <strong>STDC</strong></h1>
<pre><code>double atanh(double x)      /* wrapper atanh */
</code></pre>
<h1 id="else">else</h1>
<pre><code>double atanh(x)         /* wrapper atanh */
double x;
</code></pre>
<h1 id="endif">endif</h1>
<p>{</p>
<h1 id="ifdef-_ieee_libm">ifdef _IEEE_LIBM</h1>
<pre><code>return __ieee754_atanh(x);
</code></pre>
<h1 id="else_1">else</h1>
<pre><code>double z,y;
z = __ieee754_atanh(x);
if(_LIB_VERSION == _IEEE_ || isnan(x)) return z;
y = fabs(x);
if(y&gt;=1.0) {
    if(y&gt;1.0)
        return __kernel_standard(x,x,30); /* atanh(|x|&gt;1) */
    else 
        return __kernel_standard(x,x,31); /* atanh(|x|==1) */
} else
    return z;
</code></pre>
<h1 id="endif_1">endif</h1>
<p>}</p>
<pre><code>
* **`w_cosh.c`文件**

```c++
/* 
 * wrapper cosh(x)
 */

#include &quot;fdlibm.h&quot;

#ifdef __STDC__
    double cosh(double x)       /* wrapper cosh */
#else
    double cosh(x)          /* wrapper cosh */
    double x;
#endif
{
#ifdef _IEEE_LIBM
    return __ieee754_cosh(x);
#else
    double z;
    z = __ieee754_cosh(x);
    if(_LIB_VERSION == _IEEE_ || isnan(x)) return z;
    if(fabs(x)&gt;7.10475860073943863426e+02) {    
            return __kernel_standard(x,x,5); /* cosh overflow */
    } else
        return z;
#endif
}
</code></pre>

<ul>
<li><strong><code>w_exp.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/* 
 * wrapper exp(x)
 */

#include &quot;fdlibm.h&quot;

#ifdef __STDC__
static const double
#else
static double
#endif
o_threshold=  7.09782712893383973096e+02,  /* 0x40862E42, 0xFEFA39EF */
u_threshold= -7.45133219101941108420e+02;  /* 0xc0874910, 0xD52D3051 */

#ifdef __STDC__
    double exp(double x)        /* wrapper exp */
#else
    double exp(x)           /* wrapper exp */
    double x;
#endif
{
#ifdef _IEEE_LIBM
    return __ieee754_exp(x);
#else
    double z;
    z = __ieee754_exp(x);
    if(_LIB_VERSION == _IEEE_) return z;
    if(finite(x)) {
        if(x&gt;o_threshold)
            return __kernel_standard(x,x,6); /* exp overflow */
        else if(x&lt;u_threshold)
            return __kernel_standard(x,x,7); /* exp underflow */
    } 
    return z;
#endif
}
</code></pre>

<ul>
<li><strong><code>w_fmod.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/* 
 * wrapper fmod(x,y)
 */

#include &quot;fdlibm.h&quot;


#ifdef __STDC__
    double fmod(double x, double y) /* wrapper fmod */
#else
    double fmod(x,y)        /* wrapper fmod */
    double x,y;
#endif
{
#ifdef _IEEE_LIBM
    return __ieee754_fmod(x,y);
#else
    double z;
    z = __ieee754_fmod(x,y);
    if(_LIB_VERSION == _IEEE_ ||isnan(y)||isnan(x)) return z;
    if(y==0.0) {
            return __kernel_standard(x,y,27); /* fmod(x,0) */
    } else
        return z;
#endif
}
</code></pre>

<ul>
<li><strong><code>w_gamma.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/* double gamma(double x)
 * Return the logarithm of the Gamma function of x.
 *
 * Method: call gamma_r
 */

#include &quot;fdlibm.h&quot;

extern int signgam;

#ifdef __STDC__
    double gamma(double x)
#else
    double gamma(x)
    double x;
#endif
{
#ifdef _IEEE_LIBM
    return __ieee754_gamma_r(x,&amp;signgam);
#else
        double y;
        y = __ieee754_gamma_r(x,&amp;signgam);
        if(_LIB_VERSION == _IEEE_) return y;
        if(!finite(y)&amp;&amp;finite(x)) {
            if(floor(x)==x&amp;&amp;x&lt;=0.0)
                return __kernel_standard(x,x,41); /* gamma pole */
            else
                return __kernel_standard(x,x,40); /* gamma overflow */
        } else
            return y;
#endif
}             
</code></pre>

<ul>
<li><strong><code>w_gamma_r.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/* 
 * wrapper double gamma_r(double x, int *signgamp)
 */

#include &quot;fdlibm.h&quot;


#ifdef __STDC__
    double gamma_r(double x, int *signgamp) /* wrapper lgamma_r */
#else
    double gamma_r(x,signgamp)              /* wrapper lgamma_r */
        double x; int *signgamp;
#endif
{
#ifdef _IEEE_LIBM
    return __ieee754_gamma_r(x,signgamp);
#else
        double y;
        y = __ieee754_gamma_r(x,signgamp);
        if(_LIB_VERSION == _IEEE_) return y;
        if(!finite(y)&amp;&amp;finite(x)) {
            if(floor(x)==x&amp;&amp;x&lt;=0.0)
                return __kernel_standard(x,x,41); /* gamma pole */
            else
                return __kernel_standard(x,x,40); /* gamma overflow */
        } else
            return y;
#endif
}             
</code></pre>

<ul>
<li><strong><code>w_hypot.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/*
 * wrapper hypot(x,y)
 */

#include &quot;fdlibm.h&quot;


#ifdef __STDC__
    double hypot(double x, double y)/* wrapper hypot */
#else
    double hypot(x,y)       /* wrapper hypot */
    double x,y;
#endif
{
#ifdef _IEEE_LIBM
    return __ieee754_hypot(x,y);
#else
    double z;
    z = __ieee754_hypot(x,y);
    if(_LIB_VERSION == _IEEE_) return z;
    if((!finite(z))&amp;&amp;finite(x)&amp;&amp;finite(y))
        return __kernel_standard(x,y,4); /* hypot overflow */
    else
        return z;
#endif
}
</code></pre>

<ul>
<li><strong><code>w_j0.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/*
 * wrapper j0(double x), y0(double x)
 */

#include &quot;fdlibm.h&quot;

#ifdef __STDC__
    double j0(double x)     /* wrapper j0 */
#else
    double j0(x)            /* wrapper j0 */
    double x;
#endif
{
#ifdef _IEEE_LIBM
    return __ieee754_j0(x);
#else
    double z = __ieee754_j0(x);
    if(_LIB_VERSION == _IEEE_ || isnan(x)) return z;
    if(fabs(x)&gt;X_TLOSS) {
            return __kernel_standard(x,x,34); /* j0(|x|&gt;X_TLOSS) */
    } else
        return z;
#endif
}

#ifdef __STDC__
    double y0(double x)     /* wrapper y0 */
#else
    double y0(x)            /* wrapper y0 */
    double x;
#endif
{
#ifdef _IEEE_LIBM
    return __ieee754_y0(x);
#else
    double z;
    z = __ieee754_y0(x);
    if(_LIB_VERSION == _IEEE_ || isnan(x) ) return z;
        if(x &lt;= 0.0){
                if(x==0.0)
                    /* d= -one/(x-x); */
                    return __kernel_standard(x,x,8);
                else
                    /* d = zero/(x-x); */
                    return __kernel_standard(x,x,9);
        }
    if(x&gt;X_TLOSS) {
            return __kernel_standard(x,x,35); /* y0(x&gt;X_TLOSS) */
    } else
        return z;
#endif
}
</code></pre>

<ul>
<li><strong><code>w_j1.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/* 
 * wrapper of j1,y1 
 */

#include &quot;fdlibm.h&quot;

#ifdef __STDC__
    double j1(double x)     /* wrapper j1 */
#else
    double j1(x)            /* wrapper j1 */
    double x;
#endif
{
#ifdef _IEEE_LIBM
    return __ieee754_j1(x);
#else
    double z;
    z = __ieee754_j1(x);
    if(_LIB_VERSION == _IEEE_ || isnan(x) ) return z;
    if(fabs(x)&gt;X_TLOSS) {
            return __kernel_standard(x,x,36); /* j1(|x|&gt;X_TLOSS) */
    } else
        return z;
#endif
}

#ifdef __STDC__
    double y1(double x)     /* wrapper y1 */
#else
    double y1(x)            /* wrapper y1 */
    double x;
#endif
{
#ifdef _IEEE_LIBM
    return __ieee754_y1(x);
#else
    double z;
    z = __ieee754_y1(x);
    if(_LIB_VERSION == _IEEE_ || isnan(x) ) return z;
        if(x &lt;= 0.0){
                if(x==0.0)
                    /* d= -one/(x-x); */
                    return __kernel_standard(x,x,10);
                else
                    /* d = zero/(x-x); */
                    return __kernel_standard(x,x,11);
        }
    if(x&gt;X_TLOSS) {
            return __kernel_standard(x,x,37); /* y1(x&gt;X_TLOSS) */
    } else
        return z;
#endif
}
</code></pre>

<ul>
<li><strong><code>w_jn.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/*
 * wrapper jn(int n, double x), yn(int n, double x)
 * floating point Bessel's function of the 1st and 2nd kind
 * of order n
 *          
 * Special cases:
 *  y0(0)=y1(0)=yn(n,0) = -inf with division by zero signal;
 *  y0(-ve)=y1(-ve)=yn(n,-ve) are NaN with invalid signal.
 * Note 2. About jn(n,x), yn(n,x)
 *  For n=0, j0(x) is called,
 *  for n=1, j1(x) is called,
 *  for n&lt;x, forward recursion us used starting
 *  from values of j0(x) and j1(x).
 *  for n&gt;x, a continued fraction approximation to
 *  j(n,x)/j(n-1,x) is evaluated and then backward
 *  recursion is used starting from a supposed value
 *  for j(n,x). The resulting value of j(0,x) is
 *  compared with the actual value to correct the
 *  supposed value of j(n,x).
 *
 *  yn(n,x) is similar in all respects, except
 *  that forward recursion is used for all
 *  values of n&gt;1.
 *  
 */

#include &quot;fdlibm.h&quot;

#ifdef __STDC__
    double jn(int n, double x)  /* wrapper jn */
#else
    double jn(n,x)          /* wrapper jn */
    double x; int n;
#endif
{
#ifdef _IEEE_LIBM
    return __ieee754_jn(n,x);
#else
    double z;
    z = __ieee754_jn(n,x);
    if(_LIB_VERSION == _IEEE_ || isnan(x) ) return z;
    if(fabs(x)&gt;X_TLOSS) {
        return __kernel_standard((double)n,x,38); /* jn(|x|&gt;X_TLOSS,n) */
    } else
        return z;
#endif
}

#ifdef __STDC__
    double yn(int n, double x)  /* wrapper yn */
#else
    double yn(n,x)          /* wrapper yn */
    double x; int n;
#endif
{
#ifdef _IEEE_LIBM
    return __ieee754_yn(n,x);
#else
    double z;
    z = __ieee754_yn(n,x);
    if(_LIB_VERSION == _IEEE_ || isnan(x) ) return z;
        if(x &lt;= 0.0){
                if(x==0.0)
                    /* d= -one/(x-x); */
                    return __kernel_standard((double)n,x,12);
                else
                    /* d = zero/(x-x); */
                    return __kernel_standard((double)n,x,13);
        }
    if(x&gt;X_TLOSS) {
        return __kernel_standard((double)n,x,39); /* yn(x&gt;X_TLOSS,n) */
    } else
        return z;
#endif
}
</code></pre>

<ul>
<li><strong><code>w_lgamma.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/* double lgamma(double x)
 * Return the logarithm of the Gamma function of x.
 *
 * Method: call __ieee754_lgamma_r
 */

#include &quot;fdlibm.h&quot;

extern int signgam;

#ifdef __STDC__
    double lgamma(double x)
#else
    double lgamma(x)
    double x;
#endif
{
#ifdef _IEEE_LIBM
    return __ieee754_lgamma_r(x,&amp;signgam);
#else
        double y;
        y = __ieee754_lgamma_r(x,&amp;signgam);
        if(_LIB_VERSION == _IEEE_) return y;
        if(!finite(y)&amp;&amp;finite(x)) {
            if(floor(x)==x&amp;&amp;x&lt;=0.0)
                return __kernel_standard(x,x,15); /* lgamma pole */
            else
                return __kernel_standard(x,x,14); /* lgamma overflow */
        } else
            return y;
#endif
}             
</code></pre>

<ul>
<li><strong><code>w_lgamma_r.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/* 
 * wrapper double lgamma_r(double x, int *signgamp)
 */

#include &quot;fdlibm.h&quot;


#ifdef __STDC__
    double lgamma_r(double x, int *signgamp) /* wrapper lgamma_r */
#else
    double lgamma_r(x,signgamp)              /* wrapper lgamma_r */
        double x; int *signgamp;
#endif
{
#ifdef _IEEE_LIBM
    return __ieee754_lgamma_r(x,signgamp);
#else
        double y;
        y = __ieee754_lgamma_r(x,signgamp);
        if(_LIB_VERSION == _IEEE_) return y;
        if(!finite(y)&amp;&amp;finite(x)) {
            if(floor(x)==x&amp;&amp;x&lt;=0.0)
                return __kernel_standard(x,x,15); /* lgamma pole */
            else
                return __kernel_standard(x,x,14); /* lgamma overflow */
        } else
            return y;
#endif
}             
</code></pre>

<ul>
<li><strong><code>w_log.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/*
 * wrapper log(x)
 */

#include &quot;fdlibm.h&quot;


#ifdef __STDC__
    double log(double x)        /* wrapper log */
#else
    double log(x)           /* wrapper log */
    double x;
#endif
{
#ifdef _IEEE_LIBM
    return __ieee754_log(x);
#else
    double z;
    z = __ieee754_log(x);
    if(_LIB_VERSION == _IEEE_ || isnan(x) || x &gt; 0.0) return z;
    if(x==0.0)
        return __kernel_standard(x,x,16); /* log(0) */
    else 
        return __kernel_standard(x,x,17); /* log(x&lt;0) */
#endif
}
</code></pre>

<ul>
<li><strong><code>w_log10.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/* 
 * wrapper log10(X)
 */

#include &quot;fdlibm.h&quot;


#ifdef __STDC__
    double log10(double x)      /* wrapper log10 */
#else
    double log10(x)         /* wrapper log10 */
    double x;
#endif
{
#ifdef _IEEE_LIBM
    return __ieee754_log10(x);
#else
    double z;
    z = __ieee754_log10(x);
    if(_LIB_VERSION == _IEEE_ || isnan(x)) return z;
    if(x&lt;=0.0) {
        if(x==0.0)
            return __kernel_standard(x,x,18); /* log10(0) */
        else 
            return __kernel_standard(x,x,19); /* log10(x&lt;0) */
    } else
        return z;
#endif
}
</code></pre>

<ul>
<li><strong><code>w_pow.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/* 
 * wrapper pow(x,y) return x**y
 */

#include &quot;fdlibm.h&quot;


#ifdef __STDC__
    double pow(double x, double y)  /* wrapper pow */
#else
    double pow(x,y)         /* wrapper pow */
    double x,y;
#endif
{
#ifdef _IEEE_LIBM
    return  __ieee754_pow(x,y);
#else
    double z;
    z=__ieee754_pow(x,y);
    if(_LIB_VERSION == _IEEE_|| isnan(y)) return z;
    if(isnan(x)) {
        if(y==0.0) 
            return __kernel_standard(x,y,42); /* pow(NaN,0.0) */
        else 
        return z;
    }
    if(x==0.0){ 
        if(y==0.0)
            return __kernel_standard(x,y,20); /* pow(0.0,0.0) */
        if(finite(y)&amp;&amp;y&lt;0.0)
            return __kernel_standard(x,y,23); /* pow(0.0,negative) */
        return z;
    }
    if(!finite(z)) {
        if(finite(x)&amp;&amp;finite(y)) {
            if(isnan(z))
                return __kernel_standard(x,y,24); /* pow neg**non-int */
            else 
                return __kernel_standard(x,y,21); /* pow overflow */
        }
    } 
    if(z==0.0&amp;&amp;finite(x)&amp;&amp;finite(y))
        return __kernel_standard(x,y,22); /* pow underflow */
    return z;
#endif
}
</code></pre>

<ul>
<li><strong><code>w_remainder.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/* 
 * wrapper remainder(x,p)
 */

#include &quot;fdlibm.h&quot;

#ifdef __STDC__
    double remainder(double x, double y)    /* wrapper remainder */
#else
    double remainder(x,y)           /* wrapper remainder */
    double x,y;
#endif
{
#ifdef _IEEE_LIBM
    return __ieee754_remainder(x,y);
#else
    double z;
    z = __ieee754_remainder(x,y);
    if(_LIB_VERSION == _IEEE_ || isnan(y)) return z;
    if(y==0.0) 
        return __kernel_standard(x,y,28); /* remainder(x,0) */
    else
        return z;
#endif
}
</code></pre>

<ul>
<li><strong><code>w_scalb.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/*
 * wrapper scalb(double x, double fn) is provide for
 * passing various standard test suite. One 
 * should use scalbn() instead.
 */

#include &quot;fdlibm.h&quot;

#include &lt;errno.h&gt;

#ifdef __STDC__
#ifdef _SCALB_INT
    double scalb(double x, int fn)      /* wrapper scalb */
#else
    double scalb(double x, double fn)   /* wrapper scalb */
#endif
#else
    double scalb(x,fn)          /* wrapper scalb */
#ifdef _SCALB_INT
    double x; int fn;
#else
    double x,fn;
#endif
#endif
{
#ifdef _IEEE_LIBM
    return __ieee754_scalb(x,fn);
#else
    double z;
    z = __ieee754_scalb(x,fn);
    if(_LIB_VERSION == _IEEE_) return z;
    if(!(finite(z)||isnan(z))&amp;&amp;finite(x)) {
        return __kernel_standard(x,(double)fn,32); /* scalb overflow */
    }
    if(z==0.0&amp;&amp;z!=x) {
        return __kernel_standard(x,(double)fn,33); /* scalb underflow */
    } 
#ifndef _SCALB_INT
    if(!finite(fn)) errno = ERANGE;
#endif
    return z;
#endif 
}
</code></pre>

<ul>
<li><strong><code>w_sinh.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/* 
 * wrapper sinh(x)
 */

#include &quot;fdlibm.h&quot;

#ifdef __STDC__
    double sinh(double x)       /* wrapper sinh */
#else
    double sinh(x)          /* wrapper sinh */
    double x;
#endif
{
#ifdef _IEEE_LIBM
    return __ieee754_sinh(x);
#else
    double z; 
    z = __ieee754_sinh(x);
    if(_LIB_VERSION == _IEEE_) return z;
    if(!finite(z)&amp;&amp;finite(x)) {
        return __kernel_standard(x,x,25); /* sinh overflow */
    } else
        return z;
#endif
}
</code></pre>

<ul>
<li><strong><code>w_sqrt.c</code>文件</strong></li>
</ul>
<pre><code class="c++">/* 
 * wrapper sqrt(x)
 */

#include &quot;fdlibm.h&quot;

#ifdef __STDC__
    double sqrt(double x)       /* wrapper sqrt */
#else
    double sqrt(x)          /* wrapper sqrt */
    double x;
#endif
{
#ifdef _IEEE_LIBM
    return __ieee754_sqrt(x);
#else
    double z;
    z = __ieee754_sqrt(x);
    if(_LIB_VERSION == _IEEE_ || isnan(x)) return z;
    if(x&lt;0.0) {
        return __kernel_standard(x,x,26); /* sqrt(negative) */
    } else
        return z;
#endif
}
</code></pre>

<ul>
<li><strong><code>k_sin.c</code>文件</strong></li>
</ul>
<pre><code class="c">/*
__kernel_sin( x, y, iy)
    kernel sin function on [-pi/4, pi/4], pi/4 ~ 0.7854
    Input x is assumed to be bounded by ~pi/4 in magnitude.
    Input y is the tail of x.
    Input iy indicates whether y is 0. (if iy=0, y assume to be 0).

Algorithm
    1. Since sin(-x) = -sin(x), we need only to consider positive x.
    2. if x &lt; 2^-27 (hx&lt;0x3e400000 0), return x with inexact if x!=0.
    3. sin(x) is approximated by a polynomial of degree 13 on [0,pi/4]
                       3            13
          sin(x) ~ x + S1*x + ... + S6*x
        where
            |sin(x)          2     4     6     8    10    12  | -58
            |----- -   (1+S1*x +S2*x +S3*x +S4*x +S5*x  +S6*x)| &lt;= 2
            |  x                               |
    4. sin(x+y) = sin(x) + sin'(x')*y ~ sin(x) + (1-x*x/2)*y
            For better accuracy, let
               3      2      2      2      2
         r = x *(S2+x *(S3+x *(S4+x *(S5+x *S6))))
            then                   3    2
         sin(x) = x + (S1*x + (x *(r-y/2)+y))
 */

#include &quot;fdlibm.h&quot;

#ifdef __STDC__
    static const double
#else
    static double
#endif
half =  5.00000000000000000000e-01, /* 0x3FE00000, 0x00000000 */
S1  = -1.66666666666666324348e-01, /* 0xBFC55555, 0x55555549 */
S2  =  8.33333333332248946124e-03, /* 0x3F811111, 0x1110F8A6 */
S3  = -1.98412698298579493134e-04, /* 0xBF2A01A0, 0x19C161D5 */
S4  =  2.75573137070700676789e-06, /* 0x3EC71DE3, 0x57B1FE7D */
S5  = -2.50507602534068634195e-08, /* 0xBE5AE5E6, 0x8A2B9CEB */
S6  =  1.58969099521155010221e-10; /* 0x3DE5D93A, 0x5ACFD57C */

#ifdef __STDC__
    double __kernel_sin(double x, double y, int iy)
#else
    double __kernel_sin(x, y, iy)
    double x,y; int iy;     /* iy=0 if y is zero */
#endif
{
    double z,r,v;
    int ix;
    ix = __HI(x)&amp;0x7fffffff;            /* high word of x */
    if(ix&lt;0x3e400000)                   /* |x| &lt; 2**-27 */
       {if((int)x==0) return x;}        /* generate inexact */
    z   =  x*x;
    v   =  z*x;
    r   =  S2+z*(S3+z*(S4+z*(S5+z*S6)));
    if(iy==0) return x+v*(S1+z*r);
    else      return x-((z*(half*y-v*r)-y)-v*S1);
}
</code></pre>

  <br>
    <style>
blockquote{
    font-size: 99%;
}
</style>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  CommonHTML: {
    scale: 100
  }
});
</script>
<script type="text/javascript" async
src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


    
    
      
    

    <br>
</div>

</body>
</html>